{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: lx.apply.r 293 2017-08-06 12:09:04Z viari $\n#\n# lx apply functions\n#\n\n# =================================================\n# progress bar (PG)\n# based on Mark Heckman post : \n# http://ryouready.wordpress.com/2010/01/11/progress-bars-in-r-part-ii-a-wrapper-for-apply-functions/\n#\n\n# -------------------------------------------------------\n# <internal> PG generic function for [s|l]apply\n#\n.lx.pg.meta <- function(METAFUN, X, MARGIN=NULL, FUN, ...) {\n  env <- environment()\n  total <- if (is.null(MARGIN)) length(X) else sum(dim(X)[MARGIN])\n  counter <- 0\n  pb <- txtProgressBar(min = 0, max = total, style = lx.options('pg.options.style'))\n  \n  wrapper <- function(...) {\n    curVal <- get(\"counter\", envir = env)\n    assign(\"counter\", curVal + 1 ,envir= env)\n    setTxtProgressBar(get(\"pb\", envir= env), curVal +1)\n    FUN(...)\n  }\n  \n  tim <- system.time(res <- if (is.null(MARGIN)) METAFUN(X, wrapper, ...)\n                            else                 METAFUN(X, MARGIN, wrapper, ...))\n  \n  if (lx.options('pg.options.time')) print(tim)\n  \n  close(pb)\n  res\n}\n\n# =================================================\n# multicore functions\n#\n\n# ---------------------------------------------\n#' tell if lx can use multithreading\n#' @description\n#' multithreading is on when\n#' lx.options(use.threads) is TRUE\n#' and lx.options(mc.cores) > 1\n#' @note\n#' threads are implemented in the \\code{parallel}\n#' library by using \\code{fork}, and will\n#' run parallel processes even if lx.options(mc.cores)\n#' is greater than the actual number of cores. In this case\n#' the overall process may slow donw considerably.\n#'\nlx.use.threads <- function() {\n  lx.options('use.threads') && (lx.options('mc.cores') > 1)\n}\n\n# =================================================\n# apply wrappers\n#\n\n# ---------------------------------------------\n#' apply wrapper\n#' @description\n#' \\code{lx.apply} will call different \\link{apply} flavors\n#' depending upon the \\code{pg.verbose}.argument:\\cr\n#' if pg.verbose is TRUE then\\cr\n#' __use \\link{apply} with progress bar\\cr\n#' else\\cr\n#' __use \\link{apply} without progress bar\\cr\n#'\n#' @param X an array, including a matrix. see \\link{apply}.\n#' @param MARGIN a vector giving the subscripts which the\n#' function will be applied over. see \\link{apply}.\n#' @param FUN the function to be applied. see \\link{apply}.\n#' @param ... anything passed to FUN. see \\link{apply}.\n#' @param pg.verbose use progress bar\n#' @note\n#' default value for  \\code{pg.verbose} is taken from \\link{lx.options}\n#' and may therefore be controlled globally.\n#' @note\n#' there is no multithread flavor yet, see \\link{lx.rowapply}, \\link{lx.lapply}\n#' @examples\n#' n <- 100\n#' lx.options(pg.verbose=TRUE)\n#' system.time(x <- lx.apply(matrix(1:n, ncol=2), 1, function(x) sum(rnorm(5000*sum(x)))))\n#' lx.options(pg.verbose=FALSE)\n#' system.time(x <- lx.apply(matrix(1:n, ncol=2), 1, function(x) sum(rnorm(5000*sum(x)))))\n#'\nlx.apply <- function(X, MARGIN, FUN, ...,\n                        pg.verbose=lx.options('pg.verbose')) {\n  if (pg.verbose) {\n    .lx.pg.meta(apply, X, MARGIN, FUN, ...)\n  }\n  else {\n    apply(X, MARGIN, FUN, ...)\n  }\n}\n\n# ---------------------------------------------\n#' lapply wrapper\n#' @description\n#' \\code{lx.lapply} will call different \\link{lapply} flavors\n#' depending upon the \\code{use.threads} and \\code{pg.verbose}.\n#' arguments:\\cr\n#' if use.threads is TRUE then\\cr\n#' __use \\link{mclapply}\\cr\n#' else if pg.verbose is TRUE then\\cr\n#' __use \\link{lapply} with progress bar\\cr\n#' else\\cr\n#' __use \\link{lapply} without progress bar\\cr\n#' @param X an array, including a matrix. see \\link{lapply}.\n#' @param FUN the function to be applied. see \\link{lapply}.\n#' @param ... anything passed to FUN. see \\link{lapply}.\n#' @param pg.verbose use progress bar\n#' @param use.threads use multithreading\n#' @param mc.cores The number of cores to use. see \\link{mclapply}.\n#' @param mc.preschedule perform prescheduling. see \\link{mclapply}.\n#' @param mc.allow.recursive allow recursive call. see \\link{mclapply}.\n#' @note\n#' default value for \\code{use.threads} and \\code{pg.verbose} are \n#' taken from \\link{lx.options}\n#' and may therefore be controlled globally.\n#' @seealso \\link{lx.happly} for a version dulpicating file handle.\n#'\n#' @examples\n#' n <- 100\n#' lx.options(pg.verbose=TRUE)\n#' system.time(x <- lx.lapply(1:n, function(x) rnorm(5000*x)))\n#' lx.options(pg.verbose=FALSE)\n#' system.time(x <- lx.lapply(1:n, function(x) rnorm(5000*x)))\n#'\nlx.lapply <- function(X, FUN, ..., pg.verbose=lx.options('pg.verbose'),\n                                   use.threads=lx.use.threads(),\n                                   mc.cores=lx.options('mc.cores'),\n                                   mc.preschedule=TRUE,\n                                   mc.allow.recursive=FALSE) {\n  if (use.threads) {\n    parallel::mclapply(X, FUN, ..., mc.cores=mc.cores,\n                                    mc.preschedule=mc.preschedule,\n                                    mc.allow.recursive=mc.allow.recursive)\n  }\n  else if (pg.verbose) {\n    .lx.pg.meta(lapply, X, MARGIN=NULL, FUN, ...)\n  }\n  else {\n    lapply(X, FUN, ...)\n  }\n}\n\n# ---------------------------------------------\n#' sapply wrapper\n#' @description\n#' \\code{lx.sapply} will call different \\link{sapply} flavors\n#' depending upon the \\code{pg.verbose}.argument:\\cr\n#' if pg.verbose is TRUE then\\cr\n#' __use \\link{sapply} with progress bar\\cr\n#' else\\cr\n#' __use \\link{sapply} without progress bar\\cr\n#' @inheritParams lx.lapply\n#' @note\n#' default value for  \\code{pg.verbose} is taken from \\link{lx.options}\n#' and may therefore be controlled globally.\n#' @note\n#' there is no multithread flavor yet, see \\link{lx.lapply}\n#'\n#' @examples\n#' n <- 100\n#' lx.options(pg.verbose=TRUE)\n#' system.time(x <- lx.sapply(1:n, function(x) rnorm(5000*x)))\n#' lx.options(pg.verbose=FALSE)\n#' system.time(x <- lx.sapply(1:n, function(x) rnorm(5000*x)))\n#'\nlx.sapply <- function(X, FUN, ..., pg.verbose=lx.options('pg.verbose')) {\n  if (pg.verbose) {\n    .lx.pg.meta(sapply, X, MARGIN=NULL, FUN, ...)\n  }\n  else {\n    sapply(X, FUN, ...)\n  }\n}\n\n# ---------------------------------------------\n#' mapply wrapper\n#' @description\n#' \\code{lx.mapply} will call different \\link{mapply} flavors\n#' depending upon the \\code{use.threads}.argument:\\cr\n#' if use.threads is TRUE then\\cr\n#' __use \\link{mcmapply}\\cr\n#' else\\cr\n#' __use \\link{mapply} (without progress bar)\\cr\n#' @param FUN the function to be applied. see \\link{mapply}.\n#' @param ... arguments to vectorize over. see \\link{mapply}.\n#' @param MoreArgs a list of other arguments to FUN. see \\link{mapply}.\n#' @param SIMPLIFY see \\link{mapply}.\n#' @param USE.NAMES see \\link{mapply}.\n#' @inheritParams lx.lapply\n#' @note\n#' default value for  \\code{pg.verbose} is taken from \\link{lx.options}\n#' and may therefore be controlled globally.\n#' @note\n#' default values for \\code{SIMPLIFY} and \\code{USE.NAMES} is \\code{TRUE}\n#' as in \\link{mapply}, this usually slow down process considerably,\n#' you should consider using \\code{FALSE} instead to speed up computations.\n#' @note\n#' there is no mc.allow.recursive option in parallel::mcmapply.\n#' don't ask me why... but the consequence is that the behavior\n#' in case of a recursive call in child process is udefined.\n#' @note\n#' there is no progress bar flavor yet\n#'\n#' @examples\n#' n <- 100\n#' system.time(x <- lx.mapply(function(x, y) rnorm(5000*(x+y)), 1:n, 1:n))\n#' system.time(x <- lx.mapply(function(x, y) rnorm(5000*(x+y)), 1:n, 1:n, use.threads=TRUE))\n#'\nlx.mapply <- function(FUN, ..., MoreArgs=NULL, SIMPLIFY=TRUE, USE.NAMES=TRUE,\n                                   use.threads=lx.use.threads(), \n                                   mc.cores=lx.options('mc.cores'),\n                                   mc.preschedule=TRUE) {\n  if (use.threads) {\n    parallel::mcmapply(FUN, ..., MoreArgs=MoreArgs, SIMPLIFY=SIMPLIFY, USE.NAMES=USE.NAMES,\n                                   mc.cores=mc.cores,\n                                   mc.preschedule=mc.preschedule)\n  }\n  else {\n    mapply(FUN, ..., MoreArgs=MoreArgs, SIMPLIFY=SIMPLIFY, USE.NAMES=USE.NAMES)\n  }\n}\n\n# ---------------------------------------------\n#' mapply with names\n#' @description\n#' \\code{lx.napply(X, FUN, ...} is functionally equivalent\n#' to: \\cr\n#' \\code{lx.mapply(FUN, names(X), X, ...)}\\cr\n#' and ensures that names(X) is not NULL\\cr\n#' FUN should therefore take at least two arguments FUN(name, x, ...)\\cr\n#' @param X an array\n#' @inheritParams lx.mapply\n#' @note\n#' as an exception in the \\code{lx.?apply} family, the default behavior is no thread\n#' @note\n#' default values for \\code{SIMPLIFY} and \\code{USE.NAMES} is \\code{TRUE}\n#' as in \\link{lx.mapply}, this usually slow down process considerably,\n#' you should consider using \\code{FALSE} instead to speed up computations.\n#' @examples\n#' ll <- list(a=1, b=2, c=3)\n#' lx.napply(ll, function(nam, val) paste(nam, val, sep=\".\"))\n#'\nlx.napply <- function(X, FUN, ..., use.threads=FALSE) {\n  nam <- names(X)\n  if (is.null(nam))\n    nam <- rep(\"\", length(X))\n  lx.mapply(FUN, nam, X, ..., use.threads=use.threads)\n}\n\n# ---------------------------------------------\n#' apply function on each row of a data.frame (or matrix).\n#' @description\n#' \\link{apply} sucks because it coerces its input to an array\n#' before applying function. In case of a data.frame this will\n#' coerce all data to the same type (usually character).\\cr\n#' this function performs as \\code{apply(X, 1, FUN, ...)}\n#' but passing a correctly typed (and named) row to FUN.\\cr\n#' In addition it can be multithreaded as \\link{lx.lapply}.\\cr\n#' Note that there is no \\code{'lx.colapply'} equivalent \n#' since \\code{lapply} (and \\code{lx.lapply}) will usually \n#' do the (per column) job on a dataframe.\n#' @param X an array\n#' @param FUN the function to be applied. see \\link{lapply}.\n#' @param ... anything passed to FUN. see \\link{lapply}.\n#' @param as.list if TRUE return result as a list of FUN results per row\\cr\n#' else returns a data.frame or a vector (see below)\n#' @param SIMPLIFY if result has only one column convert it to vector\n#' @param stringsAsFactors should character columns be converted to factors\n#' @inheritParams lx.lapply\n#' @return if \\code{as.list==TRUE} returns a list else returns \n#' a data.frame or a vector if there is only one column and SIMPLIFY==TRUE.\n#' @note\n#' when \\code{as.list==FALSE} (default) all results from \\code{FUN}\n#' should be of the same size to be properly rehaped to a data.frame\n#' @examples\n#' data(iris)\n#' x <- lx.rowapply(iris, function(x) x$Sepal.Width * x$Sepal.Length)\n#' identical(x, iris$Sepal.Width * iris$Sepal.Length)\n#' x <- lx.rowapply(iris, function(x) list(area=x$Sepal.Width * x$Sepal.Length, \n#'                                         name=x$Species))\n#'\nlx.rowapply <- function(X, FUN, ..., \n                        as.list=FALSE,\n                        SIMPLIFY=TRUE,\n                        stringsAsFactors=default.stringsAsFactors(),\n                        pg.verbose=lx.options('pg.verbose'),\n                        use.threads=lx.use.threads(),\n                        mc.cores=lx.options('mc.cores'),\n                        mc.preschedule=TRUE,\n                        mc.allow.recursive=FALSE) {\n  \n  if (length(dim(X)) != 2) {\n    lx.warn(\"dim(X) must be of length 2\")\n    return(NULL)\n  }\n  \n  res <- lx.lapply(seq_len(nrow(X)), function(irow) {\n    row <- X[irow,]\n    FUN(row, ...)\n  }, pg.verbose=pg.verbose, use.threads=use.threads,\n     mc.cores=mc.cores, mc.preschedule=mc.preschedule,\n     mc.allow.recursive=mc.allow.recursive)\n  \n  if (as.list) return(res)\n  \n  # reshape as dataframe\n  \n  res <- as.data.frame(do.call(rbind, res),\n                       stringsAsFactors=stringsAsFactors)\n  \n  # unlist each column\n  \n  res <- as.data.frame(lapply(res, unlist, recursive=F, use.names=F),\n                       stringsAsFactors=stringsAsFactors)\n\n  if (SIMPLIFY && (ncol(res) == 1))\n    res <- res[,1]\n  \n  res\n}\n\n# ---------------------------------------------\n#' Filter wrapper\n#' @description\n#' just like \\link{Filter} but using \\link{lx.lapply}\n#' internally.\n#' @inheritParams lx.lapply\n#' @examples\n#' lx.options(pg.verbose=TRUE)\n#' lx.Filter(function(x) x%%2==0, 1:10)\n#' lx.options(pg.verbose=FALSE)\n#' lx.Filter(function(x) x%%2==0, 1:10)\n#'\nlx.Filter <- function(FUN, X,\n                      pg.verbose=lx.options('pg.verbose'),\n                      use.threads=lx.use.threads(), \n                      mc.cores=lx.options('mc.cores'),\n                      mc.preschedule=TRUE,\n                      mc.allow.recursive=FALSE) {\n\n    ind <- as.logical(unlist(lx.lapply(X, FUN,\n                                       pg.verbose=pg.verbose,\n                                       use.threads=use.threads, \n                                       mc.cores=mc.cores,\n                                       mc.preschedule=mc.preschedule,\n                                       mc.allow.recursive=mc.allow.recursive)))\n    X[!is.na(ind) & ind]\n}\n\n# ---------------------------------------------\n#' Map wrapper\n#' @description\n#' just like \\link{Map} but using \\link{lx.mapply}\n#' internally\\cr\n#' @inheritParams lx.mapply\n#' \nlx.Map <- function (FUN, ..., use.threads=lx.use.threads()) {\n    FUN <- match.fun(FUN)\n    lx.mapply(FUN=FUN, ..., SIMPLIFY = FALSE, use.threads=use.threads)\n}\n\n# -------------------------------------------------\n#' lx.lapply with duplicated file handle\n#' @description\n#' a version of \\link{lx.lapply} that duplicates the file handle\n#' \\code{handle} in each thread.\n#' this is useful when \\code{FUN} needs read access to file since\n#' the file descriptor will be different in each thread.\\cr\n#' warning: don't use for write access since the write position\n#' is unpredictable.\n#' @inheritParams lx.lapply\n#' @param handle a file handle (see \\link{HELP.FILE.HANDLE})\\cr\n#' @note\n#' user's function \\code{FUN} has the form \\code{FUN(x, handle, ...)}\n#'\nlx.happly <- function(X, FUN, handle, ..., pg.verbose=lx.options('pg.verbose'),\n                                   use.threads=lx.use.threads(),\n                                   mc.cores=lx.options('mc.cores')) {\n\n   # no thread\n   if (! use.threads)\n     return(lapply(X, FUN, handle, ...))\n     \n   #\n   # split input list into 'mc.cores' chunks\n   #\n   len    <- length(X)\n   lx.out(\"splitting \", len, \" elements by \", mc.cores, \" threads\", level=\"debug\")\n   chunks <- rep(1:mc.cores, length.out=len)\n\n   X <- split(X, chunks)\n   \n   #\n   # run mcapply on each chunk in turn (i.e. with 1 core per chunk)\n   #\n   res <- parallel::mclapply(X, function(y, handle, ...) {\n   \n     # duplicate file handle\n     handle <- lx.dup.handle(handle)\n\n     # run user function in each thread\n     lx.out(\"running FUN in thread\", level=\"debug\")\n     res <- lapply(y, FUN, handle, ...)\n     \n     # close dup file handle\n     lx.close(handle)\n     \n     res\n   }, handle, ..., mc.cores=mc.cores,\n                   mc.preschedule=FALSE,\n                   mc.allow.recursive=FALSE)\n   \n   #\n   # flatten results\n   #\n   lx.out(\"unsplitting chunks\", level=\"debug\")\n   unsplit(res, chunks)\n}\n",
    "created" : 1501934128076.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3968485001",
    "id" : "2944E11F",
    "lastKnownWriteTime" : 1502021345,
    "last_content_update" : 0,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/lx/R/lx.apply.r",
    "project_path" : "R/lx.apply.r",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}