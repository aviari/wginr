{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: lx.fileio.r 131 2016-11-05 19:10:30Z viari $\n# lx file io utilities\n#\n\n# -------------------------------------------------\n#' @name HELP.FILE.HANDLE\n#' @docType data\n#' @title lx binary file handle\n#' @description\n#' a file \\code{handle} (called handle for short) \n#' is an R object (see notes) wrapping a binary file connection.\n#' (do not confuse with a \\link{HELP.FILE.HANDLER})\\cr\n#' It is intended to provide a uniform interface for different\n#' file types within \\bold{lx} and its extensions.\n#'\n#' a \\code{handle} contains four mandatory fields:\n#' \\itemize{\n#'  \\item filename : a character string containing the file name (or url)\n#'  \\item type     : a character string containing the file content type (default is \"none\")\n#'  \\item mode     : a character string containing the file opening mode in \\link{lx.open}\n#'  \\item connect  : an R object containing the file physical connection, the type depends upon file type\n#'  \\item handler  : a file handler object. see \\link{HELP.FILE.HANDLER}\n#' }\n#'\n#' and some optional fields:\n#' \\itemize{\n#'  \\item header   : file specific information (header, e.g. index table)\n#' }\n#' \n#' \\code{handle}s are openened and closed thru\n#' \\link{lx.open} and \\link{lx.close} functions.\\cr\n#'\n#' files are opened as binary and lx provides the following\n#' binary IO functions to read fixed length bytes from them.\n#' \\itemize{\n#'  \\item \\link{lx.read.int8}  : 8 bits integer(s)\n#'  \\item \\link{lx.read.int16} : 16 bits integer(s)\n#'  \\item \\link{lx.read.int32} : 32 bits integer(s)\n#'  \\item \\link{lx.read.int64} : 64 (actually 53) bits integer(s)\n#'  \\item \\link{lx.read.string} : basta string\n#' }\n#'\n#' @note\n#' in practice a FILE.HANDLE is currently implemented as an R environment\n#' @note\n#' no write operations yet... time is short.\n#' \nNULL\n\n# -------------------------------------------------\n#' @name HELP.FILE.HANDLER\n#' @docType data\n#' @title lx binary file handler\n#' @description\n#' a file \\code{handler} (called handler for short) \n#' is an R object (see notes) wrapping binary file IO operations\n#' (do not confuse with a \\link{HELP.FILE.HANDLE}).\\cr\n#'\n#' a \\code{handler} should implement all the following operations:\n#' \\itemize{\n#'  \\item accept   : tell if file can be handled by this handler\n#'  \\item open     : open file\n#'  \\item close    : close file\n#'  \\item seek     : tell/seek into file\n#'  \\item read     : read n bytes from file\n#' }\n#' API for these functions:\\cr\n#' \\preformatted{\n#'   accept(filename, mode)\n#'     filename: character string, name of file (see base::open)\n#'     mode: character string, open mode (see base::open)\n#'   returns logical TRUE if the file can be handled by this handler\n#'     \n#'   open(filename, mode)\n#'     filename: character string, name of file (see base::open)\n#'     mode: character string, open mode (see base::open)\n#'   returns physical connection\n#'   \n#'   close(con)\n#'     con: physical connection\n#'   returns (ignored)\n#'   \n#'   seek(con, ...)\n#'     con: physical connection\n#'     ...: optional position (see lx::lx.seek)\n#'   returns current position in file as a (numeric) byte offset from the origin\n#'   \n#'   read(con, n=1L)\n#'     con: physical connection\n#'     n: integer The (maximal) number of bytes to be read\n#'   returns a raw vector of at most n bytes (less if EOF reached)\n#' }\n#' @note \n#' handlers have to be registered thru \\link{lx.register.file.handler}.\\cr\n#' \\code{lx} maintain a stack of handlers that are used from top to bottom\n#' when opening a file (thru \\link{lx.open}). the first handler accepting\n#' the filename argument (thru \\code{accept}) is selected.\\cr\n#' by default, a R binary file (accepting anything) is registered at the lowest\n#' stack position with name \"default\".\n#' @note\n#' in practice a FILE.HANDLER is currently implemented as an R environment\n#' \nNULL\n\n# -------------------------------------------------\n# <internal> default file handler\n#\n.dft.handler <- function(name) {\n  h <- new.env(hash=TRUE, parent=emptyenv())\n  h$name    <- name\n  h$accept  <- function(...) TRUE # accept anything\n  h$open    <- function(filename, mode) file(filename, open=mode,\n                                             blocking=TRUE, encoding=\"\",\n                                             raw=FALSE)\n  h$close    <- close\n  h$seek     <- seek\n  h$read     <- compiler::cmpfun(function(con, n=1L) readBin(con=con, what=\"raw\", n=n))\n  h\n}\n\n# -------------------------------------------------\n# <internal> lookup file handler by name or accept\n#\n.lookup.handler <- function(name, mode=NULL) {\n  for (h in .lx.env$file.handlers) {\n    if (if (is.null(mode)) (h$name %in% name) else h$accept(name, mode))\n      return(h)\n  }\n  return()\n}\n\n# -------------------------------------------------\n#' create a default file handler\n#' @description the default file handler handles usual R\n#' binary files.\n#' @param name handler name\n#' @details a default handler (with name \"default\") is always \n#' added at the lowest position in handlers stack. So, usually\n#' you don't need to call this function. It is mostly intented\n#' for the case where you want to design your own handler, not\n#' starting from scratch. A typical case is to create a default\n#' R file handler and to override the \\code{accept} function to\n#' specify which files to accept.\n#\nlx.default.file.handler <- function(name) {\n  .dft.handler(name)\n}\n\n# -------------------------------------------------\n#' register handler\n#' @description register handler at topmost position in handlers stack\n#' @param handler : file handler\n#' @note if a handler with same name already exists in stack it is first\n#'       removed and the new handler is added topmost.\n#' \nlx.register.file.handler <- function(handler) {\n  h <- .lookup.handler(handler$name)\n  if (! is.null(h)) lx.remove.file.handler(h$name)\n  .lx.env$file.handlers <- c(list(handler), .lx.env$file.handlers)\n  invisible(handler)\n}\n\n# -------------------------------------------------\n#' remove file handler(s)\n#' @description remove handler from handlers stack\n#' @param name : name(s) of handler(s) to remove\n#' @return NULL\n#\nlx.remove.file.handler <- function(name) {\n  indx <- which(sapply(.lx.env$file.handlers, function(h) h$name %in% name))\n  .lx.env$file.handlers[indx] <- NULL\n  invisible()\n}\n\n# -------------------------------------------------\n#' open (binary) file\n#' @param filename file name\n#' @param mode open mode (see \\link{HELP.FILE.HANDLE})\n#' @param .handler force use of given handler name (internal use only)\n#' @return file handle\n#' @note if you force handler (thru .handler) the handler$accept test function\n#' will not be called.\n#' @seealso \\link{HELP.FILE.HANDLE}\n#'\nlx.open <- function(filename, mode=\"rb\", .handler=NULL) {\n  handle <- new.env(hash=TRUE, parent=emptyenv())\n  handle$filename <- filename\n  handle$type <- \"none\"\n  handle$mode <- mode\n  handle$handler <- if (is.null(.handler)) .lookup.handler(filename, mode)\n                    else .lookup.handler(.handler)\n  if (is.null(handle$handler))\n    stop(\"cannot find handler for file: \", filename)\n  lx.out(\"file handler: \", handle$handler$name, level=\"debug\")\n  handle$connect <- handle$handler$open(filename, mode)\n  handle$is.open <- ! is.null(handle$connect)\n  class(handle) <- c(\"LXFileHandle\", class(handle))\n  handle\n}\n\n# -------------------------------------------------\n#' close file handle\n#' @param handle file handle (opened by \\link{lx.open})\n#' @return handle (modified)\n#' @note you should reassign handle on return since\n#' some internal fields have been modified\n#'\nlx.close <- function(handle) {\n  if (handle$is.open)\n    handle$handler$close(handle$connect)\n  handle$is.open <- FALSE\n  handle\n}\n\n# -------------------------------------------------\n#' tell/seek file\n#' @description\n#' reposition file handle opened by \\link{lx.open}\n#' @details\n#' if ... is absent then returns current position (ftell) else\n#' set the position to (numeric) argument.\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param ... optional position in file\n#' @return current position (before any move) as a (numeric) byte offset from the origin.\n#' @note\n#' for default (R) handler, position may exceed 32 bit integer.\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' cod  <- lx.read.int32(fh, n=1)\n#' pos <- lx.seek(fh)\n#' nseq <- lx.read.int32(fh, n=1)\n#' lx.seek(fh, 0)\n#' cod  <- lx.read.int32(fh, n=1)\n#' nseq <- lx.read.int32(fh, n=1)\n#' lx.seek(fh, pos)\n#' nseq <- lx.read.int32(fh, n=1)\n#' lx.close(fh)\n#'\nlx.seek <- function(handle, ...) {\n  handle$handler$seek(handle$connect, ...)\n}\n\n# -------------------------------------------------\n#' rewind file handle\n#' @description\n#' rewind file handle opened by \\link{lx.open}\n#' @param handle file handle (opened by \\link{lx.open})\n#' @return handle (invisible)\n#' @note\n#' this is a shorthand for \\code{lx.seek(handle, 0)}\n#'\nlx.rewind <- function(handle) {\n  lx.seek(handle, 0)\n}\n\n# -------------------------------------------------\n#' duplicate file handle\n#' @description\n#' duplicate file handle with a new physical connection\n#' @details\n#' this is mostly used in multithreading when accessing the same file\n#' (in read mode) by multiple threads.\n#' @param handle file handle (opened by \\link{lx.open})\n#' @return duplicated file handle\n#'\nlx.dup.handle <- function(handle) {\n  dup <- lx.open(handle$filename, handle$mode, .handler=handle$handler$name)\n  handle$connect <- dup$connect\n  handle\n}\n\n# -------------------------------------------------\n#' read binary 8 bits integer(s)\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param n number of integers to read\n#' @param signed read signed integer(s)\n#' @return (vector of) integer(s)\n#' @note n is an integer, therefore limited to 2,147,483,647\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' x <- lx.read.int8(fh, n=4)\n#' lx.close(fh)\n#\nlx.read.int8 <- function(handle, n=1L, signed=FALSE) {\n  # this is quicker than readBin\n  r <- as.integer(handle$handler$read(handle$connect, n=n))\n  if (signed)\n    r[r > 0x7FL] <- r[r > 0x7FL] - 0x100L\n  r\n}\n\n# -------------------------------------------------\n#' read binary 16 bits integer(s)\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param n number of integers to read\n#' @param signed read signed integer(s)\n#' @param little.endian integer encoding is little endian\n#' @return (vector of) integer(s)\n#' @note n is an integer, therefore limited to 2,147,483,647\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' x <- lx.read.int16(fh, n=2)\n#' lx.close(fh)\n#\nlx.read.int16 <- function(handle, n=1L, signed=FALSE, little.endian=TRUE) {\n  \n  r <- as.integer(handle$handler$read(handle$connect, n=2L*n))\n  \n  # explicit conversion is quicker than readBin\n  \n  if (little.endian) {\n    s0 <- r[c(T,F)]\n    s1 <- r[c(F,T)]\n  } else {\n    s0 <- r[c(F,T)]\n    s1 <- r[c(T,F)]\n  }\n  \n  if (signed)\n    s1[s1 > 0x7FL] <- s1[s1 > 0x7FL] - 0x100L\n  \n  s0 + 0x100L * s1\n}\n\n# -------------------------------------------------\n#' read binary 32 bits integer(s)\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param n number of integers to read\n#' @param signed read signed integer(s)\n#' @param little.endian integer encoding is little endian\n#' @return (vector of) integer(s) if signed == TRUE\n#' else (vector of) double(s) without loss of precision\n#' @note n is an integer, therefore limited to 2,147,483,647\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' cod  <- lx.read.int32(fh, n=1)\n#' nseq <- lx.read.int32(fh, n=1)\n#' s1 <- lx.read.string(fh)\n#' siz1 <- lx.read.int64(fh, n=1) # 24\n#' crc1 <- lx.read.int32(fh, n=1)\n#' s2 <- lx.read.string(fh)\n#' siz2 <- lx.read.int64(fh, n=1) # 32\n#' crc2 <- lx.read.int32(fh, n=1)\n#' ss1 <- lx.read.char(fh, n=siz1) # \"ACGTACGTACGTAAAAACGTACGT\"\n#' ss2 <- lx.read.char(fh, n=siz2) # \"GCGCGCGCGCGCGCGCGCGCGCGCTTTTTATATATATAX\"\n#' lx.close(fh)\n#'\nlx.read.int32 <- function(handle, n=1L, signed=FALSE, little.endian=TRUE) {\n\n  r <- handle$handler$read(handle$connect, n=4L*n)\n  \n  # readBin is quicker than explicit conversion\n  r <- readBin(r, \"integer\", size=4, signed=TRUE, n=n,\n               endian=ifelse(little.endian, \"little\", \"big\"))\n\n  if (! signed) {\n    r <- as.double(r)\n    r[r < 0] <- r[r < 0] + 0x100000000\n  }\n  r  \n}\n\n# -------------------------------------------------\n#' read binary 64 (actually 53) bits integer\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param n number of integers to read\n#' @param signed read signed integer(s)\n#' @param little.endian integer encoding is little endian\n#' @return (vector of) double(s) with possible precision loss.\n#' @note\n#' since R double have 53 bits precision the return\n#' values are only exact for values in range\n#' \\code{[-2^53, 2^53] = [-9007199254740992,9007199254740992] for signed long}\n#' and \\code{[0, 2^53] = [0, 9007199254740992] for unsigned long}\n#' @note n is an integer, therefore limited to 2,147,483,647\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' cod  <- lx.read.int32(fh, n=1)\n#' nseq <- lx.read.int32(fh, n=1)\n#' s1 <- lx.read.string(fh)\n#' siz1 <- lx.read.int64(fh, n=1)\n#' crc1 <- lx.read.int32(fh, n=1)\n#' s2 <- lx.read.string(fh)\n#' siz2 <- lx.read.int64(fh, n=1)\n#' crc2 <- lx.read.int32(fh, n=1)\n#' ss1 <- lx.read.char(fh, n=siz1)\n#' ss2 <- lx.read.char(fh, n=siz2)\n#' lx.close(fh)\n#\nlx.read.int64 <- function(handle, n=1L, signed=FALSE, little.endian=TRUE) {\n\n  r <- lx.read.int32(handle, n=2*n, signed=FALSE, little.endian=little.endian)\n  \n  if (little.endian) {\n    s0 <- r[c(T,F)]\n    s1 <- r[c(F,T)]\n  } else {\n    s0 <- r[c(F,T)]\n    s1 <- r[c(T,F)]\n  }\n\n  if (signed)\n    s1[s1 > 0x7FFFFFFF] <- s1[s1 > 0x7FFFFFFF] - 0x100000000\n  \n  s0 + s1 * 0x100000000 \n}\n\n# -------------------------------------------------\n#' read character(s)\n#' @description\n#' read characters from file handle stopping or not on\n#' NULL chars.\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param n integer, (maximum) number of chars to read\n#' @param skip.null logical, skip over NULL (see details)\n#' @param .raw logical, skip processing (see details)\n#' @param .chunk.size (internal parameter) size of chunks to use\n#'        when skip.null==FALSE and n < 0 \n#' @return character string\n#' @details\n#' \\preformatted{\n#' if skip.null==FALSE (default)\n#'   if (n >= 0) then input will stop either when\n#'               n chars have been read or a NULL character is found\n#'               or EOF has been reached.\n#'   if (n < 0) then input will stop on first NULL character\n#'              (or EOF).\n#' if skip.null==TRUE\n#'    read will skip over NULL chars until either\n#'    n chars have been read (not counting NULLs)\n#'    or EOF has been reached.\n#' \n#' .raw == TRUE assume that the input stream contains\n#' exactly n bytes without embedded NULLs. this will skip\n#' all checking and processing (ignoring skip.null parameter).\n#' this is intended for high speed reading when you know exactly\n#' what is currently in stream.\n#' }\n#' @note n is an integer, therefore limited to 2,147,483,647\n#' @seealso \\link{lx.read.int8} to read bytes (including NULL),\n#' \\link{lx.read.string} as an alternative form.\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' s <- lx.read.char(fh, n=40)\n#' nchar(s)  # 5\n#' lx.rewind(fh)\n#' s <- lx.read.char(fh, n=40, skip=TRUE)\n#' nchar(s, type=\"bytes\")  # 40\n#' lx.close(fh)\n#'\nlx.read.char <- function(handle, n=1L, skip.null=FALSE, .raw=FALSE, .chunk.size=100L) {\n  if (.raw) \n    r <- rawToChar(handle$handler$read(handle$connect, n=max(0, n)))\n  else if (skip.null) {\n    r  <- handle$handler$read(handle$connect, n=max(0, n))\n    nr <- length(r)\n    r  <- r[r!=0]\n    nc <- length(r)\n    r  <- rawToChar(r)\n    if (nc < nr)\n      r <- paste(r, lx.read.char(handle, n=nr-nc, skip.null=FALSE), sep=\"\")\n  } else {\n    nr <- if (n >= 0) n else .chunk.size\n    p  <- handle$handler$seek(handle$connect)\n    r  <- handle$handler$read(handle$connect, nr)\n    of <- head(which(r == 0), 1)\n    if (length(of) > 0) { # NULL found\n      r <- rawToChar(head(r, of - 1))\n      handle$handler$seek(handle$connect, p+of)\n    } else {              # no NULL found\n      r <- rawToChar(r)\n      if (n < 0)\n        r <- paste(r, lx.read.char(handle, n=n, skip.null=TRUE), sep=\"\")\n    }\n  }\n  r  \n}\n\n# -------------------------------------------------\n#' read binary C-style or basta string\n#' @description\n#' a C-style string is null terminated character array\\cr\n#' a basta string is binary encoded in the following way\\cr\n#' \\itemize{\n#'  \\item int32 : string size\n#'  \\item chars+NULL : null terminated (C style) character array\n#' }\n#' @param handle file handle (opened by \\link{lx.open})\n#' @param with.size if true basta string else simple C-style string \n#' @return character string\n#' @note if with.size==FALSE this function is equivalent to\n#' \\code{lx.read.char(handle, n=-1L, skip=FALSE)}\n#' @examples\n#' fh <- lx.open(lx.system.file(\"samples/test_bin.bst\"))\n#' cod  <- lx.read.int32(fh, n=1)\n#' nseq <- lx.read.int32(fh, n=1)\n#' s1 <- lx.read.string(fh)\n#' siz1 <- lx.read.int64(fh, n=1)\n#' crc1 <- lx.read.int32(fh, n=1)\n#' s2 <- lx.read.string(fh)\n#' siz2 <- lx.read.int64(fh, n=1)\n#' crc2 <- lx.read.int32(fh, n=1)\n#' ss1 <- lx.read.char(fh, n=siz1)\n#' ss2 <- lx.read.char(fh, n=siz2)\n#' lx.close(fh)\n#\nlx.read.string <- function(handle, with.size=TRUE) {\n  if (with.size) {\n    siz <- lx.read.int32(handle)\n    str <- lx.read.char(handle, n=siz+1, skip.null=FALSE)\n    lx.warnif(nchar(str) != siz, \"invalid string size (corrupted binary file ?)\")\n  } else {\n    str <- lx.read.char(handle, n=-1L, skip.null=FALSE)\n  }\n  str\n}\n\n# -------------------------------------------------\n#' print method for LXFileHandle\n#' @param x file handle (opened by \\link{lx.open})\n#' @param ... further arguments passed to or from other methods.\n#' @return (invisible) x\n#\nprint.LXFileHandle <- function(x, ...) {\n  .p <- function(...) print(paste0(...), quote=F)\n  .p(\"<LXFileHandle>\")\n  .p(\" filename: \", x$filename)\n  .p(\"     type: \", x$type)\n  .p(\"     mode: \", x$mode)\n  .p(\"  is.open: \", x$is.open)\n  invisible(x)\n}\n\n",
    "created" : 1500983538426.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3847374419",
    "id" : "AF159AC6",
    "lastKnownWriteTime" : 1503001927,
    "last_content_update" : 1503001927,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/lx/R/lx.fileio.r",
    "project_path" : "R/lx.fileio.r",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}