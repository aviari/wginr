{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: lx.language.r 120 2016-10-29 07:45:45Z viari $\n# lx misc langage utilities\n#\n\n# -------------------------------------------------\n# <internal> digits for base conversion\n#\n.lx.DIGITS <- c(0:9, letters)\n\n# =================================================\n# low level langage utilities\n#\n\n# -------------------------------------------------\n#' get function actual arguments\n#' @description\n#' get list of actual arguments of function call.\n#' this is mostly useful to 1) retrieve arguments from function with\n#' undefined number of arguments and 2) to retrieve actual arguments\n#' as symbols (instead of values).\n#' this should be called within a function (not from top level).\n#' returned arguments are not evaluated but are returned\n#' as symbols, constants or language expression.\n#' @param pos position of argument to extract. if NULL returns all arguments, including\n#' function name at pos=1. you can retrieve all arguments but function name\n#' by using pos=-1.\n#' @param up.frame, number of frame to go up to get caller. default (up=0)\n#' means to retrieve arguments from the function calling \\code{lx.args};\n#' up=1 means the function calling the function calling \\code{lx.args}\n#' and so on up to top level.\n#' @return\n#' named list of actual (unevaluated) arguments\\cr\n#' or NULL if called from top-level\n#' @note\n#' pos is the position of argument i.e as declared in the function definition\n#' not in the function call.\n#' @note\n#' avoid calling \\code{lx.args} as an argument of another function\n#' unless you are sure when/where it will actually be evaluated. \n#' @note\n#' don't confuse this function with \\link{lx.getargs} that handle command line arguments.\n#' @examples\n#' foo <- function(...) {\n#'   args <- lx.args(-1)\n#'   print(args)\n#' }\n#' foo(first=1, second=anything, \"third\", FUN=function(x) x+1)\n#'\n#' foo <- function() {\n#'   caller <- lx.args(1, 1)[[1]]\n#'   cat(\"foo caller is:\", caller, \"\\n\")\n#' }\n#' bar <- function() foo()\n#' bar()\n#'\nlx.args <- function(pos=NULL, up.frame=0L) {\n  if ((sys.nframe() - up.frame) < 2) # called from top level\n    return(NULL) \n  parent <- sys.parent(up.frame+1)\n  def    <- sys.function(parent)\n  cal    <- sys.call(parent)\n  # trouble when called within a lambda expression [fixme]\n  args <- as.list(tryCatch(\n    match.call(definition=def, call=cal),\n    error=function(cond) \"closure\"))\n  if (is.null(pos)) args else args[pos]\n}\n\n# -------------------------------------------------\n#' set or get lx options\n#' @param ... arguments of the form \\code{key} or \\code{key=value} (see details)\n#' @param default default value for retrieving a single key (see details)\n#' @return\n#' for set/get of \\bold{single key}: returns the associated value\n#' or (in get mode) \\code{default} or \\code{NULL} if option cannot be found\n#' and has no default\\cr\n#' for set/get of \\bold{multiple keys}: returns a named list of\n#' key:value. (note: in get mode if the key is not found, the name is \\code{<NA>} and\n#' value \\code{NULL})\\cr\n#' @details\n#' \\subsection{Set form}{\n#' \\code{lx.options(key=value [, key2=value, ...])}\\cr\n#' will set option key to value\\cr\n#' note: to remove a key then just set its value to NULL (\\code{lx.options(key=NULL)}\n#' }\n#' \\subsection{Get form}{\n#' \\code{lx.options(key, [key2, ... ] [, default=value])}\\cr\n#' return the value(s) associated to key(s)\\cr\n#' note that \\code{key} is either a symbol or a string, see examples below.\\cr\n#' a special form for retrieving a single key with a default value is:\\cr\n#' \\code{lx.options(key, default=value)}\\cr\n#' finally, if called without argument:\\cr\n#' \\code{lx.options()}, then the function returns the list of all current\n#' options.\n#' }\n#' \\subsection{Returned value}{\n#' for set/get of \\bold{single key}: returns the associated value\n#' or (in get mode) \\code{default} or \\code{NULL} if key cannot be found\\cr\n#' for set/get of \\bold{multiple keys}: returns a named list of\n#' key:value.\\cr\n#' in get mode, if the key is not found, then the corresponding\n#' name is \\code{<NA>} and value \\code{NULL}\\cr\n#' }\n#'\n#' note that set and get mode can be intermixed\n#' (although this is a bit strange to do)\\cr\n#'\n#' @note\n#' as for \\link{options}, key is a (uninterpreted) symbol or a character string.\\cr\n#' (for developpers: to use a variable value, use a \\link{do.call})\n#'\n#' @examples\n#' lx.options(foo=123, bar=234)\n#' lx.options(foo)\n#' lx.options(\"foo\")\n#' lx.options(foobar, default=456)\n#' lx.options(foo=NULL)\n#' lx.options(foo, default=pi)\n#' lx.options()\n#' @note\n#' see \\link{HELP.LX.OPTIONS} for a list of current builtin options\n#' \nlx.options <- function(..., default=NULL) {\n  args <- lx.args(-1)\n  args$default <- NULL  # remove 'default'\n  if (length(args) == 0) args <- names(.lx.env$options)\n  nams <- names(args)\n  if (is.null(nams))  nams <- rep(\"\", length(args))\n  opts <- mapply(function(name, arg) {\n    if (nchar(name) == 0) { # get mode\n      .lx.env$options[as.character(arg)]\n    }\n    else {                  # set mode\n      as.list(.lx.env$options[[as.character(name)]] <- eval(arg, envir=parent.frame(3)))\n    }}, nams, args)\n  if (length(opts) == 1) opts <- unlist(opts, recursive=FALSE)\n  if (is.null(opts) && ! is.null(default)) opts <- c(default=default)\n  opts\n}\n\n# -------------------------------------------------\n#' create an S3 instance of given class\n#' @param classname string or string vector of classnames\n#' @param ... anything accepted by \\link{list}\n#' @return a named list of \\code{...} named fields and class(es) classname\n#' @seealso \\link{class}\n#' @examples\n#' x <- lx.new(\"people\", name=\"alain\", age=10)\n#' class(x)\n#' x$age\n#'\nlx.new <- function(classname, ...) {\n  obj <- list(...)\n  class(obj) <- c(classname, class(obj))\n  obj\n}\n\n# -------------------------------------------------\n#' set/get information on object\n#' @description\n#' to get object information:\\cr\n#' \\code{lx.info(obj)}\\cr\n#' to set object information:\\cr\n#' \\code{lx.info(obj) <- \"value\"}\\cr\n#' @param obj an R object\n#' @seealso \\link{lx.doc}\n#' @examples\n#' x <- 1:3\n#' lx.info(x) <- \"my array\"\n#' lx.info(x)\n#' lx.doc(x)\n#'\nlx.info <- function(obj) attr(obj, \".lx.info\")\n\n#' @name lx.info\n#' @aliases lx.info\n#' @param value option value\n#'\n\"lx.info<-\" <- function(obj, value) {\n  if (! is.null(obj))\n    attr(obj, \".lx.info\") <- value\n  obj\n}\n\n# -------------------------------------------------\n#' minimalist documentation about object\n#' @description\n#' return a minimalist description of an object\n#' (including lx.info if available) and its\n#' subfields (if any)\n#' @param obj an R object\n#' @param depth maximum depth of subfields recursion\n#' @param maxfields maximum number of subfields\n#' @param .name name to print in header (usually internal)\n#' @param .prefix header prefix (usually internal)\n#' @param .indent current indentation level (usually internal)\n#' @seealso \\link{lx.info}\n#' @examples\n#' x <- lx.new(\"people\", name=\"alain\", age=10, hobbies=c(\"scuba\", \"guitar\"))\n#' lx.info(x) <- \"this is people class\"\n#' lx.info(x$age) <- \"people age\"\n#' lx.doc(x)\n#'\nlx.doc <- function(obj, depth=2L, maxfields=10L, \n                   .name=deparse(substitute(obj)), .prefix=\">\", .indent=0L) {\n  if (depth <= 0) return(invisible(NULL))\n  .pas <- function(..., collapse=\"\") paste0(..., collapse=collapse)\n  .cat <- function(...) cat(..., \"\\n\", sep=\"\")\n  .def <- function(s, def=\"\") ifelse(is.null(s)||(s==\"NULL\")||(s==\"\"), def, s)\n  .ind <- function(s, n=.indent) .pas(.pas(rep(\" \", 2*n)), s)\n  .sub <- function(s, n) ifelse(n >= 0, substr(s, 1, n), substr(s, nchar(s)+n, nchar(s)))\n  .trc <- function(s, n=30) ifelse(nchar(s)<=n, s, .pas(.sub(s,n/2), \"...\", .sub(s,-n/2)))\n  typz  <- .def(typeof(obj))\n  dimz  <- .pas(\"[\", .def(.pas(dim(obj), collapse=\" \"), length(obj)), \"]\")\n  clasz <- .pas(\"{\", .def(.pas(class(obj), collapse=\" \"), length(obj)), \"}\")\n  infoz <- ifelse(is.null(lx.info(obj)), \"\", .pas(\" => \", lx.info(obj)))\n  if ((infoz == \"\") && is.atomic(obj)) infoz <- .trc(.pas(\" value: \", .pas(obj, collapse=\" \")))\n  .cat(.ind(.prefix), .name, \" type:\", typz, \" dim:\", dimz, \" class:\", clasz, infoz)\n  for (e in head(names(obj), maxfields))\n    lx.doc(obj[[e]], depth-1, maxfields, e, \"$\", .indent+1)\n  if ((length(names(obj)) > maxfields) && (depth > 1))\n    .cat(.ind(.prefix, .indent+1), \"... \", length(names(obj))-maxfields, \" other fields not printed...\")\n  invisible(NULL)\n}\n\n# =================================================\n# high level langage utilities\n# mostly R alternative replacements\n#\n\n# -------------------------------------------------\n#' mixin named lists\n#' @description \n#' replace key values in lout by key values in lin.\n#' @param lout named list\n#' @param lin named list\n#' @param keys character array of keys to replace.\n#'        default is \\code{intersect(names(lout), names(lin))}\n#' @return named list\n#' @details\n#' this is equivalent to\n#' \\preformatted{lout[keys] <- lin[keys]}\n#' and is typically used to override formal arguments\n#' by user's arguments to allow specifying only part\n#' of a list argument (see example below).\n#' @examples\n#' # replace\n#' lx.mixin(list(a=1, c=3), list(a=10, b=20))\n#' \n#' # replace and add\n#' lx.mixin(list(a=1, c=3), lin<-list(a=10, b=20), names(lin))\n#' \n#' # select\n#' lx.mixin(NULL, lin<-list(a=10, b=20), intersect(names(lin), c(\"a\", \"c\")))\n#' \n#' # typical usage with function args\n#' foo <- function(arg=list(a=1, b=\"foo\")) {\n#'    dft <- formals()\n#'    arg  <- lx.mixin(dft$arg, arg)\n#'    arg\n#' }\n#' foo(list(a=2)) # => list(a = 2, b = \"foo\")\n#' \n#\nlx.mixin <- function(lout, lin, keys=intersect(names(lout), names(lin))) {\n  lout[keys] <- lin[keys]\n  lout\n}\n\n# -------------------------------------------------\n#' convert named list to character string\n#' @description \n#' convert named list to character string of the form\n#' \"key1<sep>value1<collapse>key2<sep>value2....\"\n#' @param lst named list\n#' @param sep separator between key and value\n#' @param collapse sep separator elements\n#' @param quote character to use for quoting character values(use NA to prevent quoting)\n#' @param ... arguments to \\link{format} for formating elements\n#' @note list values should be atomic. vectors are printed as '[x,y,...]'.\n#'       recursive lists or matrices are not (yet) handled.\n#' @return character string\n#' @examples\n#' ll <- list(a=1, b=\"you\", c=1:3)\n#' lx.list2str(ll)\nlx.list2str <- function(lst, sep=\"=\", collapse=\", \", quote=NA, ...) {\n  lst <- sapply(lst, function(x) {\n            if (length(x) > 1) paste0(\"[\", paste(x, collapse=\",\"), \"]\")\n            else if (is.character(x) && (! is.na(quote))) paste0(quote, x, quote)\n            else format(x, ...) })\n  paste(lx.napply(lst, function(nam, val) paste(nam, val, sep=sep)),\n        collapse=collapse)\n}\n\n# -------------------------------------------------\n#' translate keys fom dictionnary\n#' @description\n#' translate keys in vector \\code{x} to values from dictionnary \\code{dict}\n#' @param x key or vector of keys\n#' @param dict dictionnary (list indexed by keys, plus optional default value)\n#' @examples\n#' lx.key.trans(\"red\", c(red=\"rouge\", blue=\"bleu\"))\n#' lx.key.trans(c(\"red\", \"blue\"), c(red=1, green=2, blue=3))\n#' lx.key.trans(c(\"red\", \"pink\"), c(red=1, green=2, blue=3))\n#' lx.key.trans(c(\"red\", \"pink\"), c(red=1, green=2, blue=3, 0))\n#\nlx.key.trans <- function(x, dict) {\n  res <- as.character(sapply(x, function(e) { do.call(switch, as.list(c(e, dict))) }))\n  mode(res) <- mode(dict)\n  res\n}\n\n# -------------------------------------------------\n#' reverse dictionnary\n#' @param dict dictionnary : a list indexed by keys\n#' (plus optional default value that is ignored)\n#' @return reverse dictionary : a list indexed by values\n#' @examples\n#' dict <- list(warm=c(\"red\"), cold=c(\"blue\", \"green\"), basic=c(\"red\", \"blue\", \"green\"), \"white\")\n#' lx.rev.dict(dict)\n#' # => list(red=c(\"warm\", \"basic\"), blue=c(\"cold\", \"basic\"), green=c(\"cold\", \"basic\"))\n#\nlx.rev.dict <- function(dict) {\n  res <- list()\n  for (nam in names(dict)) {\n    for (key in unique(dict[[nam]])) {\n      res[[key]] <- c(res[[key]], nam)\n    }\n  }\n  res\n}\n\n# -------------------------------------------------\n#' quicker \\code{\\%in\\%} for numeric vectors\n#' @description\n#' works as \\link{\\%in\\%} but much quicker and for numeric vectors only.\n#' @param x numeric vector: the values to be matched\n#' @param table numeric vector: the values to be matched against.\n#' (better if sorted increasingly)\n#' @param .threshold internal threshold on table length to switch\n#' between standard \\%in\\% and quicker algorithm.\n#' @return A logical vector, indicating if a match was located for each element of x.\n#' @note table should be sorted increasingly. if not it will be sorted\n#' internally.\n#' @examples\n#' lx.in(1:10, 3:5)\n#' lx.in((1:10)/1000, (3:5)/1000)\n#' lx.in(5e6, 1:1e7)  # quicker than 5e6 %in% 1:1e7\n#' \nlx.in <- function(x, table, .threshold=500) {\n  if (length(table) < .threshold)\n    return(x %in% table)\n  if (is.unsorted(table)) table <- sort(table)\n  table[pmax(1, findInterval(x, table))] == x\n}\n\n# -------------------------------------------------\n#' open ends version of findInterval\n#' @description\n#' works as \\link{findInterval} but always consider that end\n#' breakpoints are infinite (i.e vec[1]=-Inf and vec[N]=+Inf).\n#' This always return indices in range [1, N].\n#' @param x numeric vector: the values to find\n#' @param vec numeric, sorted (weakly) increasingly, of length N.\n#' see \\link{findInterval}\n#' @return integer vector of length length(x) with values in 1:N (and NA).\n#' @note this is simply implemented as \\code{pmax(1, findInterval(x, vec))}\n#' @seealso \\link{findInterval}\n#' @examples\n#' lx.findInterval(0:11, 1:10)\n#' lx.findInterval(c(-Inf, Inf), 1:10)\n#' \nlx.findInterval <- function(x, vec) {\n  pmax(1, findInterval(x, vec, rightmost.closed=F, all.inside=F))\n}\n\n# -------------------------------------------------\n#' head of vector\n#' @description \n#' same as \\link{head} but limited to vectors and quicker\n#' @param x vector\n#' @param n if positive take n first elements, if negative take all but n last elements\n#' @return vector of size n if n >= 0, or of size \\code{length(x) - n} if n < 0\n#' @examples\n#' lx.head(1:10, 2)  # => 1 2\n#' lx.head(1:10, -2) # => 1 2 3 4 5 6 7\n#' @seealso \\link{head} \\link{lx.tail}\n#\nlx.head <- function(x, n=1L) {\n  m <- length(x)\n  if ((n == 0) || (n <= -m))\n    integer(0)\n  else if (n > 0)\n    x[1:min(n,m)]\n  else\n    x[1:min(m+n,m)]\n}\n\n# -------------------------------------------------\n#' tail of vector\n#' @description \n#' same as \\link{tail} but limited to vectors and quicker\n#' @param x vector\n#' @param n if positive take n last elements, if negative take all but n first elements\n#' @return vector of size n if n >= 0, or of size \\code{length(x) - n} if n < 0\n#' @examples\n#' lx.tail(1:10, 2)  # => 9 10\n#' lx.tail(1:10, -2) # => 3 4 5 6 7 8 9 10\n#' @seealso \\link{tail} \\link{lx.head}\n#\nlx.tail <- function(x, n=1L) {\n  m <- length(x)\n  if ((n == 0) || (n <= -m))\n    integer(0)\n  else if (n > 0)\n    x[max(m-n+1,1):m]\n  else\n    x[max(1-n,1):m]\n}\n\n# -------------------------------------------------\n#' binned sum \n#' @description \n#' compute the jumping sum of k consecutive elements in vector.\n#' this is equivalent to\n#' \\code{sapply(seq.int(1,length(x),by=k), function(i) sum(x[i:(i+(k-1))], na.rm=T))}\n#' but is quicker.\n#' @param x vector\n#' @param k number of consecutive elements to sum (k >= 1)\n#' @param drop drop the last element of result if length(x) is not a multiple\n#' of k.\n#' @return vector of size ceiling(length(x) / k) if drop=FALSE or\n#' floor(length(x) / k) if drop=TRUE, containing the\n#' sum of k consecutive elements.\n#' @note if drop=FALSE and length(x) is not a multiple of k \n#' the last element will sum up less than k elements.\n#' @examples\n#' lx.binsum(1:10, 2)                 # => 3 7 11 15 19\n#' lx.binsum(rep(1,10), 3)            # => 3 3 3 1\n#' lx.binsum(rep(1,10), 3, drop=TRUE) # => 3 3 3\n#' @seealso \\link{lx.rollsum} for a rolling (instead of jumping) version\n#'\nlx.binsum <- function(x, k, drop=FALSE) {\n  if (! drop) {\n    pad <- (k - (length(x) %% k)) %% k\n    if (pad != 0)\n      x <- c(as.numeric(x), rep(0, pad))\n  }\n  to <- length(x)-k+1\n  if (to <= 0) return(numeric(0))\n  y <- cumsum(as.numeric(x))\n  i <- seq.int(1, to, k)\n  y[i+k-1]-y[i]+x[i]\n}\n\n# -------------------------------------------------\n#' rolled sum \n#' @description \n#' compute the rolling sum of k consecutive elements in vector.\n#' this is equivalent to\n#' \\code{sapply(seq_along(x), function(i) sum(x[i:(i+(k-1))], na.rm=T))}\n#' but is much quicker since it runs in \\code{O(n)}.\n#' @param x vector\n#' @param k number of consecutive elements to sum (k >= 1)\n#' @param drop drop the last (k-1) elements of result \n#' @return vector of size length(x) if (drop==F) or length(x)-k+1\n#' if (drop==F), containing the sum of k consecutive elements.\n#' @note with drop==F the last (k-1) elements will\n#' sum up less than k elements.\n#' @examples\n#' lx.rollsum(1:5, 2)          # => 3 5 7 9 5\n#' lx.rollsum(rep(1,10), 3, TRUE) # => 3 3 3 3 3 3 3 3\n#' @seealso \\link{lx.binsum} for a jumping (instead of rolling) version\n#'\nlx.rollsum <- function(x, k, drop=FALSE) {\n  pad <- rep(0, k-1)\n  x   <- cumsum(c(as.numeric(x), pad))\n  x   <- x - c(0, pad, lx.head(x, -k))\n  x   <- if (k > 1) lx.tail(x, 1-k) else x\n  if (drop && (k > 1)) lx.head(x, 1-k) else x\n}\n\n# -------------------------------------------------\n#' rotate vector circularly n times\n#' @param x vector\n#' @param n number of rotations.\\cr \n#'        if > 0 rotate to left else rotate to right\n#' @return\n#' rotated vector\n#' @examples\n#' lx.rotate(1:5, 2)  # => 3 4 5 1 2\n#' lx.rotate(1:5, -2) # => 4 5 1 2 3\n#\nlx.rotate <- function(x, n=1L) {\n  right <- (n < 0)\n  m <- length(x)\n  n <- abs(n) %% m\n  from <- (if (right) (m - n) else n) + 1\n  c(x,x)[from:(2*m)][1:m]\n}\n\n# -------------------------------------------------\n#' shift vector n times and pad with fill value\n#' @param x vector\n#' @param n number of shifts.\\cr\n#'        if >= 0 shift to left else shift to right\n#' @param fill value to fill\n#' @return\n#' shifted vector\n#' @examples\n#' lx.shift(1:5, 2, fill=0)  # => 3 4 5 0 0\n#' lx.shift(1:5, -2, fill=0) # => 0 0 1 2 3\n#\nlx.shift = function(x, n=1L, fill=NA) {\n  if (n == 0)\n    x\n  else if (n > 0)\n    c(lx.tail(x, -n), rep(fill, n))\n  else\n    c(rep(fill, -n), lx.head(x, n))\n}\n\n# -------------------------------------------------\n#' expand by recycling or shrink vector to given size\n#' @description \n#' given a vector x either shrink or expand by recycling to size n\n#' @param x vector\n#' @param n positive integer\n#' @return vector of size n\n#' @examples\n#' lx.recycle(1:3, 6)\n#' lx.recycle(1:10, 6)\n#' lx.recycle(1:10, 0)\n#' lx.recycle(NULL, 2)\n#' @seealso \\link{lx.rotate}\n#\nlx.recycle <- function(x, n) {\n  lx.stopif(n < 0, \"n argument should be positive or null\")\n  if (length(x) == 0) x else head(rep(x, ceiling(n/length(x))), n)\n}\n\n# -------------------------------------------------\n#' decimate vector\n#' @description\n#' downsample vector to length \\code{length.out} by selecting\n#' equally spaced indices from 1 to \\code{length(x)}.\n#' @param x vector\n#' @param length.out desired length of the resulting vector.\n#' @param as.index if TRUE return indices else returns values\n#' @note if \\code{length(x) <= length.out} then the original\n#' vector x (or indices) is returned.\n#' @examples \n#' lx.decimate(1:100, 10)\n#' lx.decimate(letters, 5)\n#' lx.decimate(letters, 5, as.index=TRUE)\n#\nlx.decimate <- function(x, length.out, as.index=FALSE) {\n  n <- length(x)\n  if (n <= length.out) {\n    if (as.index) seq_along(x) else x\n  }\n  else {\n    indx <- round(seq.int(1, n, length.out=length.out))\n    if (as.index) indx else x[indx]\n  }\n}\n\n# -------------------------------------------------\n#' get maximum in rows\n#' @description find the maximum for each row of a matrix\n#' @param x numerical matrix\n#' @param ties.method a character string specifying how ties are handled. (see \\link{max.col})\n#' @param what a character string specifying what should be returned (see Value)\n#' @return \\itemize{\n#' \\item if \\code{what == \"value\"} return a maximal value for each row\n#' \\item if \\code{what == \"index\"} return index of a maximal value for each row\n#' }\n#' @note\n#' with \\code{what == \"index\"} this function is identical to \\link{max.col}\n#' \n#' with \\code{what == \"value\"} this function is identical to \n#' \\code{apply(1, x, max)} but much quicker for large matrices\n#' \n#' @seealso \\link{lx.rowMins}\n#\nlx.rowMaxs <- function(x, ties.method=c(\"random\", \"first\", \"last\"),\n                      what=c(\"value\", \"index\")) {\n  ties.method <- match.arg(ties.method)\n  what <- match.arg(what)\n  imax <- max.col(x, ties.method=ties.method)\n  switch(what,\n         index=imax,\n         x[cbind(seq_along(imax), imax)])\n}\n\n# -------------------------------------------------\n#' get minimum in rows\n#' @description find the minimum for each row of a matrix\n#' @param x numerical matrix\n#' @param ties.method a character string specifying how ties are handled. (see \\link{max.col})\n#' @param what a character string specifying what should be returned (see Value)\n#' @return \\itemize{\n#' \\item if \\code{what == \"value\"} return a minimum value for each row\n#' \\item if \\code{what == \"index\"} return index of a minimum value for each row\n#' }\n#' @note\n#' with \\code{what == \"index\"} this function is identical\n#' to \\link{max.col}(-x)\n#' \n#' with \\code{what == \"value\"} this function is identical to \n#' \\code{apply(1, x, min)} but much quicker for large matrices\n#' \n#' @seealso \\link{lx.rowMaxs}\n#\nlx.rowMins <- function(x, ties.method=c(\"random\", \"first\", \"last\"),\n                      what=c(\"value\", \"index\")) {\n  x <- lx.rowMaxs(-x, ties.method=ties.method, what=what)\n  switch(match.arg(what), index=x, -x)\n}\n\n# -------------------------------------------------\n#' linearly rescale numeric vector to specified range.\n#' @description\n#' rescale numeric vector x to x' from range [f1, f2] to range [t1, t2]\n#' according to:\\cr\n#' \\code{x}'\\code{ = a.x + b}\\cr\n#' where a=(t2-t1)/(f2-f1) and b = t1 - a.f1\n#' @param x numeric vector\n#' @param to output range (numeric vector of length two)\n#' @param from input range (numeric vector of length two).\\cr\n#'        if not specified, use the range of x\n#' @param zerob force b=0. this is useful for rescaling differences\n#' @return rescaled vector\n#' @examples\n#' lx.scale(1:10)\n#' lx.scale(1:10, c(1,10))\n#\nlx.scale <- function(x, to=c(0, 1), from=range(x, na.rm=TRUE), zerob=FALSE) {\n  if ((length(from) < 2) || (abs(from[1]-from[2]) < .Machine$double.eps))\n    rep(mean(to), length(x))\n  else if (zerob)\n    x * (to[2]-to[1]) / (from[2]-from[1])\n  else\n    (x - from[1]) * (to[2]-to[1]) / (from[2]-from[1]) + to[1]\n}\n\n# -------------------------------------------------\n#' always TRUE function\n#' @description\n#' this function always returns TRUE, whatever\n#' the arguments.\n#' @param ... anything (ignored arguments)\n#' @return TRUE\n#'\nlx.true  <- function(...) { TRUE }\n\n# -------------------------------------------------\n#' always FALSE function\n#' @description\n#' this function always returns FALSE, whatever\n#' the arguments.\n#' @param ... anything (ignored arguments)\n#' @return FALSE\n#'\nlx.false <- function(...) { FALSE }\n\n# -------------------------------------------------\n#' a prettier \\code{summary} for dataframes\n#' @param df a dataframe\n#' @note only works with numeric columns\n#' @examples\n#' lx.summary(iris[,-5])\n#\nlx.summary <- function(df) {\n  res  <- summary(df)\n  rnam <- sapply(res[,1], function(x) { gsub(\" *:[^:]*$\", \"\", x) })\n  cnam <- colnames(res)\n  res <- data.frame(apply(res, c(1,2), function(x) { gsub(\"^[^:]*: *\", \"\", x) }))\n  rownames(res) <- rnam\n  colnames(res) <- cnam\n  res\n}\n\n# -------------------------------------------------\n#' get number representation\n#' @description\n#' get base representation of a positive numeric\n#' (accurate up to 53 bits)\n#' @param num positive (unsigned) numeric value\n#' @param base representation base (2 <= base <= 36)\n#' @param prefix prefix to add (e.g. '0x' for hexadecimal)\n#' @return string\n#' @examples\n#' lx.tobase(123, prefix=\"0x\")  # 0x7b\n#\nlx.tobase <- function(num, base=16L, prefix=\"\") {\n  s <- \"\"\n  base <- min(36, max(2, base))\n  while (num > 0) {\n    s <- paste0(.lx.DIGITS[(num %% base) + 1], s)\n    num <- num %/% base\n  }\n  paste0(prefix, ifelse(nchar(s) == 0, \"0\", s))\n}\n",
    "created" : 1496874419269.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "533636243",
    "id" : "471170A9",
    "lastKnownWriteTime" : 1503003069,
    "last_content_update" : 1503003069,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/lx/R/lx.language.r",
    "project_path" : "R/lx.language.r",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}