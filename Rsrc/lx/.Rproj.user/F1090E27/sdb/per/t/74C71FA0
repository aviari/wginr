{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: lx.plot.r 120 2016-10-29 07:45:45Z viari $\n# lx plot utilities\n#\n\n# =================================================\n# plot layout utilities\n#\n\n# -------------------------------------------------\n#' determine best \\code{\\link{par}(mfrow=c(x,y))} layout to fit for n plots\n#' @param n number of plots\n#' @seealso \\link{par}\n#' @examples\n#' opar <- par(no.readonly=TRUE)\n#' par(mfrow=lx.mfrow(10))\n#' # ... plots\n#' par(opar)\n#'\nlx.mfrow <- function(n) {\n  for (i in 1:n) {\n    for (j in 1:i) {\n      if (i * j >= n) \n        return(c(j,i))\n    }\n  }\n  NULL # not reached\n}\n\n# -------------------------------------------------\n#' change color(s) hue, saturation or value\n#' @param color vector of any of the three kinds of R color specifications, \n#' i.e., either a color name (as listed by \\link{colors}()),\n#' a hexadecimal string of the form \"#rrggbb\" or \"#rrggbbaa\" (see \\link{rgb}),\n#' or a positive integer i meaning \\link{palette}()[i]\n#' @param dh change in hue (-1 <= dh <= 1)\n#' @param ds change in saturation (-1 <= ds <= 1)\n#' @param dv change in value (-1 <= dv <= 1)\n#' @return modified colors (as hexadecimal strings)\n#' @seealso \\link{lx.color.light}, \\link{lx.color.alpha}\n#' @examples\n#' lx.color.change(\"#ff0000\", ds=-0.5)  # => #ff8080\n#' lx.color.change(\"red\", ds=-0.5)      # => #ff8080\n#\nlx.color.change <- function(color, dh=0, ds=0, dv=0) {\n  color <- rgb2hsv(col2rgb(color)) + c(h=dh, s=ds, v=dv)\n  color <- pmin(pmax(color, 0), 1)\n  apply(color, 2, function(c) do.call(hsv, as.list(c)))\n}\n\n# -------------------------------------------------\n#' lighten or darken color(s)\n#' @param color vector of any of the three kinds of R color specifications, \n#' i.e., either a color name (as listed by \\link{colors}()),\n#' a hexadecimal string of the form \"#rrggbb\" or \"#rrggbbaa\" (see \\link{rgb}),\n#' or a positive integer i meaning \\link{palette}()[i]\n#' @param delta amount in percentage (-100 <= delta <= 100)\\cr\n#'        delta > 0 : lighten; delta < 0 : darken\n#' @return modified colors (as hexadecimal strings)\n#' @seealso \\link{lx.color.change}, \\link{lx.color.alpha}, \\link{lx.color.lum}\n#' @examples\n#' lx.color.light(\"red\", 50)  # => #ff8080\n#' lx.color.light(\"red\", -50) # => #800000\n#\nlx.color.light <- function(color, delta) {\n  if (delta > 0) \n    lx.color.change(color, ds=-delta/100)\n  else\n    lx.color.change(color, dv=delta/100)\n}\n\n# -------------------------------------------------\n#' add alpha channel to color(s)\n#' @param color vector of any of the three kinds of R color specifications, \n#' i.e., either a color name (as listed by \\link{colors}()),\n#' a hexadecimal string of the form \"#rrggbb\" or \"#rrggbbaa\" (see \\link{rgb}),\n#' or a positive integer i meaning \\link{palette}()[i]\n#' @param alpha alpha channel value (0 <= alpha <= 1)\\cr\n#'        alpha=0: completely transparent, alpha=1: completely opaque\n#' @return modified colors (as hexadecimal strings)\n#' @seealso \\link{lx.color.change}, \\link{lx.color.light}\n#' @examples\n#' lx.color.alpha(\"red\", 0)  # => #ff000000\n#' lx.color.alpha(\"red\", 1)  # => #ff0000ff\n#\nlx.color.alpha <- function(color, alpha=1) {\n  sapply(color, function(c) rgb(t(col2rgb(c)),\n                                alpha=255*alpha,\n                                maxColorValue=255))\n}\n\n# -------------------------------------------------\n#' rainbow color scale\n#' @description\n#' similar to \\link{rainbow} except that colors do not close\n#' circularly (i.e. start and end colors are not the same).\n#' @param n the number of required colors\n#' @param skip end portion of color circle to remove (default=1/6)\n#' @param ... any argument of \\link{rainbow}\n#' @return a character vector of colors\n#' @examples\n#' lx.rainbow(10)\n#\nlx.rainbow <- function(n, skip=1/6, ...) {\n  nr <- floor(n * (1 + skip))\n  rainbow(nr, ...)[1:n]\n}\n\n# -------------------------------------------------\n#' get luminance (darkness) of color(s)\n#' @description compute luminance of colors for human eye. luminance ranges\n#' between 0 (dark) and 1 (light).\n#' @param color vector of any of the three kinds of R color specifications, \n#' i.e., either a color name (as listed by \\link{colors}()),\n#' a hexadecimal string of the form \"#rrggbb\" or \"#rrggbbaa\" (see \\link{rgb}),\n#' or a positive integer i meaning \\link{palette}()[i]\n#' @return numeric vector of luminance\n#' @seealso \\link{lx.color.fore}\n#' @examples\n#' lx.color.lum(c(\"black\", \"white\", \"red\", \"yellow\"))\n#\nlx.color.lum <- function(color) {\n  apply(col2rgb(color), 2, \n        function(rgb) (rgb[1]*0.299 + rgb[2]*0.587 + rgb[3]*0.114)/256)\n}\n\n# -------------------------------------------------\n#' choose foreground color (black or white) from background color\n#' @description compute the best foreground color for given\n#' background colors according to background luminance\n#' @param color vector of any of the three kinds of R color specifications, \n#' i.e., either a color name (as listed by \\link{colors}()),\n#' a hexadecimal string of the form \"#rrggbb\" or \"#rrggbbaa\" (see \\link{rgb}),\n#' or a positive integer i meaning \\link{palette}()[i]\n#' @param threshold luminance threshold\n#' @param white foreground color for dark background\n#' @param black foreground color for light background\n#' @return numeric vector of foreground colors\n#' @seealso \\link{lx.color.lum}\n#' @examples\n#' lx.color.fore(c(\"black\", \"white\", \"red\", \"yellow\"))\n#\nlx.color.fore <- function(color, threshold=0.5, white=\"white\", black=\"black\") {\n  ifelse(lx.color.lum(color) < threshold, white, black)\n}\n\n# -------------------------------------------------\n#' DeltaE distance between two colors\n#' @description compute the DeltaE distance between two colors\n#' according to the CIE 1976 definition.\n#' @param col1,col2 colors any of the three kinds of R color specifications, \n#' i.e., either a color name (as listed by \\link{colors}()),\n#' a hexadecimal string of the form \"#rrggbb\" or \"#rrggbbaa\" (see \\link{rgb}),\n#' or a positive integer i meaning \\link{palette}()[i]\n#' @return positive numeric DeltaE\n#' @examples\n#' lx.color.deltaE(\"white\", \"white\")\n#' lx.color.deltaE(\"white\", \"red\")\n#\nlx.color.deltaE <- function(col1, col2) {\n  .lab <- function(col) convertColor(t(col2rgb(col)), \n                                     \"sRGB\", \"Lab\", scale.in=255)\n  sqrt(sum((.lab(col1)-.lab(col2))^2))\n}\n\n# =================================================\n# plot utilities\n#\n\n# -------------------------------------------------\n#' plotting large number of points\n#' @description\n#' this is a wrapper to \\link{plot} (or \\link{points}, \\link{lines})\n#' with pre-sampling of points. It is intended to plot very large\n#' number of points (i.e. when plotting time becomes prohibited).\n#' @param x,y data (same as in \\link{plot})\n#' @param fun plotting function (e.g. \\link{plot}, \\link{points}, \\link{lines})\n#' @param cex plot symbols magnifying factor. see \\link{plot}\n#' @param xlab a label for the x axis, defaults to a description of x\n#' @param ylab a label for the y axis, defaults to a description of y\n#' @param pch plotting character (see \\link{par})\n#' @param col plotting color (see \\link{par})\n#' @param ... arguments to \\code{fun} (see \\link{graphical parameters})\n#' @param .samp number of points to sample\n#' @param .method sampling method (may be abbreviated)\\cr\n#' \\code{sampled}: random sampling\\cr\n#' \\code{spaced}: equally spaced points\\cr\n#' @param .seed seed for sampling (for .method=\"sampled\" only). use\n#' NA to prevent seeding (i.e. to use current seed). use a non-NA\n#' value to produce reproducible behavior.\n#' @note\n#' if \\code{.seed != NA} the current seed will be saved and restored.\n#' @return same as \\link{barplot}\n#' @examples\n#' \\dontrun{\n#' lx.plot(rnorm(1e7))\n#' lx.plot(rnorm(1e7), ylab=\"Normal\")\n#' lx.plot(rnorm(1e7, 0, 0.1), fun=points, col=2)\n#' }\n#\nlx.plot <- function(x, y=NULL, fun=plot, cex=0.1, xlab=NULL, ylab=NULL,\n                    col=\"black\", pch=1, ..., \n                    .samp=1e4, .method=c(\"sampled\", \"spaced\"), .seed=0) {\n  \n  .method <- match.arg(.method)\n  \n  # handle labels and actual coordinates\n  #\n  xlabel <- if (! missing(x)) deparse(substitute(x))\n  ylabel <- if (! missing(y)) deparse(substitute(y))\n  log <- if (\"log\" %in% names(list(...))) list(...)[[\"log\"]] else \"dft\"\n  xy <- xy.coords(x, y, xlabel, ylabel, log)\n  xlab <- if (is.null(xlab)) xy$xlab else xlab\n  ylab <- if (is.null(ylab)) xy$ylab else ylab\n  \n  # sample data\n  #\n  if ((.samp > 0) && (length(xy$y) > .samp)) {\n    if (.method == \"sampled\") {\n      if (! is.na(.seed)) lx.rnd.push(.seed)\n      i <- tryCatch(sort(sample(length(xy$y), .samp, replace=F)),\n                    finally=if (! is.na(.seed)) lx.rnd.pop())\n    } else {\n      i <- round(seq.int(1,length(xy$y), length.out=.samp))\n    }\n    xy$x <- xy$x[i]\n    xy$y <- xy$y[i]\n    if (length(cex) > 1) cex <- lx.recycle(cex, length(x))[i]\n    if (length(pch) > 1) pch <- lx.recycle(pch, length(x))[i]\n    if (length(col) > 1) col <- lx.recycle(col, length(x))[i]\n  }\n  \n  # call plot function\n  # note: xlab and ylab are accepted but ignored in points and lines\n  #       so we don't need to worry about\n  fun(xy, cex=cex, pch=pch, col=col, xlab=xlab, ylab=ylab, ...)\n}\n\n# -------------------------------------------------\n#' barplot with values indicated on top of bars\n#' @details\n#' if \\code{pos.text} is NULL then the label position will be\n#' choosen to fit within the plot.\\cr\n#' if \\code{col.text} is NULL then the label color will be\n#' choosen to fit with the bar color.\\cr\n#' @param x vector or matrix of values\n#' @param col bar colors (see \\link{barplot})\n#' @param col.text text color (or NULL to select contrast color)\n#' @param cex.text text magnification\n#' @param pos.text text position (see \\link{text}, NULL means autopos)\n#' @param off.text text offset (see \\link{text})\n#' @param srt.text text rotation (in degrees)\n#' @param ... arguments to \\link{barplot}\n#' @return same as \\link{barplot}\n#' @note \\code{pos.text} NULL does not work well if srt.text != 0\n#' @examples\n#' \\dontrun{\n#' lx.barplot(c(apple=10, orange=5, banana=15))\n#' lx.barplot(c(apple=10, orange=5, banana=15), col=lx.COLORS)\n#' lx.barplot(c(apple=10, orange=5, banana=15), col.text=0, pos.text=1, col=lx.COLORS)\n#' }\n#\nlx.barplot <- function(x, col=NULL, col.text=NULL, cex.text=1,\n                       pos.text=NULL, off.text=0.5, srt.text=0, ...) {\n\n  # plot bars\n  #\n  mid <- barplot(x, col=col, ...)\n  \n  # add labels\n  #\n  if (is.null(pos.text)) {\n    y0 <- mean(par(\"usr\")[3:4])\n    pos.text <- ifelse(x < y0, 3, 1)\n  }\n  if (is.null(col.text)) {\n    if (is.null(col))\n      col.text <- \"black\"\n    else {\n      col.text <- mapply(function(col, pos) {\n        if (pos==3) \"black\" else lx.color.fore(col)\n      }, col, lx.recycle(pos.text, length(col)))\n    }\n  }\n  text(mid, x, as.character(x), pos=pos.text, offset=off.text,\n       col=col.text, cex=cex.text, srt=srt.text)\n  invisible(mid)\n}\n\n# -------------------------------------------------\n#' histogram plot with density\n#' @param x vector of values for which the histogram is desired\n#' @param bw smoothing bandwidth (see \\link{density})\n#' @param freq y-axis is frequency or probability (see \\link{hist})\n#' @param main title (see \\link{hist})\n#' @param xlab x axis label (see \\link{hist})\n#' @param ... other arguments to \\link{hist}\n#' @param col.density density line color\n#' @note \\code{freq} defaults to FALSE\n#' @return same as \\link{hist} plus a 'dns' component containing\n#' the density.\n#' @examples\n#' \\dontrun{\n#' lx.hist(rnorm(1000))\n#' lx.hist(rnorm(1000), main=\"Normal\", xlab=\"x\")\n#' }\n#\nlx.hist <- function(x, bw=\"nrd0\",\n                    freq=FALSE, \n                    main=paste(\"Histogram of\", xname),\n                    xlab=xname,\n                    ...,\n                    col.density='blue') {\n  xname <- paste(deparse(substitute(x), 500), collapse = \"\\n\")\n  res <- hist(x, freq=freq, main=main, xlab=xlab, ...)\n  dns <- lx.density(x, bw=bw)\n  norm <- if (freq) \n            sum(res$counts) / length(res$counts) / sum(dns$y) * length(dns$y)\n          else 1\n  lines(dns$x, dns$y * norm, col=col.density)\n  res$dns <- dns\n  invisible(res)\n}\n\n\n# -------------------------------------------------\n#' add inset plot into current plot\n#' @description\n#' add a small (inset) plot in current plot\n#' @param ... same arguments as in generic \\link{plot}\n#' @param inset.pos inset position 'tl', 'tr', 'bl', 'br'\n#' @param inset.alpha inset size factor\n#' @param inset.margin inset margin\n#' @details\n#' inset position indicate the poistion of the inset as tl:top-left,\n#' tr:top-right, bl=bottom-left, br:bottom-right\n#' @examples\n#' \\dontrun{\n#' plot(function(x) {sin(x*10)/x}, col=\"red\", ylab=\"\", main=\"main-plot\")\n#' lx.plot.inset(function(x) {cos(x*20)}, ylab=\"\", xlab=\"inset\", cex.axis=0.5,\n#'               inset.pos='tr', inset.alpha=0.5)\n#' }\n#\nlx.plot.inset <- function(..., inset.pos=c('tr', 'tl', 'br', 'bl'), \n                          inset.alpha=0.5, inset.margin=0.01) {\n  inset.pos <- match.arg(inset.pos)\n  .fig <- function(pos='tr', alpha=0.5, margin=0.01) {\n    switch(pos,\n           tl = c(margin, alpha-margin, 1-alpha+margin, 1-margin),\n           tr = c(1-alpha+margin, 1-margin, 1-alpha+margin, 1-margin),\n           bl = c(margin, alpha-margin, margin, alpha-margin),\n           br = c(1-alpha+margin, 1-margin, margin, alpha-margin),\n           c(margin, alpha-margin, 1-alpha+margin, 1-margin))\n  }\n  ofig <- par('fig')\n  par(fig=.fig(pos=inset.pos, alpha=inset.alpha, margin=inset.margin), new=TRUE)\n  plot(...)\n  par(fig=ofig)\n  invisible(NULL)\n}\n",
    "created" : 1496570972902.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "76020944",
    "id" : "74C71FA0",
    "lastKnownWriteTime" : 1502752261,
    "last_content_update" : 1502752261333,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/lx/R/lx.plot.r",
    "project_path" : "R/lx.plot.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}