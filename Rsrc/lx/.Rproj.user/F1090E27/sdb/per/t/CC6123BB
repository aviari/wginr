{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: lx.table.r 120 2016-10-29 07:45:45Z viari $\n# lx counts and contingency tables utilities\n#\n\n# -------------------------------------------------\n#' @name lx.tables\n#' @docType data\n#' @title cross tabulation and contigency tables\n#' @description\n#' there are several lx function to built contingency tables.\\cr\n#' \\itemize{\n#'  \\item \\link{lx.table}         : count or contingency table with full levels\n#'  \\item \\link{lx.table.bycols}  : k-dimensional contingency table(s) from columns\n#'  \\item \\link{lx.table.bypairs} : pairwise contingency table(s) from columns\n#'  \\item \\link{lx.table.byfacts} : count or contingency table by factors in columns\n#'  \\item \\link{lx.table.bysets}  : cross table of sets intersections\n#'  \\item \\link{lx.table.bymsets} : cross table of multisets intersections\n#'  \\item \\link{lx.table.bycoocs} : cross table of co-occurences in sets\n#' }\n#' \\itemize{\n#'  \\item \\link{lx.table.margins} : add margins (total) to a 2-dimensional contingency table\n#' }\n#'\nNULL\n\n# -------------------------------------------------\n#' count or contingency table with specified levels\n#' @description\n#' same as \\link{table} but force levels.\n#' (call \\link{factor} on \\code{...} then call \\link{table})\n#' \n#' @param ... same as \\link{table}\n#' @param levels levels to force\n#' @note\n#' \n#' \\link{table} is equivalent to \\code{lx.table(...)}\n#' @seealso \\link{lx.tables}\n#' @examples\n#' x <- round(runif(10, 1, 10))\n#' lx.table(x, levels=1:10)\n#' y <- round(runif(10, 1, 10))\n#' lx.table(x, y, levels=1:10)\n#' \nlx.table <- function(..., levels=NULL) {\n  if (is.null(levels))\n    table(lapply(list(...), factor))\n  else\n    table(lapply(list(...), factor, levels=levels))\n}\n\n# -------------------------------------------------\n#' tapply-like with specified levels\n#' @description\n#' similar to \\link{tapply} but force levels and call FUN\n#' on empty subsets.\n#' \n#' @param x an atomic object, typically a vector\n#' @param by a vector of factors (or anything that can be converted to factors)\n#'        of same length as \\code{x}\n#' @param FUN the function to be applied\n#' @param levels levels to force\n#' @param ... optional arguments to FUN\n#'\n#' @return a vector of the same length as \\code{levels} (or levels(by) if levels==NULL),\n#' each value is the result of calling FUN on the subset of x at given level.\n#' \n#' @seealso \\link{lx.tables}\n#' @examples\n#' xval  <- c( 1,   2,   3,   0,   1 )   \n#' group <- c('a', 'b', 'c', 'a', 'a')\n#' lx.tapply(xval, by=group, length)\n#' lx.tapply(xval, by=group, sum)\n#' lx.tapply(xval, by=group, length, levels=c('a', 'b', 'd'))\n#' \nlx.tapply <- function(x, by, FUN, levels=NULL, ...) {\n  by   <- if(is.null(levels)) factor(by) else factor(by, levels=levels)\n  res  <- tapply(x, by, FUN, ..., simplify=T)\n  isna <- is.na(res)\n  if (any(isna))\n    res[isna] <- FUN(c())\n  res\n}\n\n# -------------------------------------------------\n#' k-dimensional contingency table(s) from columns\n#' @param tab a table (matrix or dataframe) of nominal values\n#' @param by a list of column indices or names (of length k >= 2)\n#' @return k-dimensional contingency table, defined as the\n#'         contigency table of the first two columns stratified on other columns\n#' @note this is the same as \\code{table(tab[,by])}\n#' @seealso \\link{lx.tables}\n#' @examples\n#' data(lx.iris)\n#' tab <- lx.iris\n#' # default: stratify by last dimensions (here sepal)\n#' lx.table.bycols(tab)\n#' # stratify by species (column index 1)\n#' lx.table.bycols(tab, c(2,3,1))\n#' # same as\n#' lx.table.bycols(tab, c(\"petal\", \"sepal\", \"species\"))\n#\nlx.table.bycols <- function(tab, by=colnames(tab)) {\n  if (is.null(by)) by <- 1:ncol(tab)\n  table(as.data.frame(tab)[,by])\n}\n\n# -------------------------------------------------\n#' pairwise contingency table(s) from columns\n#' @param tab a table (matrix or dataframe) of nominal values\n#' @param by a list of column indices or names (of length k >= 2)\n#' @return list of C(k, n) contingency tables crossing all pairs of columns\n#'         in \\code{by}\n#' @seealso \\link{lx.tables}\n#' @examples\n#' data(lx.iris)\n#' tab <- lx.iris\n#' lx.table.bypairs(tab)\n#\nlx.table.bypairs <- function(tab, by=colnames(tab)) {\n  if (is.null(by)) by <- 1:ncol(tab)\n  comb <- combn(by, 2, simplify=FALSE)\n  res <- lapply(comb, function(x) lx.table.bycols(tab, by=x))\n  names(res) <- sapply(comb, paste0, collapse=\"_by_\")\n  res\n}\n\n# -------------------------------------------------\n#' make contingency table(s) by factors in columns\n#' @param tab a table (matrix or dataframe) of nominal values\n#' @param by a list of column indices or names (of length k >= 1)\n#' @return a 2-dimensional contingency table T of size f x k,\n#'         where f = number of levels in \\code{tab[,by]}\n#'         and T[i,j] equals to the number of rows with factor i in column j\n#' @seealso \\link{lx.tables}\n#' @examples\n#' data(lx.iris)\n#' tab <- lx.iris\n#' lx.table.byfacts(tab)\n#\nlx.table.byfacts <- function(tab, by=colnames(tab)) {\n  if (is.null(by)) by <- seq_len(ncol(tab))\n  tab <- tab[,by]\n  lev <- sort(unique(factor((unlist(tab)))))\n  if (is.null(dim(tab))) tab <- matrix(tab, ncol=1)\n  apply(tab, 2, function(x) table(factor(x, levels=lev)))\n}\n\n# -------------------------------------------------\n#' cross table of sets intersections\n#' @param lsets a list of n named sets Si\n#' @return n x n table where entry T[i,j] equals the size of Si inter Sj\n#' @note aka \\code{outer(lsets, lsets, function(x,y) \\{ length(intersect(x,y)) \\})}\n#'       but \\code{outer} does not work for this\n#' @seealso \\link{lx.tables}\n#' @examples\n#' lx.table.bysets(list(a=c(1,2), b=c(1,3), c=c(2,3,4)))\n#' # this the same as \n#' lx.table.bysets(list(a=c(1,2,2), b=c(1,3), c=c(2,3,4,3)))\n#' # since a, b, c are considered to as sets\n#\nlx.table.bysets <- function(lsets) {\n  n <- length(lsets)\n  res <- matrix(nrow=n, ncol=n)\n  for (i in 1:n) {\n    for (j in 1:n) { \n      res[i,j] <- length(intersect(unlist(lsets[i]), unlist(lsets[j])))\n    }\n  }\n  res <- data.frame(res)\n  names(res) <- row.names(res) <- names(lsets)\n  res\n}\n\n# -------------------------------------------------\n#' cross table of multisets intersections\n#' @param lsets a list of n named multisets Mi\n#'        each multiset can be specified as a list with repeated elements\n#'        e.g. c('a', 'a', 'b', 'c', 'b')\n#'        or, with as.card=TRUE, as a numeric list \n#'        e.g. c(a=2, b=2, c=1)\n#' @param as.card use cardinality in multiset definition\n#' @return n x m table T, where m = number of different elements in all Mi\n#'         and T [i, j] equals to the number of elements j in multiset i\n#' @seealso \\link{lx.tables}\n#' @examples\n#' lsets <- list(A=c('a', 'a', 'b'), B=c('a'), C=c('a', 'b', 'b', 'c'), D=c('c'))\n#' lx.table.bymsets(lsets)\n#' lsets <- list(A=c(a=2, b=1), B=c(a=1), C=c(a=1, b=2, c=1), D=c(c=1))\n#' lx.table.bymsets(lsets, as.card=TRUE)\n#\nlx.table.bymsets <- function(lsets, as.card=FALSE) {\n  if (! as.card) lsets <- sapply(lsets, table)\n  lev <- sort(unique(unlist(sapply(lsets, names))))\n  res <- sapply(lsets, function(x) { \n    sapply(lev, function(y) { x[y] }) })\n  res <- apply(res, c(1,2), function(x) { if (is.na(x)) 0 else x })\n  res <- data.frame(t(res))\n  names(res) <- lev\n  res\n}\n\n# -------------------------------------------------\n#' cross table of co-occurences in sets\n#' @param lsets a list of sets Si\n#' @param levels elements to keep (if NULL keeps all elements)\n#' @return n x n table where n = |union(Si)| and entry T[i,j] equals the number\n#'         of co-occurences of elements i and j in sets.\n#'         diagonal elements are the number of occurences of each element.\n#' @seealso \\link{lx.tables}\n#' @examples\n#' l <- list(c('a'), c('a', 'b'), c('a', 'b', 'c'))\n#' lx.table.bycoocs(l)\n#'\nlx.table.bycoocs <- function(lsets, levels=NULL) {\n  if (is.null(levels))\n    levels <- sort(unique(unlist(lsets)))\n  \n  nlev <- length(levels)\n  cmat <- matrix(0, ncol=nlev, nrow=nlev, dimnames=list(levels, levels))\n  \n  for (e in lsets) {\n    e <- intersect(e, levels)\n    if (length(e) > 1) {\n      apply(combn(e, 2), 2, function(x) {\n        i <- factor(x[1], levels)\n        j <- factor(x[2], levels)\n        cmat[i, j] <<- cmat[j, i] <<- cmat[i, j] + 1\n      })\n    }\n    for (ee in e) {\n      i <- factor(ee, levels)\n      cmat[i, i] <- cmat[i, i] + 1\n    }\n  }\n  cmat\n}\n\n# -------------------------------------------------\n#' add margins (total) to a 2-dimensional contingency table\n#' @param ctab 2-dimensional contingency table\n#' @param margin which margin to add\n#'     1 (total by rows), \n#'     2 (total by columns) \n#'     c(1,2) both margins\n#'     0 do nothing\n#' @seealso \\link{lx.tables}\n#' @examples\n#' data(lx.iris)\n#' lx.table.margins(lx.table.bycols(lx.iris, by=1:2))\n#'\nlx.table.margins <- function(ctab, margin=c(1,2)) {\n  if (2 %in% margin) ctab <- cbind(ctab, total=apply(ctab, 1, sum))\n  if (1 %in% margin) ctab <- rbind(ctab, total=apply(ctab, 2, sum))\n  ctab\n}\n\n# -------------------------------------------------\n# <internal> <no-export>\n# for lx.condsum - run-length-encoding version\n#\n.condsum.rel <- function(xvar, yvar, zero.rm, mx) {\n  \n  # add fake data if zero counts should be included\n  #\n  if (! zero.rm) {\n    zero <- which(tabulate(xvar-mx) == 0)\n    xvar <- c(zero+mx, xvar)\n    yvar <- c(rep(0, length(zero)), yvar)\n  }\n  \n  # tabulate using rle\n  #\n  \n  ordx <- order(xvar)\n  rle  <- rle(xvar[ordx])\n  csy  <- cumsum(yvar[ordx])\n  csl  <- cumsum(rle$lengths)\n  res  <- cbind(rle$values, rle$length, diff(c(0, csy[csl])))\n  \n  # fix zero counts\n  #\n  if (! zero.rm) {\n    res[zero+1,2] <- res[zero+1,3] <- 0\n  }\n  \n  res\n}\n\n\n# -------------------------------------------------\n# <internal> <no-export>\n# for lx.condsum - cross product version\n#\n.condsum.cross <- function(xvar, yvar, zero.rm, mx, my, nx, ny) {\n  \n  # shift values to 0\n  #\n  xvar <- xvar - mx\n  yvar <- yvar - my\n  \n  # cross-tabulate xvar and yvar\n  #\n  xtab <- tabulate(xvar+1)\n  cros <- array(tabulate(yvar * nx + xvar + 1, nbins=(nx*ny)), dim=c(nx, ny))\n  cnt  <- 0:(ny-1)\n  ytab <- apply(cros, 1, function(r) r %*% cnt)\n  ytab <- ytab + xtab * my\n  \n  res <- cbind(seq_along(ytab)+mx-1, xtab, ytab)\n  \n  # remove empty bins if zero should not be included\n  #\n  if (zero.rm) {\n    isok <- xtab != 0\n    res <- res[isok,,drop=F]\n  }\n  \n  res\n}\n\n# -------------------------------------------------\n#' tabulate conditional sum of integer values.\n#' @description \n#' let xvar and yvar two integer vectors, this function\n#' tabulates the conditional \\code{sum(yvar|xvar)}. This is\n#' similar to \\link{aggregate}\\code{(y,x,FUN=sum)} but much quicker\n#' and limited to integer variables.\n#' @param xvar,yvar integer vectors of the same length\n#' @param zero.rm should zero counts be removed from results (as in \\link{aggregate})\n#' @param .maxrange,.maxrate internal parameters (see details)\n#' @return an nx3 numeric matrix with columns namdes \\code{x, cnt and sy}.\\cr\n#' \\code{x}   : tabulated values of x\\cr\n#' \\code{cnt} : counts for each x\\cr\n#' \\code{sy}  : sum(y|x) the sum of y values for each x\n#' @details \n#' the function uses two different algorithms (called rle and crossprod)\n#' depending upon the length and range of xvar and yvar. crossprod is\n#' usually quicker when x-range and y-range are small and n is large \n#' but uses more memory. rle runs in \\code{O(n.log(n))} and depends only on\n#' x-range.\\cr\n#' the choice is done on the following (simplified) condition\\cr\n#' \\code{if ((xrange*yrange > .maxrange) || (xrange*yrange/n.log(n) > .maxrate))\n#' then rle else crossprod}. this is a tradeoff between memory usage and speed.\\cr\n#' if you want to experiment with both algorithms to fit your particular\n#' data, you may therefore force rle by setting \\code{.maxrange=0} and force\n#' crossprod by setting \\code{.maxrange=Inf and .maxrate=Inf}\n#' @examples\n#' n = 1e4\n#' x <- floor(runif(n=n, min=10, max=1000))\n#' y <- rpois(n=n, lambda=x)\n#' ax <- aggregate(y, by=list(x), FUN=sum)\n#' bx <- lx.condsum(x, y)\n#' cx <- lx.condsum(x, y, .maxrange=0) # force rle\n#' all.equal(as.matrix(ax), bx[,c(1,3)], check.attributes=FALSE)\n#' identical(bx, cx)\n#' \n#' y <- y[x!=500]\n#' x <- x[x!=500]\n#' bx <- lx.condsum(x, y, zero.rm=FALSE)\n#' cx <- lx.condsum(x, y, zero.rm=FALSE, .maxrange=0)\n#' identical(bx, cx)\n#' \nlx.condsum <- function(xvar, yvar, zero.rm=TRUE,\n                       .maxrange=1e9, .maxrate=1) {\n  \n  colnames <- c(\"x\", \"cnt\", \"sy\")\n  \n  # remove NA's\n  #\n  isok <- ! is.na(xvar+yvar)\n  xvar <- xvar[isok]\n  yvar <- yvar[isok]\n  n    <- length(xvar)\n  \n  if (n == 0)\n    return(matrix(nrow=0, ncol=3, dimnames=list(NULL, colnames)))\n  \n  lx.stopif(length(xvar) != length(yvar),\n            \"xvar and yvar must have same length\") \n  \n  # get range\n  #\n  mx <- min(xvar, na.rm=T)\n  my <- min(yvar, na.rm=T)\n  nx <- max(xvar, na.rm=T) - mx + 1\n  ny <- max(yvar, na.rm=T) - my + 1\n  \n  \n  # choose proper algorithm\n  #\n  res <- if ((nx*ny > .maxrange) || (nx*ny/n/log(n,10) > .maxrate))\n    .condsum.rel(xvar, yvar, zero.rm, mx)\n  else\n    .condsum.cross(xvar, yvar, zero.rm, mx, my, nx, ny)\n  \n  colnames(res) <- colnames\n  res\n}\n",
    "created" : 1496479768190.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1061026634",
    "id" : "CC6123BB",
    "lastKnownWriteTime" : 1503003727,
    "last_content_update" : 1503003727,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/lx/R/lx.table.r",
    "project_path" : "R/lx.table.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}