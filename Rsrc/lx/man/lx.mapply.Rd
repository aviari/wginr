% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lx.apply.r
\name{lx.mapply}
\alias{lx.mapply}
\title{mapply wrapper}
\usage{
lx.mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE,
  use.threads = lx.use.threads(), mc.cores = lx.options("mc.cores"),
  mc.preschedule = TRUE)
}
\arguments{
\item{FUN}{the function to be applied. see \link{mapply}.}

\item{...}{arguments to vectorize over. see \link{mapply}.}

\item{MoreArgs}{a list of other arguments to FUN. see \link{mapply}.}

\item{SIMPLIFY}{see \link{mapply}.}

\item{USE.NAMES}{see \link{mapply}.}

\item{use.threads}{use multithreading}

\item{mc.cores}{The number of cores to use. see \link{mclapply}.}

\item{mc.preschedule}{perform prescheduling. see \link{mclapply}.}
}
\description{
\code{lx.mapply} will call different \link{mapply} flavors
depending upon the \code{use.threads}.argument:\cr
if use.threads is TRUE then\cr
__use \link{mcmapply}\cr
else\cr
__use \link{mapply} (without progress bar)\cr
}
\note{
default value for  \code{pg.verbose} is taken from \link{lx.options}
and may therefore be controlled globally.

default values for \code{SIMPLIFY} and \code{USE.NAMES} is \code{TRUE}
as in \link{mapply}, this usually slow down process considerably,
you should consider using \code{FALSE} instead to speed up computations.

there is no mc.allow.recursive option in parallel::mcmapply.
don't ask me why... but the consequence is that the behavior
in case of a recursive call in child process is udefined.

there is no progress bar flavor yet
}
\examples{
n <- 100
system.time(x <- lx.mapply(function(x, y) rnorm(5000*(x+y)), 1:n, 1:n))
system.time(x <- lx.mapply(function(x, y) rnorm(5000*(x+y)), 1:n, 1:n, use.threads=TRUE))

}
