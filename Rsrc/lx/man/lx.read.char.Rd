% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lx.fileio.r
\name{lx.read.char}
\alias{lx.read.char}
\title{read character(s)}
\usage{
lx.read.char(handle, n = 1L, skip.null = FALSE, .raw = FALSE,
  .chunk.size = 100L)
}
\arguments{
\item{handle}{file handle (opened by \link{lx.open})}

\item{n}{integer, (maximum) number of chars to read}

\item{skip.null}{logical, skip over NULL (see details)}

\item{.raw}{logical, skip processing (see details)}

\item{.chunk.size}{(internal parameter) size of chunks to use
when skip.null==FALSE and n < 0}
}
\value{
character string
}
\description{
read characters from file handle stopping or not on
NULL chars.
}
\details{
\preformatted{
if skip.null==FALSE (default)
  if (n >= 0) then input will stop either when
              n chars have been read or a NULL character is found
              or EOF has been reached.
  if (n < 0) then input will stop on first NULL character
             (or EOF).
if skip.null==TRUE
   read will skip over NULL chars until either
   n chars have been read (not counting NULLs)
   or EOF has been reached.

.raw == TRUE assume that the input stream contains
exactly n bytes without embedded NULLs. this will skip
all checking and processing (ignoring skip.null parameter).
this is intended for high speed reading when you know exactly
what is currently in stream.
}
}
\note{
n is an integer, therefore limited to 2,147,483,647
}
\examples{
fh <- lx.open(lx.system.file("samples/test_bin.bst"))
s <- lx.read.char(fh, n=40)
nchar(s)  # 5
lx.rewind(fh)
s <- lx.read.char(fh, n=40, skip=TRUE)
nchar(s, type="bytes")  # 40
lx.close(fh)

}
\seealso{
\link{lx.read.int8} to read bytes (including NULL),
\link{lx.read.string} as an alternative form.
}
