% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lx.fileio.r
\name{lx.read.int64}
\alias{lx.read.int64}
\title{read binary 64 (actually 53) bits integer}
\usage{
lx.read.int64(handle, n = 1L, signed = FALSE, little.endian = TRUE)
}
\arguments{
\item{handle}{file handle (opened by \link{lx.open})}

\item{n}{number of integers to read}

\item{signed}{read signed integer(s)}

\item{little.endian}{integer encoding is little endian}
}
\value{
(vector of) double(s) with possible precision loss.
}
\description{
read binary 64 (actually 53) bits integer
}
\note{
since R double have 53 bits precision the return
values are only exact for values in range
\code{[-2^53, 2^53] = [-9007199254740992,9007199254740992] for signed long}
and \code{[0, 2^53] = [0, 9007199254740992] for unsigned long}

n is an integer, therefore limited to 2,147,483,647
}
\examples{
fh <- lx.open(lx.system.file("samples/test_bin.bst"))
cod  <- lx.read.int32(fh, n=1)
nseq <- lx.read.int32(fh, n=1)
s1 <- lx.read.string(fh)
siz1 <- lx.read.int64(fh, n=1)
crc1 <- lx.read.int32(fh, n=1)
s2 <- lx.read.string(fh)
siz2 <- lx.read.int64(fh, n=1)
crc2 <- lx.read.int32(fh, n=1)
ss1 <- lx.read.char(fh, n=siz1)
ss2 <- lx.read.char(fh, n=siz2)
lx.close(fh)
}
