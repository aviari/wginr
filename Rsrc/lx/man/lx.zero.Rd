% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lx.numerical.r
\name{lx.zero}
\alias{lx.zero}
\title{One dimensional Root (Zero) finding}
\usage{
lx.zero(fun, xmin = 0, xmax = 1, xtol = 10 * .Machine$double.eps,
  ytol = 10 * .Machine$double.eps, maxiter = 10000L, with.interval = TRUE,
  ..., .errorBound = TRUE)
}
\arguments{
\item{fun}{monotonic function on interval xmin, xmax}

\item{xmin}{minimum value of x}

\item{xmax}{maximum value of x}

\item{xtol}{tolerance on x (see details)}

\item{ytol}{tolerance on y=0 (see details)}

\item{maxiter}{max number of iterations (see details)}

\item{with.interval}{logical, provide lower and upper bounds for root}

\item{...}{additional arguments to fun}

\item{.errorBound}{logical, raise error if zero is not between xmin and xmax
boundaries.}
}
\value{
a named list with 4 components:
\itemize{
\item root : the root value
\item lower: root lower bound (see details)
\item upper: root upper bound (see details)
\item niter: number of iterations
}
}
\description{
look for a zero (root) of a continuous monotonic function 
by dichotomic search\cr
i.e. return value x such that \code{fun(x) = 0}.\cr
this function is similar to \link{uniroot} but additionally
returns a lower and upper bound of root (see details).
}
\details{
\code{fun} should be monotonic (either increasing or decreasing)
if not, the result will (probably) be wrong. Since the zero must be
located between \code{xmin} and \code{xmax},
\code{fun(xmin)} and \code{fun(xmax)} should be
of opposite sign else an error is raised, unless \code{.errorBound = FALSE}
in which case the closest boundary is returned (and niter is set to \code{NA})

the algorithm proceeds by dichotomic search (bissection) and convergence
is achieved when at least one of the following criterion is satisfied:\cr
\itemize{
\item \code{fun(x) = 0 +/- ytol}
\item the change in x for one step is less than \code{xtol}
\item the maximum number of iterations is reached
}
if \code{with.interval == TRUE} then a lower and upper bound for root
are additionally provided. Unless the maximum
number of iterations has been reached, the result guarantees that
\code{[lower,upper]} is the largest interval such that \code{for all x in
[lower+/-xtol, upper+/-xtol] fun(x)=0 +/- ytol}\cr
}
\note{
the algorithm is far from beeing optimal and is usually slower than
\link{uniroot}. So, if you don't care about lower and upper bounds, you
better have to use to \link{uniroot} instead.\cr

if zero is reached at xmin (resp. xmax) boundary, then the lower
(resp. upper) bound is truncated.\cr

either \code{xmin} or \code{xmax} may be a pole 
(i.e. \code{fun(x) = Inf}) but not both.\cr

there is no need to set \code{xtol} or \code{ytol} below 
\code{.Machine$double.eps}.
}
\examples{
# simple functions
lx.zero(function(x) x^2 - 0.2^2, ytol=1e-3)
lx.zero(function(x) log(x) - log(0.3), ytol=1e-3)
lx.zero(function(x) x - pi, xmax=10, ytol=1e-3)
lx.zero(function(x) pi - x, xmax=10, ytol=1e-3)
# out of bounds
tryCatch(lx.zero(function(x) x - 2), error=function(e) NA)
lx.zero(function(x) x - 2, .errorBound=FALSE)
# interval 
lx.zero(function(x) x^5, ytol=1e-3) # interval is truncated
lx.zero(function(x) x^5, ytol=1e-3, xmin=-1)
# poles
lx.zero(function(x) (x-0.5)/x/(2-x))
}
