% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thmm.init.r
\name{thmm.init}
\alias{thmm.init}
\title{initialize HMM}
\usage{
thmm.init(density, trans, init = NULL, ...)
}
\arguments{
\item{density}{a probability density function (pdf) such as \link{dnorm}
(see notes)}

\item{trans}{the transition matrix given either as a matrix, a vector
or a constant (see details)}

\item{init}{vector of probabilities of the initial states (see details)}

\item{...}{parameters of \code{density} (see examples)}
}
\value{
a DTHmm object describing the DTHmm
}
\description{
initialize a discrete time hidden markov model
(DTHmm)
}
\details{
the number of states (m) is determined from the ... arguments (see notes)
and should be consistent with the value passed to \code{trans} and
\code{init} if provided.

if \code{trans} is a constant then the transition matrix
is computed as a mxm matrix with \bold{off-diagonal} elements \code{trans}.

if \code{trans} is a vector (it should then be of length m) then the
transition matrix is computed as a mxm matrix with \bold{diagonal}
elements \code{trans}.

if \code{init} is NULL then \code{init} is computed as a vector
of uniform probabilities (1/m).

if \code{init} is not of length m then it is recycled/shortened to proper length m.
}
\note{
the pdf function \code{density} has the form:\cr
\code{density(x, ..., log=TRUE|FALSE)}\cr
see \link{dnorm}, \link{dpois}, \link{dbeta}, etc.
as examples but you may write your own as well, with the following specifications:\cr
\itemize{
\item \code{density} parameters must have default values if you don't specify
them in \code{...}
\item \code{density} must accepts vectors (including of NA's) as parameters
(possibly recycling them) (each parameter corresponds to each state) and return
a vector of length m (possibly of NA's) when called with a scalar \code{x}
(including NA). this is used to determine the actual number of states m.
\item (not mandatory) It may accept a vector (including of NA's) as \code{x} argument
(with individual states parameters) and return a vector of size \code{length(x)}.
this is used by the C code only, so if this condition is not satisfied the C code will
workaround but will run a bit slower (albeit still quicker than R code).
}
You may pass the function symbol or function name (character) as \code{density}
argument (but not a direct lambda expression nor anything fancy).

For multivariate HMM, the density function should accept a list of
(numeric) tuples as \code{x} argument (or anything equivalent like
a list of complex numbers for bivariate). The parameters can be
anything relevant to your mutivariate density distribution but
may be received as lists (one element for each state) instead
of vectors. See examples in \link{thmm} for details.
}
\examples{
# ---------------------------------------
# Normal (gaussian) HMM with two states
# full specification
trans <- matrix(c(0.9, 0.1, 0.1, 0.9), nrow=2)
init <- c(0.5, 0.5)
hmm <- thmm.init(dnorm, trans, init, mean=c(-1,1), sd=c(0.1, 0.1))

# ---------------------------------------
# *same as previous* with simplified call
hmm <- thmm.init(dnorm, 0.1, mean=c(-1,1), sd=0.1)

# ---------------------------------------
# three states HMM with Poisson distribution
hmm <- thmm.init(dpois, 0.1, lambda=1:3)

# ---------------------------------------
# two states HMM with Gamma distribution
hmm <- thmm.init(dgamma, 0.1, shape=c(3, 10), rate=c(1, 2))

# ---------------------------------------
# mixture of gaussians
# state1: mixture of 2 gaussians with mean=-1,1 sd=0.1,0.1 and prob=0.1,0.9
# state2: gaussian mean=0 sd=0.2
#
# we define first \\code{dmixnorm} as the pdf of a mixture of gaussians
# note that this function is 'vectorized' on parameters (and x either).
# the computation with log=TRUE will avoid underflow
#
dmixnorm <- function(x, mean=0, sd=1, prob=1, log=FALSE) {
  msp <- mapply(function(m, s, p) list(mean=m, sd=s, prob=p), mean, sd, prob, SIMPLIFY=FALSE)
  res <- if (log) {
    lapply(x, function(x) sapply(msp, function(p) {
      pp <- base::log(p$prob) + dnorm(x, mean=p$mean, sd=p$sd, log=TRUE)
      mp <- max(pp)
      mp + base::log(sum(exp(pp-mp)))
    }))
  } else {
    lapply(x, function(x) sapply(msp, function(p)
      sum(p$prob*dnorm(x, mean=p$mean, sd=p$sd, log=FALSE))))
  }
  unlist(res)
}
#
# then the hmm
hmm <- thmm.init(dmixnorm, 0.1, mean=list(c(-1,1), 0), sd=list(0.1, 0.2),
                                prob=list(c(0.5,0.5), 1))

# ---------------------------------------
# discrete distribution : binomial
#
# dbinom does not have default parameters
# so we need to specify all of them
hmm <- thmm.init(dbinom, 0.1, size=c(50, 100), prob=c(0.5, 0.1))

# ---------------------------------------
# discrete distribution : the dishonest casino
#
# we first define the pdf
#
dice <- function(x, p6=1/6, log=FALSE) {
  r <- unlist(lapply(x, function(x) {
    unlist(lapply(p6, function(p6) {
      if (is.na(x)) NA
      else if (x == 6) p6
      else if (x \%in\% 1:5) (1-p6)/5
      else 0
    })) }), recursive=FALSE)
  if (log) r <- base::log(r)
  r
}
# and the random generator (d->r)ice (see \\link{thmm.simulate})
rice <- function(n, p6=1/6) {
  sample(1:6, n, prob=c(rep((1-p6)/5, 5), p6), replace=TRUE)
}

hmm <- thmm.init(dice, 0.3, p6=c(1/6, 3/6))
obs <- thmm.simulate(hmm, 100)
\dontrun{
plot(obs$values)
}
}
