% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/thmm.forback.r
\name{thmm.backward}
\alias{thmm.backward}
\title{(log) backward probabilities}
\usage{
thmm.backward(hmm, obs, .useC = TRUE)
}
\arguments{
\item{hmm}{DTHmm model (from \link{thmm.init})}

\item{obs}{numerical vector of observations}

\item{.useC}{logical if TRUE (default) use C code else use R code}
}
\value{
list with one components: \code{logbeta}
(for symmetry with \link{thmm.forward})
\itemize{
\item\code{logbeta} : the (log of) backward probabilities (densities) matrix:\cr
\code{beta_{i,j} = Pr{ X_{i+1} = obs_{i+1}, ..., X_n = obs_n | state_i = j , hmm}}
that is the probability (density) of the ending partial sequence
\code{(obs_i+1, ..., obs_n)} given that we started at state j at time i,
for this hmm.
}
}
\description{
compute backward probabilities of observations
according to a discrete time hidden markov model (DTHmm).
}
\note{
the code takes care of rescaling values during calculation
to avoid underflow problems and is quite robust in practice.
}
\examples{
hmm <- thmm.init(dnorm, 0.1, mean=c(-1,1), sd=0.1)
obs <- c(rnorm(100, -1, 0.1), rnorm(100, 1, 0.1))
bwd <- thmm.backward(hmm, obs)
#
# test numerical stability
#
dif1 <- bwd$logbeta[-c(200,99),1] - bwd$logbeta[-c(200,99),2]
obs[100] <- 1000000  # this may creates overflow
bwd <- thmm.backward(hmm, obs)
dif2 <- bwd$logbeta[-c(200,99),1] - bwd$logbeta[-c(200,99),2]
max(abs((dif1-dif2)/dif1))
\dontrun{
plot(dif1)
points(dif2, col=2, cex=0.1)}
}
\seealso{
\link{thmm.forward}, \link{thmm.forward.backward}
}
