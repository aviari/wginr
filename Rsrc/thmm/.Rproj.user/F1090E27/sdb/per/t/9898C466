{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: $\n# tinyhmm : initialization, print\n#\n\n# -------------------------------------------------\n#' initialize HMM\n#' @description initialize a discrete time hidden markov model\n#' (DTHmm)\n#' @param density a probability density function (pdf) such as \\link{dnorm}\n#' (see notes)\n#' @param trans the transition matrix given either as a matrix, a vector\n#' or a constant (see details)\n#' @param init vector of probabilities of the initial states (see details)\n#' @param ... parameters of \\code{density} (see examples)\n#' @return a DTHmm object describing the DTHmm\n#' @details\n#' the number of states (m) is determined from the ... arguments (see notes)\n#' and should be consistent with the value passed to \\code{trans} and\n#' \\code{init} if provided.\n#'\n#' if \\code{trans} is a constant then the transition matrix\n#' is computed as a mxm matrix with \\bold{off-diagonal} elements \\code{trans}.\n#'\n#' if \\code{trans} is a vector (it should then be of length m) then the\n#' transition matrix is computed as a mxm matrix with \\bold{diagonal}\n#' elements \\code{trans}.\n#'\n#' if \\code{init} is NULL then \\code{init} is computed as a vector\n#' of uniform probabilities (1/m).\n#'\n#' if \\code{init} is not of length m then it is recycled/shortened to proper length m.\n#'\n#' @note\n#' the pdf function \\code{density} has the form:\\cr\n#' \\code{density(x, ..., log=TRUE|FALSE)}\\cr\n#' see \\link{dnorm}, \\link{dpois}, \\link{dbeta}, etc.\n#' as examples but you may write your own as well, with the following specifications:\\cr\n#' \\itemize{\n#' \\item \\code{density} parameters must have default values if you don't specify\n#' them in \\code{...}\n#' \\item \\code{density} must accepts vectors (including of NA's) as parameters\n#' (possibly recycling them) (each parameter corresponds to each state) and return\n#' a vector of length m (possibly of NA's) when called with a scalar \\code{x}\n#' (including NA). this is used to determine the actual number of states m.\n#' \\item (not mandatory) It may accept a vector (including of NA's) as \\code{x} argument\n#' (with individual states parameters) and return a vector of size \\code{length(x)}.\n#' this is used by the C code only, so if this condition is not satisfied the C code will\n#' workaround but will run a bit slower (albeit still quicker than R code).\n#' }\n#' You may pass the function symbol or function name (character) as \\code{density}\n#' argument (but not a direct lambda expression nor anything fancy).\n#'\n#' @note\n#' For multivariate HMM, the density function should accept a list of\n#' (numeric) tuples as \\code{x} argument (or anything equivalent like\n#' a list of complex numbers for bivariate). The parameters can be\n#' anything relevant to your mutivariate density distribution but\n#' may be received as lists (one element for each state) instead\n#' of vectors. See examples in \\link{thmm} for details.\n#'\n#' @examples\n#' # ---------------------------------------\n#' # Normal (gaussian) HMM with two states\n#' # full specification\n#' trans <- matrix(c(0.9, 0.1, 0.1, 0.9), nrow=2)\n#' init <- c(0.5, 0.5)\n#' hmm <- thmm.init(dnorm, trans, init, mean=c(-1,1), sd=c(0.1, 0.1))\n#'\n#' # ---------------------------------------\n#' # *same as previous* with simplified call\n#' hmm <- thmm.init(dnorm, 0.1, mean=c(-1,1), sd=0.1)\n#'\n#' # ---------------------------------------\n#' # three states HMM with Poisson distribution\n#' hmm <- thmm.init(dpois, 0.1, lambda=1:3)\n#'\n#' # ---------------------------------------\n#' # two states HMM with Gamma distribution\n#' hmm <- thmm.init(dgamma, 0.1, shape=c(3, 10), rate=c(1, 2))\n#'\n#' # ---------------------------------------\n#' # mixture of gaussians\n#' # state1: mixture of 2 gaussians with mean=-1,1 sd=0.1,0.1 and prob=0.1,0.9\n#' # state2: gaussian mean=0 sd=0.2\n#' #\n#' # we define first \\code{dmixnorm} as the pdf of a mixture of gaussians\n#' # note that this function is 'vectorized' on parameters (and x either).\n#' # the computation with log=TRUE will avoid underflow\n#' #\n#' dmixnorm <- function(x, mean=0, sd=1, prob=1, log=FALSE) {\n#'   msp <- mapply(function(m, s, p) list(mean=m, sd=s, prob=p), mean, sd, prob, SIMPLIFY=FALSE)\n#'   res <- if (log) {\n#'     lapply(x, function(x) sapply(msp, function(p) {\n#'       pp <- base::log(p$prob) + dnorm(x, mean=p$mean, sd=p$sd, log=TRUE)\n#'       mp <- max(pp)\n#'       mp + base::log(sum(exp(pp-mp)))\n#'     }))\n#'   } else {\n#'     lapply(x, function(x) sapply(msp, function(p)\n#'       sum(p$prob*dnorm(x, mean=p$mean, sd=p$sd, log=FALSE))))\n#'   }\n#'   unlist(res)\n#' }\n#' #\n#' # then the hmm\n#' hmm <- thmm.init(dmixnorm, 0.1, mean=list(c(-1,1), 0), sd=list(0.1, 0.2),\n#'                                 prob=list(c(0.5,0.5), 1))\n#'\n#' # ---------------------------------------\n#' # discrete distribution : binomial\n#' #\n#' # dbinom does not have default parameters\n#' # so we need to specify all of them\n#' hmm <- thmm.init(dbinom, 0.1, size=c(50, 100), prob=c(0.5, 0.1))\n#'\n#' # ---------------------------------------\n#' # discrete distribution : the dishonest casino\n#' #\n#' # we first define the pdf\n#' #\n#' dice <- function(x, p6=1/6, log=FALSE) {\n#'   r <- unlist(lapply(x, function(x) {\n#'     unlist(lapply(p6, function(p6) {\n#'       if (is.na(x)) NA\n#'       else if (x == 6) p6\n#'       else if (x %in% 1:5) (1-p6)/5\n#'       else 0\n#'     })) }), recursive=FALSE)\n#'   if (log) r <- base::log(r)\n#'   r\n#' }\n#' # and the random generator (d->r)ice (see \\link{thmm.simulate})\n#' rice <- function(n, p6=1/6) {\n#'   sample(1:6, n, prob=c(rep((1-p6)/5, 5), p6), replace=TRUE)\n#' }\n#'\n#' hmm <- thmm.init(dice, 0.3, p6=c(1/6, 3/6))\n#' obs <- thmm.simulate(hmm, 100)\n#' \\dontrun{\n#' plot(obs$values)\n#' }\n#\nthmm.init <- function(density, trans, init=NULL, ...) {\n  hmm <- .new(\"DTHmm\")\n\n  # get density function as name or symbol\n  #   density.name : function name\n  #   density.fun  : function\n  if (is.character(density)) {\n    density.name <- density\n    density.fun  <- get(density, mode=\"function\", envir=parent.frame())\n  } else if (is.function(density)) {\n    density.name <- deparse(substitute(density))\n    density.fun  <- density\n  } else {\n    density.name <- NULL\n  }\n\n  # check if density.name is valid (i.e. not a lambda or whatever exotic)\n  if (! identical(density.name, make.names(density.name)))\n    stop(\"'density' should be either a function symbol or function name\")\n\n  # 'hmm$density' will call density function as a closure (with *all* parameters)\n  # i.e. hmm$density(x) gives the probability densities at x\n  # this is mostly used in R Code. C Code use informations in hmm$info (see below)\n  hmm$density <- function(x, log=TRUE) density.fun(x, ..., log=log)\n\n  # get number of states by calling hmm$density(NA)\n  ns <- length(hmm$density(NA))\n\n  # transition matrix\n  hmm$trans <- if (is.matrix(trans)) trans else .transmat(trans, ns)\n  hmm$trans <- hmm$trans / rowSums(hmm$trans)\n  if (ns != nrow(hmm$trans)) stop(\"inconsistent transition matrix size\")\n  storage.mode(hmm$trans) <- \"double\"\n  if (any(is.na(hmm$trans) | hmm$trans < 0))\n    stop(\"transition matrix contains negative or NA entries\")\n  if (any(diag(hmm$trans) <= .Machine$double.xmin))\n    warning(\"some diagonal entries of transition matrix are zero\")\n\n  # initial probabilities\n  hmm$init  <- if (is.null(init)) 1/ns else init\n  hmm$init  <- head(rep(hmm$init, ns), ns)\n  hmm$init  <- hmm$init / sum(hmm$init)\n  storage.mode(hmm$init) <- \"double\"\n  if (any(is.na(hmm$init) | hmm$init < 0))\n    stop(\"initial probabilities contain negative or NA values\")\n\n  # keep useful information (mostly for C calls)\n  #  info$density    : density function name\n  #  info$args       : density arguments as a single list\n  #  info$sargs      : density arguments splitted by states\n  #  info$env        : environment needed to call info$density\n  #  info$vectorized : tell if density can be vectorized\n  #\n  # note: sargs is useful to access individual state parameters as hmm$info$sargs[[istate]]\n  #  e.g.: do.call(hmm$info$density, c(x=list(x), hmm$info$sargs[[istate]]), envir=hmm$info$env)\n  #        return the probability density at x for state istate\n  #\n  #  e.g.: sapply(hmm$info$sargs, function(x) x$mean) gives\n  #        the 'mean' parameters (of normal DTHmm) for all states\n  #\n\n  # force evaluation of density parameters ('...') in the context of the caller\n  args <- eval(substitute(list(...)), envir=parent.frame())\n\n  hmm$info <- list(density=density.name,\n                   args=list(args),\n                   env=parent.frame())\n\n  # and split them by state (recycling if necessary)\n  hmm$info$sargs <- lapply(1:ns, function(i)\n    lapply(args, function(x) .cycle(x,ns)[i]))\n\n  # more in-depth check of density\n  # these two conditions have eventually been removed\n  # the first one is too boring for the user\n  # the second one is not so easy to check if the first one is not satisfied\n  #\n  #     # check if density has proper default parameters\n  #     if (\"symbol\" %in% sapply(tail(formals(density), -1), typeof))\n  #       stop(\"'density' does not have default for all parameters\")\n  #\n  #     # check if density is properly vectorized on parameters\n  #     chk <- tryCatch(do.call(hmm$info$density, list(NA, rep(NA, ns)), envir=hmm$info$env),\n  #                     error=function(e) NULL)\n  #     if (length(chk) != ns) stop(\"'density' is not properly vectorized on parameters\")\n  #\n\n  # finally check if density is vectorized on first argument\n  chk <- tryCatch(lapply(hmm$info$sargs, function(arg)\n    do.call(hmm$info$density, c(list(rep(NA, 10)), arg), envir=hmm$info$env)),\n    error=function(e) NA)\n  hmm$info$vectorized <- all(sapply(chk, length) == 10)\n  if (! hmm$info$vectorized)\n    warning(\"'density' is not vectorized on x: this may slow down some computations\")\n\n  hmm\n}\n\n# -------------------------------------------------\n#' print method for DTHmm\n#' @param x a DTHmm object\n#' @param ... further arguments passed to or from other methods\n#' @return invisible(x)\n#\nprint.DTHmm <- function(x, ...) {\n  .f <- function(x) format(unclass(x))\n  .p <- function(...) print(paste(..., sep=\" \", collapse=\"\"), quote=F)\n  .p(\"-------------------------------------\")\n  .p(\"<Discrete Time HMM>\")\n  .p(\"-------------------------------------\")\n  .p(\"nb.states :\", nrow(x$trans))\n  .p(\"density   :\", x$info$density)\n  .p(\"args      :\", x$info$args)\n  .p(\"init      :\", paste(.f(x$init), collapse=\" \"))\n  .p(\"trans     :\")\n  apply(.f(x$trans), 1, function(x) .p(\" \", x))\n  .p(\"-------------------------------------\")\n  invisible(x)\n}\n\n# -------------------------------------------------\n#' get hmm parameters\n#' @description get hmm global and individual states parameters\n#' @param hmm DTHmm model (from \\link{thmm.init})\n#' @param what character parameter name to retrieve (all parameters if NULL (default))\n#' @return if \\code{what==NULL} return a list of 5 components: \\code{nstates},\n#' \\code{density}, \\code{args}, \\code{init}, \\code{trans}\n#' \\itemize{\n#' \\item nstates : integer number of states\n#' \\item density : character string name of probability density function\n#' \\item args : list (of length nstates) of named lists, each element\n#' gives the density function parameters for state i. (see note).\n#' \\item init : numerical vector of initial probabilities\n#' \\item trans : numerical transition matrix\n#' }\n#' if \\code{what!=NULL} then what should be either one of the above names or\n#' the name of one of the density function parameters. the function then return\n#' only this information.\n#' @examples\n#' # univariate gaussian hmm\n#' hmm <- thmm.init(dnorm, 0.1, mean=c(-1,1), sd=1)\n#' ns <- thmm.parameters(hmm, \"nstates\")\n#' means <- thmm.parameters(hmm, \"mean\")\n#' # viterbi decode\n#' obs <- rnorm(100)\n#' vit <- thmm.viterbi(hmm, obs)\n#' # as values\n#' means[vit$states]\n#'\nthmm.parameters <- function(hmm, what=NULL) {\n  res <- list(nstates=nrow(hmm$trans),\n              density=hmm$info$density,\n              args=hmm$info$sargs,\n              env=hmm$info$env,\n              init=hmm$init,\n              trans=hmm$trans)\n  if (is.null(what)) res\n  else if (what %in% names(res)) res[[what]]\n  else sapply(res$args, function(x) x[[what]])\n}\n\n# -------------------------------------------------\n#' forget internal environment\n#' @description\n#' In the current implementation a \\code{DTHmm} object\n#' keeps internally tracks of the \\link{parent.frame} environment where\n#' \\link{thmm.init} has been called. This is necessary to ensure that the\n#' \\code{...} arguments will be interpreted in the correct context.\n#' A drawback arise when you want to serialize (thru \\link{serialize}, \\link{save}\n#' or \\link{saveRDS}) this object. R will also serialize this environment and\n#' this may gives rise to a potentially huge file (if you have large objects\n#' in this environment).\\cr\n#' For now, a workaround is to replace this environment by \\link{globalenv}.\n#' This is safe if you do not refer to any parent frame variable in the\n#' code of \\code{density} (which is a good programming\n#' practice). A (temporary) helper function \\link{thmm.forget.env} is provided\n#' to perform this replacement. You may call it just before serializing.\\cr\n#' This unfortunate behavior will be changed in the future. I just need a bit\n#' of time to think about possible consequences of forgetting parent frame.\n#' @param hmm DTHmm model (from \\link{thmm.init})\n#' @return modified DTHmm\n#' @examples\n#' \\dontrun{\n#' myhmm <- function() { HUGE=rnorm(1e6); thmm.init(dnorm, 0.1, mean=c(-1,1), sd=1) }\n#' hmm0 <- myhmm()\n#' saveRDS(hmm0, \"hmm0.rds\")  # 7 Mb\n#' hmm1 <- thmm.forget.env(hmm0)\n#' saveRDS(hmm1, \"hmm1.rds\")  # 18 Kb\n#' hmm1 <- readRDS(\"hmm1.rds\")\n#' obs <- thmm.simulate(hmm1, 100, .seed=0)\n#' vit <- thmm.viterbi(hmm1, obs$values)\n#' plot(vit$states)\n#' points(obs$states, pch=16, cex=0.5, col=2)\n#' }\n#'\nthmm.forget.env <- function(hmm) {\n  if (! is.null(hmm)) {\n    hmm$info$env <- globalenv()\n    environment(hmm$density) <- globalenv()\n  }\n  hmm\n}\n\n\n",
    "created" : 1502880579769.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1011472366",
    "id" : "9898C466",
    "lastKnownWriteTime" : 1511562519,
    "last_content_update" : 1511562519135,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/thmm/R/thmm.init.r",
    "project_path" : "R/thmm.init.r",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}