{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: $\n# Asdog: Copy Number Analysis for WGS data\n#\n# Bayesian Change Point segmentation\n#\n\n# -------------------------------------------------\n# <internal> make complex number\n#\n.c <- function(x,y=x) complex(real=x, imaginary=y)\n\n# -------------------------------------------------\n# BCP segment rRC and AF\n#\n# ... additionnal arguments to bcp\n#\nasdog.bcp.segment <- function(rrc, baf, rcmax=4,\n                              smooth.rc=NULL,\n                              smooth.af=NULL,\n                              w0=NULL, p0=1e-10,\n                              sample.size=100000L,\n                              minseg.size=150L,\n                              ...) {\n  \n  # threshold - should have been done before - this is just a patch in case of\n  rrc <- pmax(pmin(rrc, rcmax), 0)\n  rrc[is.na(rrc)] <- median(rrc, na.rm=T)\n  \n  baf <- pmax(pmin(baf, 1), 0)\n  baf[is.na(baf)] <- 0.5\n  \n  # recenter baf on 0 and fold signal\n  fld <- abs(baf - 0.5)\n  \n  # smooth if requested\n  wrc <- if (is.null(smooth.rc)) rrc else lx.smooth.median(rrc, smooth.rc)\n  wfd <- if (is.null(smooth.af)) fld else lx.smooth.median(fld, smooth.af)\n\n  # decimate for speedup\n  if (is.na(sample.size)) {\n    pos <- seq_along(wrc)\n  } else {\n    pos <- lx.decimate(wrc, sample.size, as.index=T)\n    wrc  <- wrc[pos]\n    wfd  <- wfd[pos]\n  }\n  \n  # bcp crashes when less than 4 data points\n  if (length(wrc) <= 5) {\n    lx.warn(\"not enough points for BCP\")\n    return(seg=NULL, res=NULL)\n  }\n  \n  # make sure minseg.size is not too high\n  minseg.size <- max(2, min(minseg.size, length(wrc)))\n  \n  # segment using BCP\n  \n  # run BCP\n  lx.out(\"running bcp with p0=\", p0, \" w0=\", w0)\n  bcp <- bcp(cbind(wrc, wfd), w0=w0, p0=p0, ...)\n  means <- .c(bcp$posterior.mean[,1], bcp$posterior.mean[,2])\n  rle <- rle(means)\n\n  # make segments\n  #\n  seg <- data.frame(ifrom=head(cumsum(c(1, rle$lengths)), -1))\n  seg$ito <- seg$ifrom + rle$lengths - 1\n  \n  seg$pfrom <- pos[seg$ifrom]\n  seg$pto   <- pos[seg$ito]\n\n  seg$weight <- seg$ito - seg$ifrom + 1\n  \n  seg <- seg[seg$weight >= minseg.size,,drop=F]\n  \n  lx.out(\"kept \", nrow(seg), \" segments\")\n\n  seg$mean.rc <- apply(seg, 1, function(r) median(rrc[r[3]:r[4]]))\n  seg$sd.rc   <- apply(seg, 1, function(r)    mad(rrc[r[3]:r[4]]))\n\n  # unfold signal on segments\n  #\n  lx.out(\"unfolding segments\")\n  mfl <- apply(seg, 1, function(r) median(fld[r[3]:r[4]]))\n  sfl <- apply(seg, 1, function(r)    mad(fld[r[3]:r[4]]))\n\n  x <- t(mapply(function(m, s) asdog.unfold(m, s, type=\"median\")$solution,\n                mfl, sfl, USE.NAMES=F))\n  \n  seg$mean.af <- unlist(x[,1]) + 0.5\n  seg$sd.af   <- unlist(x[,2])\n  \n  lx.out(\"found \", nrow(seg), \" segments\", with.mem=T)\n  \n  list(seg=seg, res=list(bcp=bcp, pos=pos, obs.rc=wrc, obs.af=wfd))\n}\n\n",
    "created" : 1509539764286.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4098901156",
    "id" : "FC379642",
    "lastKnownWriteTime" : 1501850399,
    "last_content_update" : 1501850399,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.bcp.r",
    "project_path" : "R/asdog.bcp.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}