{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: asdog.gcmodel.build.r 321 2017-08-18 11:10:19Z viari $\n# Asdog: Copy Number Analysis for WGS data\n#\n# GC model contruction\n#\n\n# -------------------------------------------------\n# sample locations in provided regions\n# @param handle baf handle\n#\nasdog.sample <- function(handle, regions, size=1000000L, minspacin=0L,\n                         minreg=10000L, sorted=TRUE, maxloop=50L,\n                         use.threads=lx.use.threads()) {\n\n  if (size <= 0)\n    return(integer(0))\n\n  tot.size <- sum(regions[,3]-regions[,2]+1)\n\n  if (tot.size == 0) {\n    lx.warn(\"sampling empty regions yield empty sample\")\n    return(integer(0))\n  }\n  \n  #\n  # sample size points\n  #\n  if (minspacin <= 0) {\n    #\n    # simple version: without minimum spacing\n    #\n    lx.out(\"standard sampling \", size, \" points\" )\n    sampled <- coords.sample(handle, regions, size=size)\n  }\n  else {\n    #\n    # more sophisticated version : with minimum spacing\n    #\n    # first determine sampling factor\n    #\n    tot.loop <- ceiling(2.7 * minspacin * size / tot.size)\n    if (tot.loop > maxloop) {\n      lx.warn(\"minspacin \", minspacin, \" too large, for maxloop \", maxloop)\n      minspacin <- ceiling(maxloop * tot.size / size / 2.7)\n      lx.out(\"minspacin reduced to  \", minspacin)\n    }\n    samp.size <- min(1.2 * size, ceiling(tot.size / minspacin))\n    #\n    # sampling loop\n    #\n    sampled <- integer(0)\n    samp.try <- samp.tot <- 0\n    lx.out(\"discrete sampling \", size , \" points by \", samp.size)\n    while ((samp.tot < size) && (samp.try < 2*maxloop)) {\n      samp.try <- samp.try + 1\n      lx.out(\"subsampling #\", samp.try)\n      coords <- sort(coords.sample(handle, regions, size=samp.size))\n      coords <- coords[diff(coords) > minspacin]\n      sampled <- c(sampled, coords)\n      samp.tot <- length(sampled)\n      lx.out(\"subsampled \", length(coords), \" points, total \", samp.tot, \"/\", size, \" (\", round(samp.tot*100/size),\"%)\")\n      regions <- regions.exclude(handle, coords, spaceleft=minspacin,\n                                 spaceright=minspacin, minreg=minreg, use.threads=use.threads)\n    }\n    #\n    # resample to requested size\n    #\n    if (length(sampled) > size) {\n      lx.out(\"final resampling to size \", size)\n      sampled <- lx.sample(sampled, size=size, replace=F)\n    }\n    lx.out(\"total sampled \", length(sampled))\n  }\n\n  lx.out(\"  sampling done\", with.mem=T)\n  \n  if (sorted) sort(sampled) else sampled\n}\n\n# -------------------------------------------------\n# sample locations by gc strata in provided regions\n#\nasdog.sample.bygc <- function(handle.basta, regions, \n                              size=1000000, gcwindow=1000, gcbins=4,\n                              minspacin=0, minreg=gcwindow,\n                              flatten=TRUE, sorted=TRUE, maxloop=50,\n                              use.threads=lx.use.threads()) {\n  # split regions by gc\n  #\n  regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow, \n                                 nstrata=gcbins, minreg=minreg,\n                                 use.threads=use.threads)\n\n  # init loop\n  #\n  totsize <- rep(0, gcbins)\n  allow   <- rep(T, gcbins)\n  sampled <- rep(list(NULL), gcbins)\n\n  while (sum(totsize) < size) {\n\n    left <- size - sum(totsize)\n    reqsize <- ceiling(rep(left, gcbins) / sum(allow))\n    reqsize[! allow] <- 0\n    \n    lx.out(\"sampling by gc \", left, \" points left on \", size, \" (\", round((size-left)*100/size), \"% done)\")\n\n    # sample within regions\n    #\n    samp <- lapply(seq_along(regions), function(i) {\n      asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,\n                 minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)\n    })\n    sampsize <- sapply(samp, length)\n    sampled <- mapply(c, sampled, samp, SIMPLIFY=F)\n    \n    allow <- allow & (sampsize > reqsize/2)\n    totsize <- totsize + sampsize\n\n    if (sum(sampsize) == 0) {\n      lx.warn(\"sampling exhausted at \", sum(totsize), \" points\")\n      break\n    }\n  }\n  \n  if (flatten) {\n    sampled <- unlist(sampled, use.names=F)\n    if (sorted) sampled <- sort(sampled)\n  }\n  \n  sampled\n}\n\n\n# =================================================\n# API\n# =================================================\n\n# -------------------------------------------------\n#' compute GCCorrect model\n#' @description\n#' Empirical loess GC model\n#\nasdog.gcmodel <- function(params, use.threads=lx.use.threads()) {\n  \n  #-------------------------------\n  # init results\n  #-------------------------------\n  \n  model <- asdog.object('GCModel', params=params)\n  \n  asdog.print.params(asdog.filter.params(params, in.filter=\"gccorrect:\"))\n  \n  #-------------------------------\n  # open the basta and baf files\n  #-------------------------------\n  \n  lx.out(\"---------------------------------------\")\n  lx.out(\"Opening Basta and Baf files\")\n  lx.out(\"---------------------------------------\")\n\n  name <- asdog.check.file(params$ref, \"bst\")\n  basta <- basta.open(name)\n  \n  name <- asdog.check.file(params$base, \"baf\")\n  baf <- baf.open(name)\n\n  #\n  # keep sequence header\n  #\n  \n  model$header <- basta$header\n  \n  #-------------------------------\n  # prepare sampling regions\n  #-------------------------------\n  \n  lx.out(\"---------------------------------------\")\n  lx.out(\"Prepare sampling regions\")\n  lx.out(\"---------------------------------------\")\n  \n  .rsize <- function(x) x[,3] - x[,2] + 1\n  .tsize <- function(x) sum(.rsize(x))\n\n  #\n  # all regions from basta\n  #\n\n  regions <- basta2clocs(basta)\n  \n  chrs <- regions[,1]\n  \n  lx.out(\"basta regions: \", length(chrs), \" chromosomes\")\n\n  if (length(params$chrs) == 0)\n    params$chrs = chrs\n\n  chrs <- intersect(chrs, params$chrs)  \n  \n  lx.stopif(length(chrs) == 0, \"empty list of chromosomes\")\n  \n  lx.out(\"filtering chromosomes indexes [\", chrs, \"]\")\n  \n  regions <- regions[chrs,,drop=F]\n\n  #\n  # read user's regions\n  #\n  \n  regions.names <- lapply(params$gcmodel.regions.name, function(x) {\n      x <- sub('@BASE@', params$base, x)\n      x <- sub('@base@', basename(params$base), x)\n      x <- sub('@REF@',  params$ref, x)\n      x <- sub('@ref@',  basename(params$ref), x)\n      x\n    })\n  \n  lx.out(\"user's regions: \", paste(regions.names, collapse=', '))\n\n  regions <- regions.bybed(basta, regions.names, \n                          init=regions,\n                          minreg=params$gcmodel.regions.minreg,\n                          use.threads=use.threads)\n  \n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n\n  #\n  # remove regions with N's\n  #\n  \n  lx.out(\"removing regions with N's\")\n  regions <- regions.byacgt(basta, init=regions, \n                            minreg=params$gcmodel.regions.minreg,\n                            use.threads=use.threads)\n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n  \n  #\n  # make large regions (for large GC window model only)\n  #\n  \n  has.large.window <- params$gcmodel.large.winrange[[2]] != 0\n  \n  if (has.large.window) {\n\n    lx.out(\"making large windows regions\")\n    \n    lwidth <- params$gcmodel.large.winrange[[2]]\n    delta  <- params$gcmodel.regions.joinsize[1]\n    regions.large <- clocs.join(regions, delta=delta, minsize=1)\n    \n    while (median(.rsize(regions.large)) < lwidth) {\n      delta <- 2 * delta\n      if (delta > params$gcmodel.regions.joinsize[2]) break\n      regions.large <- clocs.join(regions, delta=delta, minsize=1)\n      lx.out(\"increasing delta-join to \", delta)\n    }\n    \n    regions.large <- clocs.join(regions, delta=delta, minsize=lwidth)\n    regions.large <- regions.trim(regions.large, trim=lwidth/2,\n                                  minreg=params$gcmodel.regions.minreg)\n    \n    lx.out(\"yielding \", nrow(regions.large), \n           \" large regions covering \", .tsize(regions.large), \" bp\")\n  }\n\n  #\n  # now select 'monoploid' regions.\n  # to this purpose, we first get mean coverage\n  # per chunks of 10K in each region, compute smoothed\n  # coverage distribution and select a single band\n  # in this distribution.\n  # there are several possible flavors for defining this\n  # band: => params$gcmodel.regions.band\n  #\n   \n  lx.out(\"keeping monoploid regions : \", params$gcmodel.regions.band)\n  \n  regions <- regions.bycover.band(baf, init=regions,\n                                  binsize=params$gcmodel.regions.binsize,\n                                  model=params$gcmodel.regions.band,\n                                  smooth.k=params$gcmodel.regions.smooth,\n                                  minreg=params$gcmodel.regions.minreg,\n                                  keep.bins=TRUE,\n                                  use.threads=use.threads)\n\n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n  \n  # keep regions bins in model$regions\n  #\n  \n  model$regions <- list()\n  \n  for (att in setdiff(names(attributes(regions)), c(\"dim\", \"names\", \"dimnames\"))) {\n    model$regions[[att]] <- attr(regions, att)\n    attr(regions, att) <- NULL\n  }\n\n  #\n  # finally trim 1 kb from each region\n  #\n  \n  lx.out(\"trimming regions\")\n  regions <- regions.trim(regions,\n                          trim=params$gcmodel.small.winrange[2], ##\n                          minreg=params$gcmodel.regions.minreg)\n  \n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n  \n  #\n  # intersect with large regions\n  #\n  \n  if (has.large.window) {\n    lx.out(\"intersect with large windows\")\n    regions <- clocs.inter(regions, regions.large, \n                           minsize=params$gcmodel.regions.minreg,\n                           use.threads=use.threads)\n    lx.out(\"yielding \", nrow(regions), \n           \" regions covering \", .tsize(regions), \" bp\")\n  } \n  \n  #\n  # keep final regions in model$regions\n  #\n  \n  lx.out(\"final \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n\n  model$regions$regions <- regions\n  \n  #-------------------------------\n  # sample\n  #-------------------------------\n  \n  lx.out(\"---------------------------------------\", with.mem=T)\n  lx.out(\"Sampling regions\")\n  lx.out(\"---------------------------------------\")\n\n  if (params$gcmodel.sample.gcbins <= 1) {\n    #\n    # standard sampling\n    #\n    sampled <- asdog.sample(basta, regions, size=params$gcmodel.sample.size,\n                            minspacin=params$gcmodel.sample.spacin,\n                            minreg=params$gcmodel.regions.minreg,\n                            sorted=TRUE,\n                            use.threads=use.threads)\n  }\n  else {\n    #\n    # sampling by gc regions\n    #\n    sampled <- asdog.sample.bygc(basta, regions,\n                                 size=params$gcmodel.sample.size,\n                                 gcwindow=params$gcmodel.sample.gcwindow,\n                                 gcbins=params$gcmodel.sample.gcbins,\n                                 minspacin=params$gcmodel.sample.spacin,\n                                 minreg=params$gcmodel.regions.minreg,\n                                 flatten=TRUE, sorted=TRUE,\n                                 use.threads=use.threads)\n  }\n\n  model$sample <- list()\n  model$sample$size <- length(sampled)\n  model$sample$coords <- sampled\n\n  # stop here on no sampling\n  #\n  lx.stopif(model$sample$size == 0, \"no sampled data\", trace=F)\n  \n  #-------------------------------\n  # winsize optimization\n  #-------------------------------\n  \n  # collect datasource for speedup\n  # \n  lx.out(\"loading rcgc datasource\", with.mem=T)\n  \n  datasrc <- asdog.rcgc.datasrc(basta, baf,\n                             chrs=chrs,\n                             smooth.k=params$gcmodel.datasrc.smooth,\n                             grain=params$gcmodel.datasrc.grain,\n                             use.threads=use.threads)\n  \n  # collect sample coverage\n  #\n  lx.out(\"collecting sample coverage\", with.mem=T)\n  \n  model$sample$pts <- asdog.rcgc.collect(datasrc, sampled,\n                                        winsize.gc=params$gccorrect.binsize,\n                                        winsize.cov=params$gccorrect.binsize,\n                                        use.threads=use.threads)\n                                        \n  # optimize gc windows\n  # \n  lx.out(\"optimizing windows\", with.mem=T)\n  \n  model$optim <- asdog.gcOptimize.gloess(datasrc, sampled,\n                         learn.ratio=params$gcmodel.learn.ratio,\n                         winrange.gc=list(params$gcmodel.small.winrange,\n                                          params$gcmodel.large.winrange),\n                         winsize.cov=params$gccorrect.binsize,\n                         fit=params$gcmodel.gloess.fit,\n                         objective=params$gcmodel.optim.objective,\n                         span=params$gcmodel.loess.span,\n                         base.quant=params$gcmodel.base.quant,\n                         base.trim=params$gcmodel.base.trim,\n                         nband=params$gcmodel.nband[2],\n                         use.threads=use.threads)\n  \n  #\n  # end\n  #\n  \n  basta.close(basta)\n  baf.close(baf)\n  \n  lx.out(\"---------------------------------------\", with.mem=T)\n  lx.out(\"End\")\n  lx.out(\"---------------------------------------\")\n  \n  lx.info(model)           <- 'GC GLoess correction model'\n  lx.info(model$params)    <- 'computation parameters'\n  lx.info(model$header)    <- 'chromosomes information'\n  lx.info(model$regions)   <- 'selected regions for GC model'\n  lx.info(model$sample)    <- 'sampled positions and values'\n  lx.info(model$optim)     <- 'optimized model'\n\n  model\n}\n\n# -------------------------------------------------\n# some S3 helper\n#\n\n# print overload\n\nprint.GCModel <- function(model) lx.doc(model, .name='GCModel')\n\n# plot overload\n# @todo\n\n",
    "created" : 1509375485508.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "723515969",
    "id" : "31A0A81D",
    "lastKnownWriteTime" : 1503054619,
    "last_content_update" : 1503054619,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.gcmodel.build.r",
    "project_path" : "R/asdog.gcmodel.build.r",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}