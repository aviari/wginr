{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: $\n# Asdog: Copy Number Analysis for WGS data\n#\n# GC loess or gam model\n#\n\n# =================================================\n# internals <no_export>\n# =================================================\n\n# -------------------------------------------------\n# select points in most populated GC band\n#\n.select.gc.band <- function(pts, nbins=10) {\n  scut <- cut(pts$gc, nbins, labels=1:nbins)\n  sidx <- which(scut == which.max(table(scut)))\n  list(ref.gc=mean(pts$gc[sidx]), range.gc=range(pts$gc[sidx]),\n       idx=sidx, pos=pts$pos[sidx])\n}\n\n# -------------------------------------------------\n# sample equally spaced points\n#\n.sample.spaced <- function(from, to, winsize, by=winsize) {\n  ok <- (to - from + 1) >= winsize\n  if (all(! ok)) return(integer(0))\n  unlist(mapply(function(f,t) seq.int(f+winsize/2, t-winsize/2-1, by=by),\n                from[ok], to[ok], SIMPLIFY=F))\n}\n\n# -------------------------------------------------\n# quicker aggregate using lx.condsum\n#\n.aggregate <- function(x, y, N=1000) {\n  res <- lx.condsum(round(x*N), round(y*N))\n  res[,2] <- res[,3]/res[,2]/N\n  res <- as.data.frame(res[,1:2])\n  names(res) <- c(\"gc\", \"cov\")\n  res\n}\n\n# -------------------------------------------------\n# initialize gloess model\n#\n.gloess.init <- function(pts, name=\"\", fit=\"none\", N=1000, span=0.75,\n                         base.quant=0.01, base.trim=c(0.2, 0.8)) {\n  mod <- list()\n  mod$name <- name\n  mod$span <- span\n  mod$fit  <- fit\n  mod$N    <- N\n  mod$base.quant <- base.quant\n  mod$base.trim  <- base.trim\n  mod$cov  <- pts$cov\n  mod$mcov <- median(mod$cov, na.rm=T)\n  mod$gc   <- pts$gc\n  #\n  # -- slower version but uses median\n  # mod$mean <- aggregate(mod$cov, by=list(gc=round(mod$gc*N)), median)\n  # names(mod$mean) <- c(\"gc\", \"cov\")\n  #\n  mod$mean <- .aggregate(mod$gc, mod$cov, N=N)\n  mod\n}\n\n# -------------------------------------------------\n# make constant gloess model\n#\n.gloess.constant <- function(pts, name=\"Constant\", N=1000) {\n  \n  mod <- .gloess.init(pts, name, N=N, span=NA, base.quant=NA, base.trim=NULL)\n\n  mod$pvec <- rep(mod$mcov, N+1)\n\n  mod\n}\n\n# -------------------------------------------------\n# make standard gloess model\n#\n.gloess.model <- function(pts, name=\"\", N=1000, fit=\"gam\", span=0.75, \n                          base.quant=0.01, base.trim=c(0.2, 0.8)) {\n  \n  mod <- .gloess.init(pts, name, fit=fit, N=N, span=span,\n                      base.quant=base.quant, base.trim=base.trim)\n  \n  # baseline adjustment\n  #\n  baseline <- if (is.na(base.quant) || (base.quant <= 0)) 1 \n              else quantile(mod$cov, base.quant, na.rm=T)\n  cov <- c(baseline, baseline, mod$mean$cov)\n  gc  <- c(0, N, mod$mean$gc)\n  \n  # make gloess model\n  #\n  mod$gloess <- switch(fit,\n                       gam=gam(cov ~ s(gc)),\n                       loess(cov ~ gc, span=span,\n                             control=loess.control(surface=\"direct\"))\n                )\n\n  # prediction vector \n  #\n  mod$pvec <- switch(fit,\n                     gam=predict(mod$gloess, list(gc=seq.int(0, N))),\n                     predict(mod$gloess, seq.int(0, N))\n              )\n  mod$pvec[mod$pvec <= baseline] <- baseline\n  \n  # trim low and high gc\n  #\n  if (! is.null(base.trim)) {\n    bnds <- round(base.trim*N)\n    mod$pvec[1:bnds[1]] <- mod$pvec[bnds[1]]\n    mod$pvec[bnds[2]:length(mod$pvec)] <- mod$pvec[bnds[2]]\n  }\n  \n  # remove outliers (may occur if span is too small)\n  #\n  outl <- 5*median(mod$pvec, na.rm=T)\n  mod$pvec[mod$pvec >= outl] <- outl\n  \n  mod\n}\n\n# -------------------------------------------------\n# gloess model predictor\n#\n.gloess.predict <- function(mod, gc) mod$pvec[round(gc*mod$N)+1]\n\n\n# -------------------------------------------------\n# init GC model\n#\n.model.init <- function(nmodel, winsize.gc=0, winsize.cov=NA,\n                        fit=\"none\", span=NA, base.quant=NA, base.trim=NULL,\n                        nband=NA) {\n\n  model <- asdog.object(\"GCGloessModel\")\n  model$nmodel      <- nmodel\n  model$winsize.gc  <- winsize.gc\n  model$winsize.cov <- winsize.cov\n  model$fit         <- fit\n  model$span        <- span\n  model$base.quant  <- base.quant\n  model$base.trim   <- base.trim\n  model$nband       <- nband\n  model$gloess      <- vector(\"list\", nmodel)\n  \n  model\n}\n\n# -------------------------------------------------\n# constant GC model\n#\n.model.constant <- function(datasrc, clocations, \n                            winsize.cov=1000L,\n                            use.threads=lx.use.threads()) {\n  \n  lx.out(\"making model Constant\")\n  \n  model <- .model.init(nmodel=1, winsize.cov=winsize.cov)\n  \n  pts <- asdog.rcgc.collect(datasrc, clocations,\n                           winsize.gc=winsize.cov,\n                           winsize.cov=winsize.cov,\n                           use.threads=use.threads)\n  \n  gloess <- .gloess.constant(pts, \"Constant\")\n\n  gloess$winsize.gc  <- winsize.cov\n  gloess$winsize.cov <- winsize.cov\n  \n  pts$pred <- rep(gloess$mcov, length(pts$pos))\n  \n  model$pts <- pts\n  \n  model$alpha <- 1\n  \n  model$gloess[[1]] <- gloess\n  \n  model\n}\n\n# -------------------------------------------------\n# gloess GC model with single window\n#\n.model.single <- function(datasrc, clocations, \n                          winsize.gc=1000L, \n                          winsize.cov=1000L,\n                          fit=\"gam\",\n                          span=0.75,\n                          base.quant=0.01, base.trim=c(0.2, 0.8),\n                          use.threads=lx.use.threads()) {\n  \n  lx.out(\"making model Single W=\", winsize.gc)\n  \n  model <- .model.init(nmodel=1, winsize.gc=winsize.gc,\n                       winsize.cov=winsize.cov, fit=fit, span=span,\n                       base.quant=base.quant, base.trim=base.trim)\n  \n  pts <- asdog.rcgc.collect(datasrc, clocations,\n                           winsize.gc, winsize.cov,\n                           use.threads=use.threads)\n  \n  gloess <- .gloess.model(pts, \"Single\", fit=fit,\n                          span=span[1],\n                          base.quant=base.quant, \n                          base.trim=base.trim)\n  \n  gloess$winsize.gc  <- winsize.gc\n  gloess$winsize.cov <- winsize.cov\n  \n  pts$pred <- .gloess.predict(gloess, pts$gc)\n  \n  model$pts <- pts\n  \n  model$alpha <- median(pts$cov/pts$pred, na.rm=T)\n  \n  model$gloess[[1]] <- gloess\n  \n  model\n}\n\n# -------------------------------------------------\n# gloess GC model with two windows\n#\n.model.twin <- function(datasrc, clocations,\n                        winsize.gc=c(1000L, 100000L), \n                        winsize.cov=c(1000L, 1000L),\n                        fit=\"gam\",\n                        span=0.75,\n                        base.quant=0.01, base.trim=c(0.2,0.8),\n                        nband=c(4L, 10L),\n                        use.threads=lx.use.threads()) {\n  \n  model <- .model.init(nmodel=2, winsize.gc=winsize.gc,\n                       winsize.cov=winsize.cov, fit=fit, span=span,\n                       base.quant=base.quant, base.trim=base.trim,\n                       nband=nband)\n  \n  # -- Large window\n  # remove small window effect in large window model\n  #\n  lx.out(\"making model Large W=\", winsize.gc[2])\n  \n  lpts.full <- asdog.rcgc.collect(datasrc, clocations,\n                                 winsize.gc[2], winsize.cov[2],\n                                 use.threads=use.threads)\n  \n  # subsample large windows (we shall oversample later on) \n  #\n  nb.sub <- length(.sample.spaced(-winsize.gc[2]/2, winsize.gc[2]/2,\n                                  winsize.gc[1], winsize.gc[1]))\n  idx.sub <- seq.int(1, length(lpts.full$pos), by=nb.sub)\n  lpts <- lpts.full\n  lpts$pos <- lpts.full$pos[idx.sub]\n  lpts$gc  <- lpts.full$gc[idx.sub]\n  \n  # oversample small windows in large window\n  #\n  samp.ovr <- .sample.spaced(lpts$pos-winsize.gc[2]/2,\n                             lpts$pos+winsize.gc[2]/2,\n                             winsize.gc[1], winsize.gc[1])\n  \n  lpts.ovr <- asdog.rcgc.collect(datasrc, samp.ovr,\n                                winsize.gc[1], winsize.cov[1],\n                                use.threads=use.threads)\n  \n  cov.mat <- matrix(lpts.ovr$cov, ncol=nb.sub, byrow=T)\n  \n  # collect small windows within GC bandwidth\n  # (and increase bandwidth if necessary)\n  #\n  nna.frac  <- 0\n  nband.min <- min(nband)\n  nband     <- max(nband)\n  while ((nna.frac < 0.5) && (nband >= nband.min)) {\n    band <- .select.gc.band(lpts.full, nbins=nband)\n    cut.mat <- matrix(cut(lpts.ovr$gc, band$range.gc, label=F), ncol=nb.sub, byrow=T)\n    lpts$cov  <- rowMeans(cut.mat * cov.mat, na.rm=T)\n    nna.frac <- sum(!is.na(lpts$cov))/length(lpts$cov)\n    lx.out(\"nband=\", nband, \" bandwidth=\", format(band$range.gc, digits=3), \n           \" frac=\", format(nna.frac, digits=3), level=\"debug\")\n    if (nna.frac < 0.5) nband <- nband - 1\n  }\n  \n  # maybe we prefer to remove NaN\n  if (FALSE) {\n    na.cov <- is.na(lpts$cov)\n    lpts$cov[na.cov] <- mean(lpts$cov[! na.cov])\n    lpts$gc[na.cov]  <- mean(lpts$gc[! na.cov])\n  }\n  \n  gloess <- .gloess.model(lpts, \"Large\", fit=fit,\n                          span=span[2],\n                          base.quant=base.quant,\n                          base.trim=base.trim)\n  \n  gloess$winsize.gc  <- winsize.gc[2]\n  gloess$winsize.cov <- winsize.cov[2]\n  model$gloess[[2]] <- gloess\n  \n  model$band  <- band\n  \n  # -- Small window\n  # remove large window effect in small window model\n  #\n  lx.out(\"making model Small W=\", winsize.gc[1])\n  \n  # resample small window within large windows in GC band\n  #\n  samp.swin <- .sample.spaced(band$pos-winsize.gc[2]/2, band$pos+winsize.gc[2]/2,\n                              winsize.gc[1], winsize.gc[1])\n  step.swin <- floor(length(samp.swin)/nrow(clocations))\n  if (step.swin > 1)\n    samp.swin <-samp.swin[seq.int(1, length(samp.swin), by=step.swin)]\n  \n  spts  <- asdog.rcgc.collect(datasrc, samp.swin,\n                             winsize.gc[1], winsize.cov[1],\n                             use.threads=use.threads)\n  \n  gloess <- .gloess.model(spts, \"Small\", fit=fit,\n                          span=span[1],\n                          base.quant=base.quant,\n                          base.trim=base.trim)\n  \n  gloess$winsize.gc  <- winsize.gc[1]\n  gloess$winsize.cov <- winsize.cov[1]\n  \n  model$gloess[[1]] <- gloess\n  \n  # compute model$alpha\n  \n  model$alpha <- 1\n  \n  pred <- asdog.gcPredict.gloess(datasrc, model, clocations,\n                                 use.threads=use.threads)\n  \n  model$alpha <- median(lpts.full$cov/pred$cov, na.rm=T)\n\n  model\n}\n\n# =================================================\n# API\n# =================================================\n\n# -------------------------------------------------\n# gloess GC model (with one or two windows)\n#\nasdog.gcModel.gloess <- function(datasrc, locs, \n                                 winsize.gc=c(1000L, 100000L), \n                                 winsize.cov=1000L,\n                                 fit=c(\"gam\", \"loess\"),\n                                 span=0.75,\n                                 base.quant=0.01, base.trim=c(0.2,0.8),\n                                 nband=c(4L, 10L),\n                                 use.threads=lx.use.threads()) {\n  \n  fit <- match.arg(fit)\n  \n  clocations <- if (is.null(dim(locs))) coords2clocs(datasrc, locs)\n                else locs\n  \n  nmodel      <- length(winsize.gc)\n  winorder    <- order(winsize.gc)\n  winsize.gc  <- head(winsize.gc[winorder], 2)\n  winsize.cov <- lx.recycle(winsize.cov, nmodel)[winorder]\n  span        <- lx.recycle(span, nmodel)[winorder]\n\n  # -----------------------------------------\n  # single window model\n  # -----------------------------------------\n\n  if (nmodel == 1) {\n    model <- if (winsize.gc[1] <= 0)\n                .model.constant(datasrc, clocations,\n                                winsize.cov=winsize.cov[1],\n                                use.threads=use.threads)\n             else \n                .model.single(datasrc, clocations,\n                              winsize.gc=winsize.gc[1],\n                              winsize.cov=winsize.cov[1],\n                              fit=fit,\n                              span=span,\n                              base.quant=base.quant,\n                              base.trim=base.trim,\n                              use.threads=use.threads)\n    return(model)\n  }\n\n  # -----------------------------------------\n  # two windows model with at least one of width <= 0\n  # => recurse to single window\n  # -----------------------------------------\n  \n  if (min(winsize.gc) <= 0) {\n    model <- asdog.gcModel.gloess(datasrc, clocations,\n                                  winsize.gc=max(winsize.gc),\n                                  winsize.cov=winsize.cov[which.max(winsize.gc)],\n                                  fit=fit,\n                                  span=span,\n                                  base.quant=base.quant,\n                                  base.trim=base.trim,\n                                  use.threads=use.threads)\n    return(model)\n  }\n  \n  # -----------------------------------------\n  # two windows model\n  # -----------------------------------------\n\n  model <- .model.twin(datasrc, clocations,\n                       winsize.gc=winsize.gc,\n                       winsize.cov=winsize.cov,\n                       fit=fit,\n                       span=span,\n                       base.quant=base.quant,\n                       base.trim=base.trim,\n                       nband=c(min(nband), max(nband)),\n                       use.threads=use.threads)\n  \n  return(model)\n}\n\n# -------------------------------------------------\n# GC gloess model predict\n#\nasdog.gcPredict.gloess <- function(datasrc, model, locs,\n                                   use.threads=lx.use.threads()) {\n  \n  clocations <- if (is.null(dim(locs))) coords2clocs(datasrc, locs) else locs\n  \n  pts <- lapply(model$gloess, function(gloess)\n              asdog.rcgc.collect(datasrc, clocations, \n                                gloess$winsize.gc, 0L,\n                                use.threads=use.threads))\n  \n  pred <- .gloess.predict(model$gloess[[1]], pts[[1]]$gc)\n  \n  if (model$nmodel > 1) {\n    pred <- pred +\n            .gloess.predict(model$gloess[[2]], pts[[2]]$gc) -\n            .gloess.predict(model$gloess[[2]], model$band$ref.gc)\n  }\n  \n  list(gcs=pts[[1]]$gc, gcl=pts[[model$nmodel]]$gc, cov=pred*model$alpha)\n}\n\n# -------------------------------------------------\n# gloess GC model optimization\n#\n# note: next two functions should be global\n#       because of using lx.get0 backport for R < 3.2.0 :-(\n#\nasdog.gloess.objective.pearson <- function(cov, pred, gc) {\n    abs(cor(cov/pred, gc, method=\"pearson\"))\n}\n\nasdog.gloess.objective.gam.rsq <- function(cov, pred, gc, N=1000) {\n  abs(summary(gam(lx.decimate(cov/pred, N) ~ s(lx.decimate(gc, N))))$r.sq)\n}\n\nasdog.gcOptimize.gloess <- function(datasrc, coords,\n                                learn.ratio=0.1,\n                                winrange.gc=list(c(0L, 2000L, 100L),\n                                                 c(0L, 200000L, 50000L)),\n                                winsize.cov=1000L,\n                                fit=c(\"gam\", \"loess\"),\n                                objective=c(\"gam.rsq\", \"pearson\"),\n                                span=0.75,\n                                base.quant=0.01,\n                                base.trim=NULL,\n                                nband=c(4L, 10L),\n                                use.threads=lx.use.threads()) {\n  \n  fit <- match.arg(fit)\n  objective <- match.arg(objective)\n  objective.fun <- lx.get0(paste0(\"asdog.gloess.objective.\", objective), mode=\"function\")\n  \n  # remove outliers\n  #\n  pts <- asdog.rcgc.collect(datasrc, coords,\n                           winsize.gc=0,\n                           winsize.cov=winsize.cov,\n                           use.threads=use.threads)\n  \n  coords <- coords[pts$cov <= 2 * median(pts$cov, na.rm=T)]\n\n  # separate learn and test sets  \n  #\n  ntot <- length(coords)\n  coords.learn <- coords[seq.int(1, ntot, length.out=round(ntot*learn.ratio))]\n  coords.test  <- sort(setdiff(coords, coords.learn))\n  \n  clocs.learn <- coords2clocs(datasrc, coords.learn)\n  clocs.test  <- coords2clocs(datasrc, coords.test)\n  \n  pts.test <- asdog.rcgc.collect(datasrc, clocs.test,\n                                winsize.gc=winsize.cov, # this is ok\n                                winsize.cov=winsize.cov,\n                                use.threads=use.threads)\n  \n  # search for best windows\n  #\n  .range <- function(rng) seq.int(rng[1], rng[2], by=rng[3])\n  swins <- .range(winrange.gc[[1]])\n  lwins <- .range(winrange.gc[[2]])\n  \n  scores <- sapply(lwins, function(lwin) {\n    sapply(swins, function(swin) {\n      mod <- asdog.gcModel.gloess(datasrc, clocs.learn,\n                                  winsize.gc=c(swin, lwin),\n                                  winsize.cov=winsize.cov,\n                                  fit=fit,\n                                  span=span,\n                                  nband=nband,\n                                  base.quant=base.quant,\n                                  base.trim=base.trim,\n                                  use.threads=use.threads)\n      pred <- asdog.gcPredict.gloess(datasrc, mod, clocs.test,\n                                    use.threads=use.threads)\n\n      objective.fun(pts.test$cov, pred$cov, pts.test$gc)\n\n    })\n  })\n    \n  colnames(scores) <- lwins\n  rownames(scores) <- swins\n\n  # retrieve best model\n  #\n  scores.min <- which(scores==min(scores),arr.ind=T)\n  best.swin <- swins[scores.min[[1]]]\n  best.lwin <- lwins[scores.min[[2]]]\n  \n  best.mod <- asdog.gcModel.gloess(datasrc, clocs.learn,\n                                   winsize.gc=c(best.swin, best.lwin),\n                                   winsize.cov=winsize.cov,\n                                   fit=fit,\n                                   span=span,\n                                   nband=nband,\n                                   base.quant=base.quant,\n                                   base.trim=base.trim,\n                                   use.threads=use.threads)\n  \n  pred <- asdog.gcPredict.gloess(datasrc, best.mod, clocs.test,\n                                use.threads=use.threads)\n\n  pred <- list(pos=pts.test$pos, \n               gc=pts.test$gc, \n               cov=pts.test$cov,\n               pred=pred$cov)\n  \n  info <- list(fit=fit, objective=objective)\n  \n  list(scores=scores, model=best.mod, test=pred, info=info)\n}\n\n# -------------------------------------------------\n# S3 method to plot GCGloess model\n#\nplot.GCGloessModel <- function(model, xlim=c(0.2,0.8), ylim=c(0,2), ...) {\n  \n  # setup\n  opar <- par(no.readonly=T)\n  par(mfrow=c(1, model$nmodel),\n      cex.main=0.9)\n  \n  # model\n  sapply(model$gloess, function(mod) {\n    lx.plot(mod$gc, mod$cov/mod$mcov,\n            xlim=xlim,\n            ylim=ylim,\n            xlab=\"%GC\", ylab=\"rel. cov.\",\n            main=paste0(mod$name, \" W=\", mod$winsize.gc), ...)\n    points(mod$mean$gc/mod$N, mod$mean$cov/mod$mcov, pch=19, cex=0.3, col=4)\n    lines(seq.int(0, 1, 1/mod$N), mod$pvec/mod$mcov, col=2, lwd=3)\n    abline(h=1, col=3)\n    if (is.null(model$band$range.gc))\n      abline(v=mean(mod$gc), col=3)\n    else {\n      py <- par(\"usr\")[3:4]\n      rect(model$band$range.gc[1], py[1], model$band$range.gc[2], py[2],\n           col=lx.color.alpha(lx.BLUE, 0.3), border=NA)\n      abline(v=model$band$ref.gc, col=3)\n    }\n  })\n  \n  # restore\n  par(opar)\n  \n  invisible()\n}\n\n\n",
    "created" : 1511545039883.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2740027466",
    "id" : "469BD09",
    "lastKnownWriteTime" : 1511550393,
    "last_content_update" : 1511550393986,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.gcmodel.gloess.r",
    "project_path" : "R/asdog.gcmodel.gloess.r",
    "properties" : {
    },
    "relative_order" : 16,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}