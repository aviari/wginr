{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: asdog.params.r 286 2017-07-25 12:03:15Z viari $\n# Asdog: Copy Number Analysis for WGS data\n#\n# asdog default parameters\n#\n\n# -------------------------------------------------\n# default parameters\n#\n# note: seed, verbose, use.threads and mc.cores\n#       are handled directly from args (in function 'asdog.main.args')\n#\n\nasdog.default.params <- function() {\n\n  .def <- function(category, info, type, value, required=FALSE) {\n    list(category=category, info=info, type=type,\n         value=value, required=required)\n  }\n  \n  def <- list()\n  class(def) <- c('ParamDefs', class(def))\n\n  # -------------------------------------------------\n  # general parameters\n  # -------------------------------------------------\n\n  def$base        <- .def(\"gccorrect:cnpredict:popmap:matchpair: general\",\n                          \"pathname of BAF file (without extension)\",\n                          \"character\",\n                          \"none\", TRUE)\n\n  def$ref         <- .def(\"gccorrect: general\",\n                          \"pathname of reference (BASTA) file (without extension)\",\n                          \"character\",\n                          \"none\", TRUE)\n\n  def$normal      <- .def(\"cnpredict: general\",\n                          \"pathname of normal BAF file (without extension)\",\n                          \"character\",\n                          \"none\", TRUE)\n  \n  def$ref.snp     <- .def(\"popmap:matchpair: general\",\n                          \"pathname of reference SNPs file (default to internal)\",\n                          \"character\",\n                          \"sys:asdog:data/HapMap.hg19.snp.100K.rds\")\n\n  def$match      <- .def(\"matchpair: general\",\n                         \"pathname of matched BAF file (without extension)\",\n                         \"character\",\n                         \"none\", TRUE)\n\n  def$outdir     <- .def(\"gccorrect:cnpredict: general\",\n                         \"output directory\",\n                         \"character\",\n                         \".\")\n  \n  def$chrs       <- .def(\"gccorrect:cnpredict:segment:popmap:matchpair: general\",\n                         \"list of chromosomes indexes to consider (empty means all)\",\n                         \"vector-of-integer\",\n                         1L:22L)\n\n  def$seed        <- .def(\"gccorrect:cnpredict:popmap:matchpair: general\",\n                          \"random seed (use < 0 for no seed)\",\n                          \"integer\",\n                          0L)\n\n  def$verbose     <- .def(\"*: general\",\n                          \"verbosity level (one of 'debug', 'info', 'warning', 'error')\",\n                          \"character\",\n                          \"info\")\n\n  def$use.threads <- .def(\"*: general\",\n                          \"use threads\",\n                          \"logical\",\n                          TRUE)\n\n  def$mc.cores    <- .def(\"*: general\",\n                          \"nb cores to use (use 0 for maximum cores available)\",\n                          \"integer\",\n                          0L)\n  \n  # -------------------------------------------------\n  # parameters for gcmodel regions selection\n  # -------------------------------------------------\n    \n  def$gcmodel.regions.name    <- .def(\"gccorrect: regions_selection\",\n                                      \"name of user's regions bed file\",\n                                      \"character\",\n                                      \"@REF@.mappable.bed\")\n\n  def$gcmodel.regions.minreg  <- .def(\"gccorrect: regions_selection\",\n                                      \"minimum size of regions in bp\",\n                                      \"integer\",\n                                      10000L)\n\n  def$gcmodel.regions.binsize <- .def(\"gccorrect: regions_selection\",\n                                      \"size for binning regions coverage\",\n                                      \"integer\",\n                                      10000L)\n  \n  def$gcmodel.regions.joinsize <- .def(\"gccorrect: regions_selection\",\n                                      \"min and max join size for large windows\",\n                                      \"vector-of-integer\",\n                                      c(1000L, 1e6L))\n  \n  def$gcmodel.regions.smooth <- .def(\"gccorrect: regions_selection\",\n                                      \"median smoothing parameters\",\n                                      \"vector-of-integer\",\n                                      c(3L, 5L, 15L, 35L, 55L))\n\n  def$gcmodel.regions.band <- .def(\"gccorrect: regions_selection\",\n                                    \"coverage band selection model\",\n                                    \"character\",\n                                    \"1 * poisson\")\n  \n  def$gcmodel.regions.plot.alpha <- .def(\"gccorrect:report: regions_selection\",\n                                         \"region display extension alpha factor\",\n                                         \"double\",\n                                         5)\n  \n  # -------------------------------------------------\n  # parameters for gcmodel sampling\n  # -------------------------------------------------\n  \n  def$gcmodel.sample.size    <- .def(\"gccorrect: sampling\",\n                                       \"sample size\",\n                                       \"integer\",\n                                       1000000L)\n\n  def$gcmodel.sample.spacin  <- .def(\"gccorrect: sampling\",\n                                       \"minimum distance between samples\",\n                                       \"integer\",\n                                       0L)\n\n  def$gcmodel.sample.gcbins  <- .def(\"gccorrect: sampling\",\n                                       \"number of gc bins (use 0 to disable gc sampling, typical value 4)\",\n                                       \"integer\",\n                                       0L)\n  \n  def$gcmodel.sample.gcwindow  <- .def(\"gccorrect: sampling\",\n                                         \"gc sampling window size in bp (only if gcbins != 0)\",\n                                         \"integer\",\n                                         1000L)\n\n  # -------------------------------------------------\n  # parameters for gam-loess gcmodel\n  # -------------------------------------------------\n\n  def$gcmodel.datasrc.grain      <- .def(\"gccorrect: data source\",\n                                         \"datasource grain (in bp)\",\n                                         \"integer\",\n                                         100L)\n  \n  def$gcmodel.datasrc.smooth     <- .def(\"gccorrect: data source\",\n                                         \"datasource median smoothing (use 0 to disable smoothing)\",\n                                         \"vector-of-integer\",\n                                         c(3L, 5L, 15L))\n\n  def$gcmodel.small.winrange     <- .def(\"gccorrect: gc_window_optimization\",\n                                         \"gc small window minimum, maximum size and step in bp\",\n                                         \"vector-of-integer\",\n                                         c(0L, 2500L, 500L))\n\n  def$gcmodel.large.winrange     <- .def(\"gccorrect: gc_window_optimization\",\n                                         \"gc large window minimum, maximum size and step in bp\",\n                                         \"vector-of-integer\",\n                                         c(0L, 250000L, 50000L))\n\n  def$gcmodel.learn.ratio       <- .def(\"gccorrect: gc_window_optimization\",\n                                         \"learn/test size ratio\",\n                                         \"double\",\n                                         0.1)\n\n  def$gcmodel.gloess.fit        <- .def(\"gccorrect: model definition\",\n                                        \"fit function: gam or loess\",\n                                        \"character\",\n                                        \"gam\")\n  \n  def$gcmodel.loess.span        <- .def(\"gccorrect: model definition\",\n                                         \"loess span parameters\",\n                                         \"vector-of-double\",\n                                         c(0.75, 0.75))\n  \n  def$gcmodel.base.quant         <- .def(\"gccorrect: model definition\",\n                                         \"baseline quantile (use 0 to disable)\",\n                                         \"double\",\n                                         0.01)\n  \n  def$gcmodel.base.trim          <- .def(\"gccorrect: model definition\",\n                                         \"baseline trimming (use NULL to disable)\",\n                                         \"vector-of-double\",\n                                         c(0.2, 0.8))\n  \n  def$gcmodel.nband              <- .def(\"gccorrect: model definition\",\n                                         \"min and max number of gc bands\",\n                                         \"vector-of-integer\",\n                                         c(4L, 10L))\n  \n  def$gcmodel.optim.objective    <- .def(\"gccorrect: model optimization\",\n                                         \"objective function (one of gam.rsq, pearson)\",\n                                         \"character\",\n                                         \"gam.rsq\")\n  \n  # -------------------------------------------------\n  # parameters for gc correction\n  # -------------------------------------------------\n  \n  def$gccorrect.regions    <- .def(\"gccorrect: gc correction\",\n                                   \"regions to predict\",\n                                   \"character\",\n                                   \"@REF@.mappable.bed\")\n\n  def$gccorrect.binsize    <- .def(\"gccorrect: gc correction\",\n                                   \"binsize in bp\",\n                                   \"integer\",\n                                   1000L)\n\n  def$gccorrect.collect    <- .def(\"gccorrect: gc correction\",\n                                   \"collect function (mean or median)\",\n                                   \"character\",\n                                   \"median\")\n  \n  def$gccorrect.plot.rcmax  <- .def(\"gccorrect:report: gc correction\",\n                                    \"rrc plot max value (use 0 to disable)\",\n                                    \"double\",\n                                    4)\n\n  def$gccorrect.plot.smooth <- .def(\"gccorrect:report: gc correction\",\n                                    \"rrc plot median smoothing parameters\",\n                                    \"vector-of-integer\",\n                                    c(3L, 5L, 15L, 35L, 55L))\n  \n  def$gccorrect.plot.nbpts  <- .def(\"gccorrect:report: gc correction\",\n                                    \"number of plot points\",\n                                    \"integer\",\n                                    5000L)\n  \n  def$gccorrect.plot.cex   <- .def(\"gccorrect:report: gc correction\",\n                                   \"rrc plot point size\",\n                                   \"double\",\n                                   0.1)\n  \n  # -------------------------------------------------\n  # parameters for popmap, matchpair\n  # -------------------------------------------------\n  \n  def$snp.pop.low     <- .def(\"popmap:matchpair: snp selection\",\n                              \"population alt/ref allele frequency lower threshold\",\n                              \"double\",\n                              0.01)\n\n  def$snp.lowread   <- .def(\"popmap:matchpair: snp selection\",\n                            \"maximum number of reads to be considered as 0\",\n                            \"integer\",\n                            2L)\n  \n  def$snp.mincov     <- .def(\"popmap:matchpair: snp selection\",\n                             \"minimum coverage (use negative value for quantile/1000)\",\n                             \"integer\",\n                             10L)\n\n  def$snp.deltafreq  <- .def(\"popmap: snp selection\",\n                             \"maximum delta allelic frequency around 0.5\",\n                             \"double\",\n                             0.3)\n\n  def$snp.sample.size <- .def(\"popmap:matchpair: snp selection\",\n                              \"initial SNPs sample size (use 0 to keep all SNPs)\",\n                              \"integer\",\n                              10000L)\n\n  def$snp.match.nbest <- .def(\"matchpair: snp selection\",\n                              \"number of most segregating SNPs\",\n                              \"integer\",\n                              200L)\n\n  def$snp.match.refpop <- .def(\"matchpair: snp selection\",\n                              \"reference population ('AF', 'EUR', 'AMR', 'AFR', 'EAS', 'SAS')\",\n                              \"character\",\n                              \"AF\")\n  \n  # -------------------------------------------------\n  # parameters for ploidy model\n  # -------------------------------------------------\n\n  def$plmodel.regions <- .def(\"cnpredict: ploidy model\",\n                              \"user's regions (set to NULL to ignore)\",\n                              \"character\",\n                              \"@REF@.mappable.bed\")\n  \n  def$plmodel.snp.lowread <- .def(\"cnpredict: ploidy model\",\n                                  \"maximum number of reads to be considered as 0\",\n                                  \"integer\",\n                                  2L)\n\n  def$plmodel.snp.mincov  <- .def(\"cnpredict: ploidy model\",\n                                  \"minimum coverage (use negative value for quantile/1000)\",\n                                  \"integer\",\n                                  10L)\n  \n  def$plmodel.snp.dfreq   <- .def(\"cnpredict: ploidy model\",\n                                  \"maximum delta allelic frequency around 0.5\",\n                                  \"double\",\n                                  0.1)\n\n  # pre-segmentation : general\n  \n  def$plmodel.preseg.mode <- .def(\"cnpredict: ploidy model\",\n                                  \"pre-segmentation mode (shmm or bcp)\",\n                                  \"character\",\n                                  \"bcp\")\n  \n  def$plmodel.preseg.rcmax <- .def(\"cnpredict:shmm: ploidy model\",\n                                   \"pre-segmentation maximum rrc\",\n                                   \"double\",\n                                   4)\n  \n  def$plmodel.preseg.sampsize <- .def(\"cnpredict:shmm: ploidy model\",\n                                      \"pre-segmentation rc and af downsampling (0 to disable)\",\n                                      \"integer\",\n                                      1e5L)\n  \n  def$plmodel.preseg.segsize  <- .def(\"cnpredict:shmm: ploidy model\",\n                                      \"rc and af minimum seg size in Mb for smooth.hmm\",\n                                      \"integer\",\n                                      10L)\n  \n  # pre-segmentation : smooth hmm\n  \n  def$plmodel.shmm.rc.raw  <- .def(\"cnpredict:shmm: ploidy model\",\n                                   \"use raw (TRUE) or smooth (FALSE) rrc for smooth.hmm\",\n                                   \"logical\",\n                                   TRUE)\n\n  def$plmodel.shmm.rc.smooth <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"rrc smoothing parameters for smooth.hmm\",\n                                     \"vector-of-integer\",\n                                     c(3L, 5L, 15L, 35L, 55L, 105L))\n\n  def$plmodel.shmm.rc.eps    <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"rrc maxima eps value for smooth.hmm\",\n                                     \"double\",\n                                     0.1)\n\n  def$plmodel.shmm.rc.maxlev <- .def(\"cnpredict:shmm: ploidy model\",\n                                    \"maximum number of rrc levels for smooth.hmm\",\n                                    \"integer\",\n                                    10L)\n  \n  def$plmodel.shmm.rc.tau    <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"rrc smooth.hmm transition probability\",\n                                     \"double\",\n                                     1e-50)\n\n  def$plmodel.shmm.af.raw  <- .def(\"cnpredict:shmm: ploidy model\",\n                                   \"use raw (TRUE) or smooth (FALSE) af for smooth.hmm\",\n                                   \"logical\",\n                                   FALSE)\n  \n  def$plmodel.shmm.af.smooth <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"af smoothing parameters for smooth.hmm\",\n                                     \"vector-of-integer\",\n                                     c(3L, 5L, 15L, 35L, 55L, 105L))\n  \n  def$plmodel.shmm.af.eps    <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"af maxima eps value for smooth.hmm\",\n                                     \"double\",\n                                     0.1)\n  \n  def$plmodel.shmm.af.maxlev <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"maximum number of af levels for smooth.hmm\",\n                                     \"integer\",\n                                     10L)\n  \n  def$plmodel.shmm.af.tau    <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"af smooth.hmm transition probability\",\n                                     \"double\",\n                                     1e-50)\n  \n  def$plmodel.shmm.sampsize <- .def(\"cnpredict:shmm: ploidy model\",\n                                     \"rc and af smooth.hmm downsampling (0 to disable)\",\n                                     \"integer\",\n                                     1e5L)\n  \n  def$plmodel.shmm.segsize  <- .def(\"cnpredict:shmm: ploidy model\",\n                                    \"rc and af minimum seg size in Mb for smooth.hmm\",\n                                    \"integer\",\n                                    10L)\n  \n  # pre-segmentation : bcp\n  \n  def$plmodel.bcp.rc.smooth <- .def(\"cnpredict:bcp: ploidy model\",\n                                     \"rrc smoothing parameters for bcp\",\n                                     \"vector-of-integer\",\n                                     NULL)\n  \n  def$plmodel.bcp.af.smooth <- .def(\"cnpredict:bcp: ploidy model\",\n                                    \"baf smoothing parameters for bcp\",\n                                    \"vector-of-integer\",\n                                    NULL)\n\n  def$plmodel.bcp.p0 <- .def(\"cnpredict:bcp: ploidy model\",\n                             \"bcp p0 parameter\",\n                             \"double\",\n                             1e-50)\n  \n  # ploidy fit\n\n  def$plmodel.fit.weightquant  <- .def(\"cnpredict: ploidy model\",\n                                    \"minimum weight quantile for fit (0 to disable)\",\n                                    \"double\",\n                                    0.25)\n  \n  def$plmodel.fit.segsrc    <- .def(\"cnpredict: ploidy model\",\n                              \"segment source for fit (mean|hmm.rc|af)\",\n                              \"vector-of-character\",\n                              c(\"mean.rc\", \"mean.af\"))\n\n  def$plmodel.fit.arange  <- .def(\"cnpredict: ploidy model\",\n                                    \"plmodel fit alpha range and step\",\n                                    \"vector-of-double\",\n                                    c(0, 1, 0.05))\n  \n  def$plmodel.fit.qrange  <- .def(\"cnpredict: ploidy model\",\n                                  \"plmodel fit Q range and step\",\n                                  \"vector-of-double\",\n                                  c(1, 8, 0.05))\n\n  def$plmodel.fit.thweight  <- .def(\"cnpredict: ploidy model\",\n                                  \"plmodel fit use theo weights\",\n                                  \"logical\",\n                                  FALSE)\n  \n  def$plmodel.fit.gamma     <- .def(\"cnpredict: ploidy model\",\n                                    \"plmodel fit gamma penalty\",\n                                    \"double\",\n                                    1)\n\n  def$plmodel.fit.rho      <- .def(\"cnpredict: ploidy model\",\n                                    \"plmodel fit score ratio power\",\n                                    \"double\",\n                                    0.5)\n\n  def$plmodel.alpha.normal <- .def(\"cnpredict: ploidy model\",\n                                   \"max alpha tolerated for a tumour\",\n                                   \"double\",\n                                   0.95)\n\n  def$plmodel.plot.rcmax   <- .def(\"cnpredict:report: ploidy model\",\n                                    \"rrc plot max value (use 0 to disable)\",\n                                    \"double\",\n                                    4)\n\n  # -------------------------------------------------\n  # parameters for segmentation\n  # -------------------------------------------------\n  \n  \n  def$segment.alpha  <- .def(\"segment: HMM_segmentation\",\n                             \"contamination value (set to NA to use ploidy model)\",\n                             \"double\",\n                             NA)\n  \n  def$segment.ploidy  <- .def(\"segment: HMM_segmentation\",\n                              \"ref. ploidy value (set to NA to use ploidy model)\",\n                              \"double\",\n                              NA)\n  \n  def$segment.tau      <- .def(\"segment: HMM_segmentation\",\n                               \"HMM transition probability\",\n                               \"double\",\n                               1e-50)\n  \n  def$segment.cnmax    <- .def(\"segment: HMM_segmentation\",\n                               \"max CN level\",\n                               \"double\",\n                               30)\n  \n  def$segment.joinsize    <- .def(\"segment: HMM_segmentation\",\n                                  \"max interval distance in bp for segments fusion\",\n                                  \"integer\",\n                                  1e5L)\n  \n  def$segment.minsize     <- .def(\"segment: HMM_segmentation\",\n                                  \"min segment size in bp. (should be >= gccorrect.binsize)\",\n                                  \"integer\",\n                                  1000L)\n  \n  def$segment.plot.cnmax   <- .def(\"segment:report: ploidy model\",\n                                   \"cn plot max value (use 0 to disable)\",\n                                   \"double\",\n                                   10)\n  \n  def$segment.plot.rcmax   <- .def(\"segment:report: ploidy model\",\n                                   \"rrc plot max value (use 0 to disable)\",\n                                   \"double\",\n                                   4)\n\n  # -------------------------------------------------\n  # parameters for reporting\n  # -------------------------------------------------\n \n  def$report.latex.driver <- .def(\"gcmodel:rcpredict:segment:report:\",\n                                 \"latex graphics driver ('pdf' | 'jpeg')\",\n                                 \"character\",\n                                 \"jpeg\")\n  \n  def$report.driver.res   <- .def(\"gcmodel:rcpredict:segment:report:\",\n                                  \"resolution for jpeg | tiff drivers\",\n                                  \"integer\",\n                                  300L)\n\n  def\n}\n",
    "created" : 1496766488632.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "259896413",
    "id" : "F2D00A31",
    "lastKnownWriteTime" : 1502864753,
    "last_content_update" : 1502864753810,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.params.default.r",
    "project_path" : "R/asdog.params.default.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}