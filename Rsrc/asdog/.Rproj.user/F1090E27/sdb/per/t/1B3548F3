{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: $\n# Asdog: Copy Number Analysis for WGS data\n#\n# CN & AF final segmentation\n# bivariate normal (CN) & binormal (AF) model\n#\n\n# -------------------------------------------------\n# <internal> collect segments from viterbi states\n#            on single chromosome\n#\n.collect.segments <- function(states, pos, chr, ...) {\n  rle <- rle(states)\n  ifrom <- head(c(0, cumsum(rle$lengths)) + 1, -1)\n  seg <- data.frame(cbind(chr=chr,\n                          from=pos[ifrom],\n                          to=pos[ifrom+rle$lengths-1],\n                          state=rle$values))\n  data <- list(...)\n  for (e in names(data)) {\n    seg[,e] <- data[[e]][rle$values]\n  }\n  \n  seg\n}\n\n# -------------------------------------------------\n# <internal> filter segments on single chromosome\n# note: regions should be on the same chromosome\n#\n.filter.segments <- function(seg, minsize=1L, joinsize=1L, regions=NULL) {\n  \n  #\n  # intersect with regions if provided\n  #\n  # note: we cannot simply intersect the segments with regions\n  # because the intersection will artificially join contiguous\n  # segments with different states. So we have to proceed state\n  # by state instead\n  #\n  if (! is.null(regions)) {\n    seg.state <- split(seg, as.factor(seg$state))\n    res.state <- lapply(seg.state, function(seg) {\n      clocs <- clocations(cbind(chr=seg$chr, from=seg$from, to=seg$to))\n      clocs <- clocs.inter(clocs, regions, use.threads=FALSE)\n      res  <- data.frame(chr=clocs[,1], from=clocs[,2], to=clocs[,3])\n      iseg <- lx.findInterval(clocs[,2], seg$from)\n      for (e in setdiff(colnames(seg), colnames(res))) {\n        res[,e] <- seg[,e][iseg]\n      }\n      res\n    })\n    res <- do.call(rbind, res.state)\n  } else {\n    res <- seg\n  }\n  \n  #\n  # filter out dust segments\n  # that may result from intersection\n  #\n  res <- res[res$to-res$from+1 >= minsize,,drop=F]\n  if (nrow(res) == 0) return(res)\n  \n  #\n  # join close segments on same state\n  #\n  lres <- split(res, seq(nrow(res)))\n  lres <- Reduce(function(p, x) {\n    fused <- ((x$from - p$to) < joinsize) && (x$state == p$state)\n    if (fused) x$from <- p$from\n    x }, lres, lres[[1]], accumulate=T)\n  res <- do.call(rbind, tail(lres, -1))\n  clocs <- clocations(cbind(1, res$from, res$to))\n  clocs <- clocs.reduce(clocs, use.threads=F)\n  res <- res[lx.in(res$to, clocs[,3]),,drop=F]\n  \n  res\n}\n\n# -------------------------------------------------\n# <internal> collect segments statistics\n#\n\n.stat.segments <- function(seg, pos, data, lev.ref=c(\"lev.rrc\", \"lev.baf\")) {\n  \n  #\n  # get data\n  #\n  lev.ref <- match.arg(lev.ref)\n  \n  if (lev.ref == \"lev.baf\") data <- abs(data-0.5)+0.5 # fold af\n\n  #\n  # collect statistics\n  #\n  res <- lapply(seq_len(nrow(seg)), function(i) {\n    row   <- seg[i,] # 'apply' sucks\n    ifrom <- lx.findInterval(row$from, pos)\n    ito   <- lx.findInterval(row$to, pos)\n    ilen  <- ito - ifrom + 1\n    seg.data <- as.vector(data[seq.int(ifrom, ito)])\n    med  <- median(seg.data)\n    sd   <- if (ilen > 1) sd(seg.data) else 0\n    mad  <- mad(seg.data)\n    if (mad == 0) mad <- sd\n    if (lev.ref == \"lev.baf\") {\n      cor <- asdog.unfold(med, sd, type=\"median\")$solution\n      med <- cor$mu\n      mad <- cor$sd\n    }\n    ref  <- row[, lev.ref]\n    zscor <- if (med == ref) 0 else (med - ref)/mad\n    pval  <- 2*pnorm(-abs(zscor)) # two-sided\n    list(nb.mark=ilen, med=med, mad=mad, zscor=zscor, pval=pval)\n  })\n\n  as.data.frame(apply(do.call(rbind, res), 2, unlist))\n}\n\n# -------------------------------------------------\n# RRC & AF segmentation\n#\n\nasdog.segment.rcaf <- function(plmodel, regions, params,\n                               use.threads=lx.use.threads()) {\n\n  #\n  # get parameters\n  #\n  alpha  <- params$segment.alpha\n  ploidy <- params$segment.ploidy\n\n  if (is.na(alpha))  alpha  <- plmodel$best$alpha\n  if (is.na(ploidy)) ploidy <- plmodel$best$q0\n\n  lx.out(\"ploidy model : alpha=\", alpha, \" ploidy=\", ploidy)\n  \n  theo <- asdog.theo.RCAF(alpha, ploidy, 0:params$segment.cnmax)\n  max.theo.rc <- max(theo$rc)\n\n  lx.out(\"ploidy model : max.theo.rc = \", max.theo.rc)\n\n  #\n  # make HMM\n  #\n  lx.out(\"make HMM RCAF\")  \n  \n  .c <- function(x,y=x) complex(real=x, imaginary=y)\n  \n  means <- .c(theo$rc, theo$af-0.5)\n  sd.rc <- lx.wt.mean(plmodel$seg$sd.rc, plmodel$seg$weight)\n  sd.af <- lx.wt.mean(plmodel$seg$sd.af, plmodel$seg$weight)\n  sds <- .c(sd.rc, sd.af)\n  \n  hmm.rcaf <- thmm.init(drcaf.asdog, params$segment.tau,\n                        mean=means,\n                        sd=sds)\n  \n  #\n  # compute segments by chromosomes\n  #\n  lx.out(\"computing segments by chromosome\", with.mem=T)\n  \n  chrs <- unique(plmodel$rcaf$chr)\n  rcaf <- split(plmodel$rcaf, plmodel$rcaf$chr)[as.character(chrs)]\n  \n  segs.rcaf <- lx.lapply(rcaf, function(dat) {\n    \n    ichr <- as.integer(head(dat$chr, 1))\n    rrc  <- dat$rrc\n    baf  <- dat$baf\n    \n    rrc[rrc >= max.theo.rc] <- max.theo.rc\n    \n    v <- thmm.viterbi(hmm.rcaf, .c(rrc, baf-0.5))\n    \n    seg <- .collect.segments(v$states, dat$pos, ichr,\n                             lev.rrc=theo$rc, lev.baf=theo$af,\n                             lev.cn=theo$ploidy,\n                             geno=theo$label,\n                             delta.cn=rep(0, length(theo$ploidy)))\n    \n    seg <- .filter.segments(seg,\n                            minsize=params$segment.minsize, \n                            joinsize=params$segment.joinsize,\n                            regions=regions[regions[,1]==ichr,,drop=F])\n    \n    # add rrc and baf statistics\n    #\n    stat.rrc <- .stat.segments(seg, dat$pos, dat$rrc, \"lev.rrc\")\n    nb.mark  <- stat.rrc[,1]\n    ppm.mark <- nb.mark / (seg$to - seg$from + 1) * 1e6\n    stat.rrc <- stat.rrc[,-1]\n    colnames(stat.rrc) <- paste0(colnames(stat.rrc), \".rrc\")\n    stat.rrc$med.cn <- asdog.absCN(stat.rrc$med.rrc, alpha, ploidy)\n    \n    stat.baf <- .stat.segments(seg, dat$pos, dat$baf, \"lev.baf\")[,-1]\n    colnames(stat.baf) <- paste0(colnames(stat.baf), \".baf\")\n    \n    seg <- cbind(seg, nb.mark=nb.mark, ppm.mark=ppm.mark, stat.rrc, stat.baf)\n    \n    seg\n  }, use.threads=use.threads) ## thread bug \n  \n  segs.rcaf <- do.call(rbind, segs.rcaf)\n  \n  #\n  # add delta.cn for gains and losses\n  # ref.cn is the majoritary cn level observed in segments\n  # it is used to compute gains and losses\n  #\n  cnt <- aggregate(segs.rcaf$to - segs.rcaf$from+1,\n                   by=list(cn=segs.rcaf$lev.cn),\n                   FUN=sum, simplify=F)\n  ref.cn <- cnt$cn[which.max(cnt$x)]\n  segs.rcaf$delta.cn <- segs.rcaf$lev.cn - ref.cn\n\n  #\n  # end\n  #\n  \n  lx.out(\"found \", nrow(segs.rcaf), \" segments\", with.mem=T)\n  \n  list(theo=theo, hmm=hmm.rcaf, segs=segs.rcaf, ref.cn=ref.cn)\n}\n\n# -------------------------------------------------\n# RRC only segmentation\n#\n\nasdog.segment.rc <- function(gccorrect, regions, params,\n                             sd.winsize=1000L,\n                             use.threads=lx.use.threads()) {\n  #\n  # get parameters\n  #\n  alpha  <- params$segment.alpha\n  ploidy <- params$segment.ploidy\n\n  lx.out(\"ploidy model : alpha=\", alpha, \" ploidy=\", ploidy)\n  \n  theo <- asdog.theo.RCAF(alpha, ploidy, 0:params$segment.cnmax)\n  max.theo.rc <- max(theo$rc)\n  \n  lx.out(\"ploidy model : max.theo.rc = \", max.theo.rc)\n\n  #\n  # estimate rrc standard deviation\n  #\n  rrc <- unlist(sapply(gccorrect$bychr, function(x) x$rrc.cor), use.names=F)\n  lx.stopif(length(rrc) == 0, \"no rrc.cor data points found in gccorrect\")\n  \n  sd.winsize <- min(sd.winsize, length(rrc))\n  sd0 <- median(sapply(seq(1, length(rrc), sd.winsize), \n                       function(i) sd(rrc[i:(i+sd.winsize)])),\n                na.rm=T)\n  lx.out(\"sd rrc estimate=\", sd0)\n  \n  #\n  # make HMM\n  #\n  lx.out(\"make HMM RC only\")  \n  \n  means <- unique(theo$rc)\n  ploidy.levels <- theo$ploidy[match(means, theo$rc)]\n  hmm.rc <- thmm.init(dnorm, params$segment.tau, mean=means, sd=sd0)\n\n  #\n  # compute segments\n  #\n  lx.out(\"computing segments by chromosome\", with.mem=T)\n  \n  segs.rc <- lx.lapply(names(gccorrect$bychr), function(chr) {\n    \n    dat  <- gccorrect$bychr[[chr]]\n    ichr <- as.integer(chr)\n    rrc  <- dat$rrc.cor\n    \n    rrc[rrc >= max.theo.rc] <- max.theo.rc\n    \n    v <- thmm.viterbi(hmm.rc, rrc)\n    \n    seg <- .collect.segments(v$states, dat$pos, ichr, \n                             lev.rrc=means, \n                             lev.cn=ploidy.levels,\n                             delta.cn=rep(0, length(ploidy.levels)))\n    \n    seg <- .filter.segments(seg, \n                            minsize=params$segment.minsize,\n                            joinsize=params$segment.joinsize,\n                            regions=regions[regions[,1]==chr,,drop=F])\n    \n    # add rrc statistics\n    #\n    stat.rrc <- .stat.segments(seg, dat$pos, dat$rrc.cor, \"lev.rrc\")\n    nb.mark  <- stat.rrc[,1]\n    ppm.mark <- nb.mark / (seg$to - seg$from + 1) * 1e6\n    stat.rrc <- stat.rrc[,-1]\n    colnames(stat.rrc) <- paste0(colnames(stat.rrc), \".rrc\")\n    stat.rrc$med.cn <- asdog.absCN(stat.rrc$med.rrc, alpha, ploidy)\n\n    seg <- cbind(seg, nb.mark=nb.mark, ppm.mark=ppm.mark, stat.rrc)\n    \n    seg\n  }, use.threads=use.threads)\n  \n  segs.rc <- do.call(rbind, segs.rc)\n\n  #\n  # add delta.cn for gains and losses\n  # ref.cn is the majoritary cn level observed in segments\n  # it is used to compute gains and losses\n  #\n  cnt <- aggregate(segs.rc$to - segs.rc$from+1,\n                   by=list(cn=segs.rc$lev.cn),\n                   FUN=sum, simplify=F)\n  ref.cn <- cnt$cn[which.max(cnt$x)]\n  segs.rc$delta.cn <- segs.rc$lev.cn - ref.cn\n  \n  #\n  # end\n  #\n\n  lx.out(\"found \", nrow(segs.rc), \" segments\", with.mem=T)\n  \n  list(theo=theo, hmm=hmm.rc, segs=segs.rc, ref.cn=ref.cn)\n}\n\n# -------------------------------------------------\n# All segmentation - API\n#\n# note: plmodel maybe NULL\n#\nasdog.segment <- function(gccorrect, plmodel=NULL, params=gccorrect$params,\n                          use.threads=lx.use.threads()) {\n\n  #-------------------------------\n  # check parameter compatibility\n  #-------------------------------\n  \n  lx.stopif(is.null(plmodel) && (   is.na(params$segment.alpha) \n                                 || is.na(params$segment.ploidy)),\n            \"plmodel not provided. \",\n            \"you should provide segment.alpha and segment.ploidy parameters\")\n  \n  if (is.na(params$segment.alpha))\n    params$segment.alpha <- plmodel$best$alpha\n\n  if (is.na(params$segment.ploidy))\n    params$segment.ploidy <- plmodel$best$q0\n  \n  #\n  # the correct binsize is the one actually used in gccorrect\n  #\n  binsize <- gccorrect$params$gccorrect.binsize\n  params$segment.minsize <- max(params$segment.minsize, binsize)\n\n  #-------------------------------\n  # init results\n  #-------------------------------\n  \n  segment <- asdog.object('Segment', params=params)\n  \n  asdog.print.params(asdog.filter.params(params, in.filter=\"segment:\"))\n  \n  # keep sequence header\n  #\n  segment$header <- gccorrect$header\n\n  #-------------------------------\n  # Get user's regions\n  #-------------------------------\n  \n  lx.out(\"---------------------------------------\")\n  lx.out(\"Get User's regions\")\n  lx.out(\"---------------------------------------\")\n  \n  .rsize <- function(x) x[,3] - x[,2] + 1\n  .tsize <- function(x) sum(.rsize(x))\n  \n  regions <- basta2clocs(segment)\n  \n  chrs <- regions[,1]\n\n  lx.out(\"basta regions: \", length(chrs), \" chromosomes\")\n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n  \n  if (length(params$chrs) == 0)\n    params$chrs = chrs\n  \n  chrs <- intersect(chrs, params$chrs)\n  \n  lx.out(\"filtered chromosomes indexes [\", chrs, \"]\")\n\n  if (! is.null(plmodel)) {\n    chrs <- intersect(chrs, as.integer(unique(plmodel$rcaf$chr)))\n    lx.out(\"filtered rcaf chromosomes indexes [\", chrs, \"]\")\n  }\n\n  lx.stopif(length(chrs) == 0, \"empty list of chromosomes\")\n\n  regions <- regions[chrs,,drop=F]\n\n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n\n  #-------------------------------\n  # intersect with gccorrect regions\n  #-------------------------------\n  \n  lx.out(\"intersecting with gccorrect regions\")\n  \n  regions <- clocs.inter(regions, gccorrect$regions, minsize=params$segment.minsize)\n  \n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n\n  # keep chrs in params\n  \n  chrs <- unique(regions[,1])\n  params$chrs <- chrs\n  \n  lx.stopif(length(chrs) == 0, \"empty list of chromosomes\")\n\n  #-------------------------------\n  # join regions\n  #-------------------------------\n\n  lx.out(\"joining regions with joinsize= \", params$segment.joinsize, \n         \" and minsize=\", params$segment.minsize)\n  \n  regions <- clocs.join(regions, delta=params$segment.joinsize,\n                        minsize=params$segment.minsize)\n\n  lx.out(\"yielding \", nrow(regions), \n         \" regions covering \", .tsize(regions), \" bp\")\n\n  #-------------------------------\n  # Segmentation on RCAF (using plmodel normal heterozygous sites)\n  #-------------------------------\n\n  if (! is.null(plmodel)) {\n    lx.out(\"---------------------------------------\")\n    lx.out(\"Segmentation on RC-AF\")\n    lx.out(\"---------------------------------------\")\n    res.rcaf <- asdog.segment.rcaf(plmodel, regions, params,\n                                   use.threads=use.threads)\n    segs.rcaf <- res.rcaf$segs\n  } else {\n    res.rcaf  <- NULL\n    segs.rcaf <- NULL\n  }\n  \n  #-------------------------------\n  # Segmentation on RC Only (using gccorrect data)\n  #-------------------------------\n  \n  lx.out(\"---------------------------------------\")\n  lx.out(\"Segmentation on RC only\")\n  lx.out(\"---------------------------------------\")\n  \n  res.rrc <- asdog.segment.rc(gccorrect, regions, params,\n                             use.threads=use.threads)\n  segs.rrc <- res.rrc$segs\n  \n\n  #-------------------------------\n  # assign putative genotype(s) to rc segments\n  # using overlap with rcaf segments\n  #-------------------------------\n  \n  if (! is.null(segs.rcaf)) {\n    clocs.rcaf <- clocations(segs.rcaf[,1:3])\n    clocs.rc   <- clocations(segs.rrc[,1:3])\n    over <- clocs.overlap(clocs.rc, clocs.rcaf)\n    segs.rrc$geno <- sapply(over, function(lst)\n                            paste(unique(segs.rcaf[lst, \"geno\"]), collapse=\"/\"))\n  }\n  \n  #-------------------------------\n  # keep some information in Segment object\n  #-------------------------------\n  #\n  chrs.char <- as.character(params$chrs)\n  segment$regions <- regions\n  segment$rcaf.data <- if (is.null(plmodel)) NULL \n                       else split(plmodel$rcaf, plmodel$rcaf$chr)[chrs.char]\n  segment$rrc.data  <- sapply(chrs.char, function(chr) {\n                            x <- gccorrect$bychr[[chr]]\n                            data.frame(chr=chr, \n                                       pos=x$pos,\n                                       rrc=x$rrc.cor,\n                                       stringsAsFactors=F)\n                        }, simplify=F)\n  segment$rcaf.theo  <- res.rcaf$theo\n  segment$rrc.theo   <- res.rrc$theo\n  segment$rcaf.hmm   <- thmm.forget.env(res.rcaf$hmm)\n  segment$rrc.hmm    <- thmm.forget.env(res.rrc$hmm)\n  segment$rcaf.segs  <- segs.rcaf\n  segment$rrc.segs   <- segs.rrc\n  segment$rcaf.refcn <- res.rcaf$ref.cn\n  segment$rrc.refcn  <- res.rrc$ref.cn\n  \n  #\n  # end\n  #\n  \n  lx.out(\"---------------------------------------\", with.mem=T)\n  lx.out(\"End\")\n  lx.out(\"---------------------------------------\")\n  \n  lx.info(segment)            <- 'Segmentation results'\n  lx.info(segment$params)     <- 'computation parameters'\n  lx.info(segment$header)     <- 'chromosomes information'\n  lx.info(segment$regions)    <- 'regions for selecting SNPs'\n  lx.info(segment$rcaf.data)  <- 'RRC-AF data per chromosome'\n  lx.info(segment$rrc.data)   <- 'RRC only data per chromosome'\n  lx.info(segment$rcaf.theo)  <- 'RRC-AF ploidy model theo points'\n  lx.info(segment$rrc.theo)   <- 'RRC only ploidy model theo points'\n  lx.info(segment$rcaf.hmm)   <- 'RRC-AF hmm'\n  lx.info(segment$rrc.hmm)    <- 'RRC only hmm'\n  lx.info(segment$rcaf.segs)  <- 'RRC-AF segments'\n  lx.info(segment$rrc.segs)   <- 'RRC only segments'\n  lx.info(segment$rcaf.refcn) <- 'RRC-AF reference CN'\n  lx.info(segment$rrc.refcn)  <- 'RRC only reference CN'\n  \n  segment\n}\n\n# -------------------------------------------------\n# some S3 helper\n#\n\n# print overload\n\nprint.Segment <- function(segment) lx.doc(segment, .name='Segment')\n\n##\n## [AV] dev test\n##\n\nif (FALSE) {\n  \n  require(asdog)\n  \n  # !\n  # dans rcaf la position est celle des SNP heterozygotes du normal\n  # dans gccor c'est celle du centre de la fenetre de taille binsize\n  # !\n  \n  gccorrect  <- readRDS(\"/TmpStorage/GYNCS.PA16014.PR16020.WGS.gccorrect.rds\")  \n  plmodel <- readRDS(\"/TmpStorage/GYNCS.PA16014.PR16020.WGS.plmodel.rds\")  \n  \n  gccorrect  <- readRDS(\"/TmpStorage/HER2.P01952.TU110C1.WGS.gccorrect.rds\")  \n  plmodel <- readRDS(\"/TmpStorage/HER2.P01952.TU110C1.WGS.plmodel.rds\")  \n\n  gccorrect  <- readRDS(\"/TmpStorage/GYNCS.PA140A7.PR140A7.WGS.gccorrect.rds\")  \n  plmodel <- readRDS(\"/TmpStorage/GYNCS.PA140A7.PR140A7.WGS.plmodel.rds\")  \n  \n  params = asdog.new.params()\n  segment <- asdog.segment(gccorrect, plmodel, params, use.threads=T)\n\n  segment <- readRDS(\"/TmpStorage/HER2.P01952.TU110C1.WGS.segment.rds\")\n  \n  plot(segment)\n}\n",
    "created" : 1503594351523.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "605357463",
    "id" : "1B3548F3",
    "lastKnownWriteTime" : 1511562768,
    "last_content_update" : 1511562768842,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.segment.build.r",
    "project_path" : "R/asdog.segment.build.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}