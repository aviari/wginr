{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: asdog.plmodel.build.r 138 2016-11-06 10:40:00Z viari $\n# Asdog: Copy Number Analysis for WGS data\n#\n# Ploidy model : build RCAF model API\n# @seealso asdog.plmodel.model : RCAF model equations\n#\n\n\n# -------------------------------------------------\n# make ploidy model\n#\n# rcsource = object of class GCCorrect (new computation) \n#            or PLModel (recompute model)\n#\n\nasdog.plmodel <- function(rcsource, params=rcsource$params,\n                          use.threads=lx.use.threads()) {\n\n  mode <- if (\"PLModel\" %in% class(rcsource)) \"recompute\" else\n          if (\"GCCorrect\" %in% class(rcsource)) \"newmodel\" else\n          NULL\n  \n  lx.stopif(is.null(mode), \n            \"data source should be of class GCCorrect or PLModel\")\n\n  #-------------------------------\n  # init results\n  #-------------------------------\n  \n  model <- asdog.object('PLModel', params=params)\n  \n  preseg <- params$plmodel.preseg.mode\n  pexcl <- if (preseg == \"shmm\") \"bcp:\" else \"shmm:\"\n  asdog.print.params(asdog.filter.params(params, in.filter=\"cnpredict:\", out.filter=pexcl))\n  \n  #\n  # keep sequence header\n  #\n  \n  model$header <- rcsource$header\n  \n  #-------------------------------\n  # Load RCAF data\n  #-------------------------------\n  \n  if (mode == \"newmodel\") {\n    \n    #-------------------------------\n    # open the baf files\n    #-------------------------------\n    \n    lx.out(\"---------------------------------------\")\n    lx.out(\"Opening Tumour and Normal Baf files\")\n    lx.out(\"---------------------------------------\")\n    \n    name <- asdog.check.file(params$base, \"baf\")\n    tum.hdle <- baf.open(name)\n    \n    name <- asdog.check.file(params$normal, \"baf\")\n    nor.hdle <- baf.open(name)\n\n    lx.out(\"---------------------------------------\")\n    lx.out(\"Loading RC-AF data\")\n    lx.out(\"---------------------------------------\")\n    \n    rcaf <- asdog.rcaf.datasrc(nor.hdle, tum.hdle, rcsource, \n                               chrs=params$chrs,\n                               lowread=params$plmodel.snp.lowread,\n                               mincov=params$plmodel.snp.mincov,\n                               deltafreq=params$plmodel.snp.dfreq,\n                               use.threads=use.threads)\n    \n    baf.close(nor.hdle)\n    baf.close(tum.hdle)\n    \n  } else {\n    \n    lx.out(\"---------------------------------------\")\n    lx.out(\"recovering RC-AF from previous model\")\n    lx.out(\"---------------------------------------\")\n    \n    rcaf <- rcsource$rcaf\n    \n    lx.out(\"RC-AF data : \", nrow(rcaf), \" normal heterozygous sites\")\n  }\n  \n  #-------------------------------\n  # Get user's regions\n  #-------------------------------\n\n  .rsize <- function(x) x[,3] - x[,2] + 1\n  .tsize <- function(x) sum(.rsize(x))\n  \n  regions <- basta2clocs(model)\n  \n  chrs <- regions[,1]\n  \n  lx.out(\"basta regions: \", length(chrs), \" chromosomes\")\n  \n  if (length(params$chrs) == 0)\n    params$chrs = chrs\n  \n  chrs <- intersect(chrs, params$chrs)  \n  \n  lx.stopif(length(chrs) == 0, \"empty list of chromosomes\")\n  \n  lx.out(\"filtering chromosomes indexes [\", chrs, \"]\")\n  \n  regions <- regions[chrs,,drop=F]\n\n  if (! is.null(params$plmodel.regions)) {\n    \n    lx.out(\"---------------------------------------\")\n    lx.out(\"Get User's regions\")\n    lx.out(\"---------------------------------------\")\n    \n    #\n    # read user's regions\n    #\n    \n    regions.names <- lapply(params$plmodel.regions, function(x) {\n      x <- sub('@BASE@', params$normal, x)\n      x <- sub('@base@', basename(params$normal), x)\n      x <- sub('@REF@',  params$ref, x)\n      x <- sub('@ref@',  basename(params$ref), x)\n      x\n    })\n    \n    lx.out(\"user's regions: \", paste(regions.names, collapse=', '))\n    \n    regions <- regions.bybed(model, regions.names, \n                             init=regions,\n                             minreg=1L,\n                             use.threads=use.threads)\n    \n    lx.out(\"yielding \", nrow(regions), \n           \" regions covering \", .tsize(regions), \" bp\")\n    \n    lx.out(\"intersecting heterozygous sites with regions\")\n    \n    hs.clocs <- clocations(rcaf[,c(1,2,2)])\n    hs.ok <- clocs.covered(hs.clocs, regions, use.threads=use.threads)\n    \n    lx.out(sum(hs.ok), \" / \", length(hs.ok), \n           \" normal heterozygous sites kept (\",\n           sprintf(\"%.1f\", sum(hs.ok)*100/length(hs.ok)),\n           \" %)\")\n    \n    rcaf <- rcaf[hs.ok,]\n  } \n  \n  #-------------------------------\n  # Pre-Segmentation\n  #-------------------------------\n  \n  # minseg.size  Mb -> sampled size\n  \n  totsize  <- .tsize(regions)\n  rcafsize <- nrow(rcaf)\n  sampsize <- params$plmodel.preseg.sampsize\n  sampsize <- min(if (sampsize <= 0) rcafsize else sampsize, rcafsize)\n  segsize <- params$plmodel.preseg.segsize * 1e6 # param in Mb\n  segsize <- max(2, round(segsize * sampsize / totsize))\n  \n  lx.out(\"pre-segmentation minseg.size : \", segsize)\n  lx.out(\"pre-segmentation mode : \", preseg)\n  \n\n  if (preseg == \"shmm\") {  \n    \n    lx.out(\"HMM smoothing\")\n\n    rc.ctrl <- list(rcmax=params$plmodel.preseg.rcmax, \n                    raw=params$plmodel.shmm.rc.raw,\n                    smooth=params$plmodel.shmm.rc.smooth,\n                    eps.max=params$plmodel.shmm.rc.eps,\n                    max.levels=params$plmodel.shmm.rc.maxlev, \n                    sample.size=sampsize,\n                    minseg.size=segsize,\n                    tau=params$plmodel.shmm.rc.tau)\n    \n    af.ctrl <- list(raw=params$plmodel.shmm.af.raw,\n                    smooth=params$plmodel.shmm.af.smooth,\n                    eps.max=params$plmodel.shmm.af.eps,\n                    max.levels=params$plmodel.shmm.af.maxlev, \n                    sample.size=sampsize,\n                    minseg.size=segsize,\n                    tau=params$plmodel.shmm.af.tau)\n    \n    segres <- asdog.smooth.hmm.segment(rcaf$rrc, rcaf$baf,\n                                       rc.ctrl=rc.ctrl, af.ctrl=af.ctrl)\n  } else {\n    \n    lx.out(\"BCP\")\n    \n    segres <- asdog.bcp.segment(rcaf$rrc, rcaf$baf,\n                                rcmax=params$plmodel.preseg.rcmax,\n                                smooth.rc=params$plmodel.bcp.rc.smooth,\n                                smooth.af=params$plmodel.bcp.af.smooth, \n                                p0=params$plmodel.bcp.p0,\n                                sample.size=sampsize,\n                                minseg.size=segsize)\n                                \n  }\n\n  #-------------------------------\n  # Parameter fitting\n  #-------------------------------\n  \n  lx.out(\"---------------------------------------\")\n  lx.out(\"Fitting model parameters\")\n  lx.out(\"---------------------------------------\")\n  \n  # making obs structure\n  \n  lx.out(\"fit segment source : \", params$plmodel.fit.segsrc)\n  obs <- segres$seg[,1,drop=F]\n  obs$rc <- segres$seg[[params$plmodel.fit.segsrc[1]]]\n  obs$af <- segres$seg[[params$plmodel.fit.segsrc[2]]]\n  obs$weight <- log10(segres$seg$weight)\n  obs <- obs[,-1]\n\n  if (FALSE) {  # testing\n    qsd.rc <- quantile(segres$seg$sd.rc, 0.90)\n    qsd.af <- quantile(segres$seg$sd.af, 0.90)\n    hsd <- (segres$seg$sd.rc > qsd.rc) | (segres$seg$sd.af > qsd.af)\n    obs <- obs[!hsd,]\n  }\n  \n  # threshold quantile\n  #\n  # obs$weight <- obs$weight * sqrt(((obs$rc-1)^2 + (obs$af-0.5)^2))\n  #\n  quant <- quantile(obs$weight, params$plmodel.fit.weightquant)\n  obs <- obs[obs$weight >= quant,,drop=F]\n  lx.out(\"segment weight quantile \", params$plmodel.fit.segquant*100,\n         \" : \", sprintf(\"%.2f\", quant))\n\n  # fit\n  #\n  lx.out(\"fitting ploidy model\", with.mem=T)\n  \n  fit <- plmodel.fit(obs,\n                     min.A=params$plmodel.fit.arange[1],\n                     max.A=params$plmodel.fit.arange[2],\n                     step.A=params$plmodel.fit.arange[3],\n                     min.Q=params$plmodel.fit.qrange[1],\n                     max.Q=params$plmodel.fit.qrange[2],\n                     step.Q=params$plmodel.fit.qrange[3],\n                     theo.weight=params$plmodel.fit.thweight,\n                     gamma0=params$plmodel.fit.gamma,\n                     rho=params$plmodel.fit.rho,\n                     use.threads=use.threads)\n  \n  fit$status <- \"tumour\"\n  \n  #\n  # check if we should revert to Normal\n  #\n  if ((nrow(obs) == 1) || (fit$a0 >= params$plmodel.alpha.normal)) {\n    lx.warn(\"this appears to be a normal sample, status set to 'normal'\")\n    fit$status <- \"normal\"\n    fit$a0 <- 0\n    fit$q0 <- 2\n  }\n  \n  lx.out(\"best model alpha=\", fit$a0, \" Q=\", fit$q0, \n         \" qual=\", round(fit$qual, 2), \" status=\", fit$status)\n  \n  qrange <- params$plmodel.fit.qrange[1]:params$plmodel.fit.qrange[2]\n  fit$theo <- asdog.theo.RCAF(fit$a0, fit$q0, qrange=qrange)\n\n  #-------------------------------\n  # compute mean ploidy\n  #-------------------------------\n  \n  rc <- rcaf$rrc\n  iq <- quantile(rc, c(0.01, 0.99))\n  rc <- mean(rc[(rc >= iq[1]) & (rc <= iq[2])])\n  mean.ploidy <- round(asdog.absCN(rc, fit$a0, fit$q0), digits=2)\n  \n  lx.out(\"best mean ploidy=\", mean.ploidy)\n  \n  #-------------------------------\n  # compute expected profiles\n  # @todo\n  #-------------------------------\n  \n  #-------------------------------\n  # keep some information in model\n  #-------------------------------\n  #\n  model$regions <- regions\n  model$rcaf    <- rcaf\n  model$seg     <- segres$seg\n  model$fit     <- fit\n  model$best    <- list(alpha=fit$a0,\n                        q0=fit$q0,\n                        qmean=mean.ploidy,\n                        qual=fit$qual)\n\n  #\n  # end\n  #\n\n  lx.out(\"---------------------------------------\", with.mem=T)\n  lx.out(\"End\")\n  lx.out(\"---------------------------------------\")\n  \n  lx.info(model)         <- 'Ploidy model'\n  lx.info(model$params)  <- 'computation parameters'\n  lx.info(model$header)  <- 'chromosomes information'\n  lx.info(model$regions) <- 'regions for selecting SNPs'\n  lx.info(model$rcaf)    <- 'RC-AF full data'\n  lx.info(model$seg)     <- 'RC-AF pre-segments'\n  lx.info(model$fit)     <- 'model fit info'\n  lx.info(model$best)    <- 'best model parameters (alpha, Q)'\n\n  model\n}\n\n# -------------------------------------------------\n# some S3 helper\n#\n\n# print overload\n\nprint.PLModel <- function(model) lx.doc(model, .name='PLModel')\n\n##\n## [AV] dev test\n##\n\nif (FALSE) {\n  \n  require(asdog)\n  \n  plmodel <- readRDS(\"/TmpStorage/GYNCS.PA16014.PR16020.WGS.plmodel.rds\")  \n#  gccorrect <- readRDS(\"/TmpStorage/GYNCS.PA16014.PR16020.WGS.gccorrect.rds\")  \n\n  plmodel <- readRDS(\"/TmpStorage/GYNCS.PA1600A.PR16013.WGS.plmodel.rds\")  \n  \n  params = asdog.new.params()\n  plmodel <- asdog.plmodel(plmodel, params, use.threads=T)\n\n  plot(plmodel)\n  plot(plmodel, what=\"fit\")\n  \n}\n\n\n\n",
    "created" : 1503214858878.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2172968333",
    "id" : "3379B610",
    "lastKnownWriteTime" : 1503606752,
    "last_content_update" : 1503606752286,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.plmodel.build.r",
    "project_path" : "R/asdog.plmodel.build.r",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}