sorted=TRUE,
use.threads=use.threads)
sampled.0 = sampled
sampled <- asdog.sample.bygc(basta, regions,
size=params$gcmodel.sample.size,
gcwindow=params$gcmodel.sample.gcwindow,
gcbins=params$gcmodel.sample.gcbins,
minspacin=params$gcmodel.sample.spacin,
minreg=params$gcmodel.regions.minreg,
flatten=TRUE, sorted=TRUE,
use.threads=use.threads)
dim(sampled)
length(sampled)
attributes(sampled)
head(sampled)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
names(pts)
hist(pts$gc)
params$gcmodel.sample.size
params$gcmodel.sample.gcwindow
params$gcmodel.sample.gcbins
size=params$gcmodel.sample.size
gcwindow=params$gcmodel.sample.gcwindow
gcbins=params$gcmodel.sample.gcbins
minspacin=params$gcmodel.sample.spacin
minspacin
minreg=params$gcmodel.regions.minreg
minreg
flatten=TRUE
sorted=TRUE
use.threads
handle.basta
handle.basta=basta
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
length(regions)
sapply(regions, length)
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
length(sampled)
sapply(sampled, length)
sapply(regions, length)
regions=regions.bycover.band
gcbins=4
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
dilm(regions)
dim(regions)
length(regions)
regions <- basta2clocs(basta)
dim(regions)
regions <- regions.bybed(basta, regions.names,
init=regions,
minreg=params$gcmodel.regions.minreg,
use.threads=use.threads)
reg0 =regions
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
sapply(regions, length)
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
sapply(sampled, length)
sampled <- unlist(sampled, use.names=F)
if (sorted) sampled <- sort(sampled)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
hist(pts$gc)
hist(pts$gc, br=100)
params$gcmodel.sample.gcbins
params$gcmodel.sample.gcbins = 3
sampled <- asdog.sample.bygc(basta, regions,
size=params$gcmodel.sample.size,
gcwindow=params$gcmodel.sample.gcwindow,
gcbins=params$gcmodel.sample.gcbins,
minspacin=params$gcmodel.sample.spacin,
minreg=params$gcmodel.regions.minreg,
flatten=TRUE, sorted=TRUE,
use.threads=use.threads)
sampled <- asdog.sample.bygc(basta, regions,
size=params$gcmodel.sample.size,
gcwindow=params$gcmodel.sample.gcwindow,
gcbins=params$gcmodel.sample.gcbins,
minspacin=params$gcmodel.sample.spacin,
minreg=params$gcmodel.regions.minreg,
flatten=TRUE, sorted=TRUE,
use.threads=use.threads)
use.threads
gcbins
gcbins=3
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
gcbins
gcbins=4
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
dim(regions)
length(regions)
diml(reg0)
dim(reg0)
regions=reg0
rr <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
length(rr)
gcbins
gcbins=3
rr3 <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
dimm(regions)
dim(regions)
source('~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/xlx/R/xlx.regions.r')
rr3 <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=F)
xchr=0
source('~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/xlx/R/xlx.regions.r')
rr3 <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=F)
gcbins
regions=rr3
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
if (flatten) {
sampled <- unlist(sampled, use.names=F)
if (sorted) sampled <- sort(sampled)
}
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
hist(pts$gc)
hist(pts$gc, br=100)
gcbins
abline(v=c(0.33,0.66), col=2)
dim(regions)
dim(reg0)
regions=reg0
gcbins
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
length(regions)
sapply(regions, length)
regions <- regions.strata.bygc(handle.basta, regions, winsize=gcwindow,
nstrata=gcbins, minreg=minreg,
use.threads=use.threads)
length(regions)
gcwindow
minspacin
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
if (flatten) {
sampled <- unlist(sampled, use.names=F)
if (sorted) sampled <- sort(sampled)
}
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
sapply(sampled, length)
sampled <- unlist(sampled, use.names=F)
if (sorted) sampled <- sort(sampled)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
hist(pts$gc, br=100)
hist(pts$cov, br=100)
hist(pts$cov, br=100, xlim=c(0, 80))
hist(pts$cov, br=1000, xlim=c(0, 80))
hist(pts$gc, br=100)
minspacin=100
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
source('~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.gcmodel.build.r')
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
maxloop
maxloop=50
totsize <- rep(0, gcbins)
allow   <- rep(T, gcbins)
sampled <- rep(list(NULL), gcbins)
while (sum(totsize) < size) {
left <- size - sum(totsize)
reqsize <- ceiling(rep(left, gcbins) / sum(allow))
reqsize[! allow] <- 0
lx.out("sampling by gc ", left, " points left on ", size, " (", round((size-left)*100/size), "% done)")
# sample within regions
#
samp <- lapply(seq_along(regions), function(i) {
asdog.sample(handle.basta, regions[[i]], size=reqsize[i], minspacin=minspacin,
minreg=minreg, sorted=sorted, maxloop=maxloop, use.threads=use.threads)
})
sampsize <- sapply(samp, length)
sampled <- mapply(c, sampled, samp, SIMPLIFY=F)
allow <- allow & (sampsize > reqsize/2)
totsize <- totsize + sampsize
if (sum(sampsize) == 0) {
lx.warn("sampling exhausted at ", sum(totsize), " points")
break
}
}
sapply(sampled, length)
sampled <- unlist(sampled, use.names=F)
if (sorted) sampled <- sort(sampled)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
hist(pts$gc, br=100)
regions=reg0
params$gcmodel.sample.spacin
params$gcmodel.sample.spacin=1000
sampled <- asdog.sample.bygc(basta, regions,
size=params$gcmodel.sample.size,
gcwindow=params$gcmodel.sample.gcwindow,
gcbins=params$gcmodel.sample.gcbins,
minspacin=params$gcmodel.sample.spacin,
minreg=params$gcmodel.regions.minreg,
flatten=TRUE, sorted=TRUE,
use.threads=use.threads)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
hist(pts$gc, br=100)
params$gcmodel.sample.gcbins
params$gcmodel.sample.gcbins=10
params$gcmodel.sample.spacin
params$gcmodel.sample.spacin=0
sampled <- asdog.sample.bygc(basta, regions,
size=params$gcmodel.sample.size,
gcwindow=params$gcmodel.sample.gcwindow,
gcbins=params$gcmodel.sample.gcbins,
minspacin=params$gcmodel.sample.spacin,
minreg=params$gcmodel.regions.minreg,
flatten=TRUE, sorted=TRUE,
use.threads=use.threads)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
hist(pts$gc, br=100)
hist(pts$gc, br=50)
params$gcmodel.sample.gcbins=20
sampled <- asdog.sample.bygc(basta, regions,
size=params$gcmodel.sample.size,
gcwindow=params$gcmodel.sample.gcwindow,
gcbins=params$gcmodel.sample.gcbins,
minspacin=params$gcmodel.sample.spacin,
minreg=params$gcmodel.regions.minreg,
flatten=TRUE, sorted=TRUE,
use.threads=use.threads)
pts <- asdog.rcgc.collect(datasrc, sampled,
winsize.gc=params$gccorrect.binsize,
winsize.cov=params$gccorrect.binsize,
use.threads=use.threads)
length(sampled)
hist(pts$gc, br=50)
hist(pts$gc, br=100)
hist(pts$gc, br=50)
?regions.bycover.band
gc()
gc()
install.packages('jetset')
x= read.table("/Users/viari/data.txt",sep=',', header=T)
x= read.table("/Users/viari/Desktop/data.txt",sep=',', header=T)
dim(x)
head(x)
x$new_DATE_DECES
x$DECES_FICHE_
table(x$DECES_FICHE_)
x$
a
x$delai_os
segment <- readRDS("/Users/viari/Desktop/LUNG.PA18029.PR18028.WGS.segment.rds")
library(asdog)
fname = "toto"
asdog.pdf.report(segment,
fname)
tex <- tex.open(fname)
asdog.tex.report.segment(tex, segment)
params <- segment$params
p <- asdog.filter.params(params, in.filter="segment:")
p <- as.matrix(p, ncol=2)
p <- as.data.frame(apply(p, 1, paste))
names(p) <- 'value'
tex.section(tex, "Parameters")
tex.print(tex, p, size='small')
source('~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.segment.report.r')
segment$rcaf.segs
tex.tag(tex, "newpage")
tex.section(tex, "RCAF segments summary")
tex <- tex.fig.on(tex, width=7, height=7, family="Times")
.histo.segnum(segment, "rcaf")
what="rcaf"
.mean <- function(x, w) {
ok <- ! (is.na(x) | is.infinite(x))
lx.wt.mean(x[ok], w[ok], na.rm=T)
}
segs <- segment[[paste0(what, ".segs")]]
segs.chr <- split(segs, segs$chr)
tab <- table(segs$chr)
tab
colr <- asdog.chromos.colors(names(tab))
lx.barplot(tab, cex.text=0.7, col=colr, cex.names=0.7,
main=paste0("number of ",  what, " segments"))
dens <- tab / sapply(segment$header$seq, function(x) x$size)[names(tab)]
dens <- round(dens * 1e8) / 100
dens
names(tab)
dens <- tab / sapply(segment$header$seq, function(x) x$size)[names(tab)]
tab
dens
segment$header$seq
sapply(segment$header$seq, function(x) x$size)
a=sapply(segment$header$seq, function(x) x$size)
names(tab)
a=sapply(segment$header$seq, function(x) x$size)
names(a)
head(names(a))
asdog.chromos.colors(names(tab))
lx.barplot(tab, cex.text=0.7, col=colr, cex.names=0.7,
main=paste0("number of ",  what, " segments"))
dev.off()
lx.barplot(tab, cex.text=0.7, col=colr, cex.names=0.7,
main=paste0("number of ",  what, " segments"))
dev.off()
dev.off()
dev.on()
quartz()
lx.barplot(tab, cex.text=0.7, col=colr, cex.names=0.7,
main=paste0("number of ",  what, " segments"))
names(tab)
dens <- tab / sapply(segment$header$seq, function(x) x$size)[as.integer(names(tab))]
dens
dens <- round(dens * 1e8) / 100
lx.barplot(dens, cex.text=0.7, col=colr, cex.names=0.7,
srt.text=90, pos.text=3, off.text=0.8, col.text=1,
main=paste0("number of ",  what, " segments per Mb"))
zsco <- sapply(segs.chr, function(seg) .mean(seg$zscor.rrc, seg$to-seg$from+1))
pval <- sapply(segs.chr, function(seg) .mean(seg$pval.rrc, seg$to-seg$from+1))
colr <- asdog.gradient.colors(abs(zsco), xrange=c(0, 10), nlevels=11, alpha=0.5, rev=T)
lx.barplot(round(pval*100)/100, col=colr, cex.names=0.7, cex.text=0.7, srt.text=90,
pos.text=3, off.text=0.8, col.text=1,
main=paste0("mean ", what, " segments quality"))
source('~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/asdog/R/asdog.segment.report.r')
tex <- tex.open(fname)
asdog.tex.report.segment(tex, segment)
x=c(3,4)
mean(x)
var(x)
?var
sd(x)
3e7 / 365
