{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: xlx.coords.r 301 2017-08-14 17:58:00Z viari $\n# XLX coordinate systems\n#\n# @todo: make an S3 class Lcoation to wrap this stuff\n#\n\n# -------------------------------------------------\n#' @name HELP.COORD\n#' @docType data\n#' @title Coordinate systems\n#' @description\n#' XLX tools use three coordinates system:\\cr\n#' \\subsection{Relative string coordinates, called \\code{sloc}}{\n#'   a \\code{sloc} is a string of the form :\\cr\n#'   \\code{\"chrname:from-to\"} or \\code{\"chrname:from:to\"}\\cr\n#'   where \\code{chrname} is the sequence name (not the sequence index)\n#'    \\code{from} and \\code{to} can be either 1-based (default)\n#'   or 0-based (by specifiying the zero.based.loc=TRUE option)\n#' }\n#' \\subsection{Relative coordinates, called \\code{cloc}}{\n#'    a \\code{cloc} is a 1-based \\code{slocation} of the form:\\cr\n#'    \\code{c(chrindex, from, to)}\n#'    where \\code{chrindex} is the (1-based) index of sequence entry in basta file.\\cr\n#'    \\code{chrindex}, \\code{from} and \\code{to} are (32 bits) integers.\n#' }\n#' \\subsection{Absolute coordinates, called \\code{coord}}{\n#'  a \\code{coord} represents two absolute positions in the catenated chromosomes,\n#'  of the form \\code{c(from, to)}.\\cr\n#'  absolute coordinates are always 1-based\\cr\n#'  \\code{from} and \\code{to} are (64 bits) doubles actually representing integers\n#'  (there is no loss of precision until 53 bits i.e. 9,007,199,254,740,992)\n#' }\n#' It is not memory nor speed efficient to manipulate large amount\n#' of clocations as lists (it uses about 64 bytes per clocation).\\cr\n#' Instead, XLX manipulate sets of clocations by matrices or list of matrices\n#' (this uses 12 or 8 bytes per clocation and is much quicker to operate).\n#' \\subsection{Matrix of clocations, called \\code{clocs}}{\n#' a \\code{clocs} is a nx3 matrix. each row is a clocation chrindex, from, to.\n#' columns are named: \"chr\", \"from\", \"to\" respectively.\n#' if necessary you may convert it to a dataframe by: \\code{as.data.frame(clocs)}.\n#' note that \"chr\" is (as in cloc) a chrindex \\bold{not} a chr name.\n#' use \\code{basta.index2name} or \\code{basta.name2index} to transform between\n#' names and indexes}\n#' \\subsection{List of matrices of locations, called \\code{llocs}}{\n#' a \\code{llocs} is a more memory efficient version of \\code{clocs}.\n#' this is a named list of matrices. each element of the list is named\n#' by a chromosome index (as character) and contains an mx2 matrix\n#' of from, to relative positions on this chromosome.\n#' }\n#' \\subsection{Matrix of coordinates, called \\code{coords}}{\n#' a \\code{coords} is a nx2 matrix. each row is a coord absfrom, absto.\n#' columns are named: \"from\", \"to\" respectively.\n#' if necessary you may convert it to a dataframe by: \\code{as.data.frame(coords)}\n#' }\n#' \\subsection{Summary}{\n#'   \\tabular{llll}{\n#'   \\bold{single location} \\tab \\tab \\tab \\cr\n#'   \\bold{shortname} \\tab \\bold{name} \\tab \\bold{definition} \\tab \\bold{base}\\cr\n#'   sloc \\tab relative slocation \\tab \"chrname:from-to\" \\tab 0 or 1-based\\cr\n#'   cloc \\tab relative clocation \\tab c(chrindex, from, to) \\tab 1-based\\cr\n#'   coord \\tab absolute coordinates \\tab c(absfrom, absto) \\tab 1-based offset\\cr\\cr\n#'   \\bold{multiple locations} \\tab \\tab \\tab \\cr\n#'   \\bold{shortname} \\tab \\bold{name} \\tab \\bold{definition} \\tab \\bold{base}\\cr\n#'   clocs \\tab matrix of clocations \\tab nx3 matrix \\tab 1-based\\cr\n#'   llocs \\tab list of matrices of locations \\tab n list of mx2 matrices \\tab 1-based\\cr\n#'   coords \\tab matrix of coordinates \\tab nx2 matrix \\tab 1-based\\cr\n#'   }\n#' }\n#' \n#' @note\n#' in 1-based system endpoints are included : [from, to]\\cr\n#' in 0-based system the right endpoint is excluded : [from, to[\\cr\n#' the conversion between 0-based and 1-based is therefore\\cr\n#' from0 = from1 - 1\\cr\n#' to0   = to1\\cr\n#' @note\n#' conversion between coordinate systems is performed by the\n#' <xxx>2<yyy> functions (e.g. \\link{coord2cloc})\n#' @note\n#' when extracting rows (or cols) from matrix, don't forget\n#' to add the \\code{drop=FALSE} last subscript, in order to avoid\n#' spurious coercing to vector when selecting a single row (or col).\n#' (eg: \\code{clocs[1,,drop=FALSE]})\n#'\nNULL\n\n# =================================================\n# internals <no_export>\n# =================================================\n\n# -------------------------------------------------\n# <internal> <no_export>\n# emit warning\n#\n.xlx.warn <- function(ret=NULL, ..., up.frame=1) {\n  lx.warn(..., up.frame=up.frame)\n  ret\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# default colnames for clocations matrix\n#\n.xlx.colnames <- function() {\n  c(\"chr\", \"from\", \"to\")\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# clocations matrix to interval (chr is lost)\n#\n.clocs2inter <- function(clocs) {\n  if (is.null(clocs)) clocs <- matrix(0, ncol=3, nrow=0)\n  clocs <- clocs[clocs[,2]<=clocs[,3],,drop=FALSE]\n  intervals::Intervals(clocs[,-1], type='Z')\n}\n\n# =================================================\n# API\n# =================================================\n\n# -------------------------------------------------\n#' reformat data to proper matrix of clocations\n#' @description\n#' this function is mostly used within other functions to properly\n#' (re)format a clocs matrix. It is quite unusual to call it directly,\n#' please consider \\link{clocations} instead.\n#' @param x data to reformat (see details)\n#' @return nx3 matrix of clocations with proper\n#' colnames and storage.\n#' @details\n#' data can be :\\cr\n#' \\itemize{\n#' \\item NULL : return empty matrix\n#' \\item matrix : (should be nx3) then just setup colnames and storage mode\n#' \\item dataframe : (should be nx3) then convert to matrix \n#' \\item  anything else: transform to nx3 matrix \n#' }\n#' @seealso \\link{clocations}\n#' @examples\n#' clocs.matrix() # empty clocs\n#' clocs.matrix(list(c(1,1,10), c(2,1,10)))\n#' clocs.matrix(c(1,1,10, 2,1,10))\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs.matrix(lapply(c(\"seq1:1-10\", \"seq2:1-10\"), sloc2cloc, handle=fh))\n#' basta.close(fh)\n#\nclocs.matrix <- function(x=NULL) {\n  if (length(x) == 0)        x <- matrix(0L, nrow=0, ncol=3)\n  else if (is.matrix(x))     x <- x\n  else if (is.data.frame(x)) x <- as.matrix(x)\n  else                       x <- matrix(unlist(x, use.names=FALSE),\n                                         ncol=3, byrow=TRUE)\n\n  colnames(x) <- .xlx.colnames()\n  rownames(x) <- NULL\n  storage.mode(x) <- \"integer\"\n  x\n}\n\n# -------------------------------------------------\n#' create a matrix of clocations from data\n#' @description\n#' check if data is a proper matrix of clocations and\n#' reformat it if necessary.\n#' @param x data to reformat (see details)\n#' @return nx3 matrix of clocations with proper\n#' colnames and storage.\n#' @details\n#' data can be :\\cr\n#' \\itemize{\n#' \\item NULL : return empty matrix\n#' \\item matrix : (should be nx3) then just setup colnames and storage mode\n#' \\item dataframe : (should be nx3) then convert to matrix \n#' \\item  anything else: transform to nx3 matrix \n#' }\n#' @seealso \\link{clocs.matrix}\n#' @examples\n#' clocations() # empty clocs\n#' clocations(list(c(1,1,10), c(2,1,10)))\n#' clocations(c(1,1,10, 2,1,10))\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocations(lapply(c(\"seq1:1-10\", \"seq2:1-10\"), sloc2cloc, handle=fh))\n#' basta.close(fh)\n#\nclocations <- function(x=NULL) {\n\n  if (   (length(dim(x)) != 2)\n      || (storage.mode(x) != \"integer\")\n      || (! identical(colnames(x), .xlx.colnames())))\n    x <- clocs.matrix(x)\n  \n  x\n}\n\n# -------------------------------------------------\n#' transform relative slocation to relative clocation\n#' @description\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param slocation relative slocation (\"chrname:from-to\")\n#' @param zero.based.loc given slocation is 0-based\n#' @return relative clocation (1-based), NULL on error\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' sloc2cloc(fh, \"seq1:1-10\")\n#' basta.close(fh)\n#'\nsloc2cloc <- function(handle, slocation, zero.based.loc=FALSE) {\n  if (is.null(slocation))\n    return(NULL)\n  \n  loc <- unlist(strsplit(slocation, \":|-\"))\n  if (length(loc) != 3)\n    return(.xlx.warn(NULL, \"malformed slocation : \", slocation))\n  \n  indx <- basta.name2index(handle, loc[1])\n  if (is.null(indx))\n    return(.xlx.warn(NULL, \"unknown sequence : \", loc[1]))\n\n  zero <- ifelse(zero.based.loc, 1L, 0L)\n  from <- as.integer(loc[2]) + zero\n  to   <- as.integer(loc[3])\n  \n  c(indx, from, to)\n}\n\n# -------------------------------------------------\n#' transform relative clocation to relative slocation\n#' @description\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param clocation relative clocation c(chrindex, from, to) (1-based)\n#' @param zero.based.loc returned slocation should be 0-based\n#' @return relative slocation \"chrname:from-to\" (0 or 1-based), NULL on error\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' cloc2sloc(fh, c(1, 1, 10))\n#' basta.close(fh)\n#'\ncloc2sloc <- function(handle, clocation, zero.based.loc=FALSE) {\n  if (is.null(clocation))\n    return(NULL)\n  \n  name <- basta.index2name(handle, clocation[1])\n  if (is.null(name))\n    return(.xlx.warn(NULL, \"unknown sequence index : \", clocation[1]))\n    \n  zero <- ifelse(zero.based.loc, 1, 0)\n  paste(name, \":\", clocation[2] - zero, \"-\", clocation[3], sep=\"\")\n}\n\n# -------------------------------------------------\n#' transform relative clocation to absolute coordinates\n#' @description\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param clocation relative clocation c(chrindex, from, to) (1-based)\n#' @param truncate truncate 3' to seq.size if needed\n#' @return absolute coordinates c(absfrom, absto) (1-based), NULL on error\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' cloc2coord(fh, c(1, 1, 10))\n#' cloc2coord(fh, c(2, 1, 10))\n#' basta.close(fh)\n#'\ncloc2coord <- function(handle, clocation, truncate=TRUE) {\n  if (is.null(clocation))\n    return(NULL)\n  \n  seqindx <- clocation[1]\n  if ((seqindx <= 0) || (seqindx > handle$header$nbseq))\n    return(.xlx.warn(NULL, \"unknown sequence index : \", seqindx))\n\n  seq <- handle$header$seq[[seqindx]]\n  if (truncate) {\n    if (clocation[2] > seq$size) clocation[2] <- seq$size\n    if (clocation[3] > seq$size) clocation[3] <- seq$size\n  }\n  c(clocation[2], clocation[3]) + seq$offset\n}\n\n# -------------------------------------------------\n#' transform relative slocation to absolute coordinates\n#' @description\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param slocation relative slocation (\"chrname:from-to\")\n#' @param zero.based.loc given slocation is 0-based\n#' @param truncate truncate 3' to seq.size if needed\n#' @return absolute coordinates c(absfrom, absto) (1-based), NULL on error\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' sloc2coord(fh, \"seq1:1-10\")\n#' sloc2coord(fh, \"seq2:1-10\")\n#' basta.close(fh)\n#'\nsloc2coord <- function(handle, slocation, zero.based.loc=FALSE, truncate=TRUE) {\n  cloc <- sloc2cloc(handle, slocation, zero.based.loc=zero.based.loc)\n  if (is.null(cloc))\n    return(NULL)\n  cloc2coord(handle, cloc, truncate=truncate)\n}\n\n# -------------------------------------------------\n#' transform absolute coordinates to relative clocation\n#' @description\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param coord absolute coordinates c(absfrom, absto) (1-based) or\n#'        single absolute position\n#' @param truncate truncate 5' and 3' to seq.size if needed\n#' @return relative clocation c(chrindex, from, to) (1-based), NULL on error\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' coord2cloc(fh, c(1, 10))\n#' coord2cloc(fh, c(25, 34))\n#' basta.close(fh)\n#'\ncoord2cloc <- function(handle, coord, truncate=TRUE) {\n\n  if (length(coord) == 1) coord <- c(coord, coord)\n  \n  off <- handle$header$offsets\n\n  ifrom <- findInterval(coord[1]-1, off)\n  ito   <- findInterval(coord[2]-1, off)\n  \n  if (ifrom != ito)\n    return(.xlx.warn(NULL, \"coordinates span several chromosomes\"))\n  \n  if (ifrom <= 0)\n    return(.xlx.warn(NULL, \"invalid (<=0) coordinates\"))\n  \n  seq <- handle$header$seq[[ifrom]]\n  loc  <- coord - seq$offset\n  \n  from <- loc[1]\n  to   <- loc[2]\n\n  if ((from > seq$size) && truncate) from <- seq$size\n  if ((to   > seq$size) && truncate) to   <- seq$size\n  \n  as.integer(c(ifrom, from, to))\n}\n\n# -------------------------------------------------\n#' transform absolute coordinates to relative slocation\n#' @description\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param coord absolute coordinates c(absfrom, absto) (1-based) or\n#'        single absolute position\n#' @param zero.based.loc given slocation is 0-based\n#' @param truncate truncate 3' to seq.size if needed\n#' @return relative slocation \"chrname:from-to\" (0 or 1-based), NULL on error\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' coord2sloc(fh, c(1, 10))\n#' coord2sloc(fh, c(25, 34))\n#' basta.close(fh)\n#'\ncoord2sloc <- function(handle, coord, zero.based.loc=FALSE, truncate=TRUE) {\n  cloc <- coord2cloc(handle, coord, truncate=truncate)\n  if (is.null(cloc))\n    cloc\n  else\n    cloc2sloc(handle, cloc, zero.based.loc=zero.based.loc)\n}\n\n# -------------------------------------------------\n#' transform matrix of absolute coordinates to matrix of relative clocations\n#' @description\n#' transform a nx2 matrix of absolute coordinates (or a vector of point\n#' coordinates) to nx3 matrix of relative clocations.\\cr\n#' see \\link{HELP.COORD} for help on coordinates systems\n#'\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param coords nx2 matrix of absolute coordinates  (1-based) or\n#'        vector of n absolute point coordinates\n#' @param truncate truncate 5' and 3' to seq.size if needed\n#' @return nx3 matrix of relative clocation (1-based)\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#'\n#' x <- sample(1:50, 10, replace=TRUE)\n#' coo <- cbind(x, x)\n#' clocs <- coords2clocs(fh, coo)\n#' plocs <- coords2clocs(fh, x)\n#' identical(clocs, plocs)\n#'\n#' x <- sample(25:30, 10, replace=TRUE)\n#' coo <- cbind(from=x, to=x+10)\n#' clocs <- coords2clocs(fh, coo)\n#' rcoo <-clocs2coords(fh, clocs)\n#' identical(coo, rcoo)\n#'\n#' clocs <- coords2clocs(fh, matrix(0, ncol=2, nrow=0))\n#' clocs <- coords2clocs(fh, matrix(1, ncol=2, nrow=1))\n#'\n#' basta.close(fh)\n#' @note\n#' if some absolute coordinates span several chromosomes\n#' then the corresponding rows are discarded.\n#'\ncoords2clocs <- function(handle, coords, truncate=TRUE) {\n\n  if (is.null(coords))\n    return(clocs.matrix(NULL))\n  \n  header <- handle$header\n\n  ncols <- ncol(coords)\n  if ( is.null(ncols) || (ncols < 2))\n    coords <- cbind(coords, coords)\n    \n  findx <- findInterval(coords[,1] - 1, header$offsets)\n  tindx <- findInterval(coords[,2] - 1, header$offsets)\n\n  ok <- (findx == tindx)\n  if (! all(ok)) {\n    .xlx.warn(NULL, \"coordinates span several chromosomes\")\n    findx <- findx[ok]\n    tindx <- tindx[ok]\n    coords <- coords[ok,,drop=F]\n  }\n  \n  ok <- (findx > 0)\n  if (! all(ok)) {\n    .xlx.warn(NULL, \"invalid (<=0) coordinates\")\n    findx <- findx[ok]\n    tindx <- tindx[ok]\n    coords <- coords[ok,,drop=F]\n  }\n\n  if (truncate) {\n    #\n    # for compatibilty with version < 1.6\n    # where header$sizes was absent\n    #\n    if (is.null(header$sizes))\n      header$sizes <- sapply(header$seq, function(x) x$size)\n    off  <- header$offsets[findx]\n    siz  <- header$sizes[findx]\n    clocs <- cbind(findx, \n                   pmin(siz, coords[,1] - off),\n                   pmin(siz, coords[,2] - off))\n  } else {\n    clocs <- cbind(findx, coords - header$offsets[findx])\n  }\n  \n  \n  clocs.matrix(clocs)\n}\n\n# -------------------------------------------------\n#' transform matrix of relative clocations to matrix of absolute coordinates \n#' @description\n#' transform a nx3 matrix of relative clocations to\n#' a nx2 matrix of absolute coordinates\\cr\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param clocations nx3 matrix of relative clocation (1-based)\n#' @return nx2 matrix of absolute coordinates  (1-based)\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#'\n#' x <- sample(1:50, 10, replace=TRUE)\n#' coo <- cbind(x, x)\n#' clocs <- coords2clocs(fh, coo)\n#' plocs <- coords2clocs(fh, x)\n#' identical(clocs, plocs)\n#'\n#' x <- sample(25:30, 10, replace=TRUE)\n#' coo <- cbind(from=x, to=x+10)\n#' clocs <- coords2clocs(fh, coo)\n#' rcoo <-clocs2coords(fh, clocs)\n#' identical(coo, rcoo)\n#'\n#' clocs <- coords2clocs(fh, matrix(0, ncol=2, nrow=0))\n#' clocs2coords(fh, clocs)\n#' clocs <- coords2clocs(fh, matrix(1, ncol=2, nrow=1))\n#' clocs2coords(fh, clocs)\n#'\n#' basta.close(fh)\n#'\nclocs2coords <- function(handle, clocations) {\n  if (is.null(clocations)) clocations <- clocs.matrix(NULL)\n  offs <- sapply(handle$header$seq, function(x) x$offset, USE.NAMES=FALSE)\n  clocations[,-1, drop=FALSE] + offs[clocations[,1, drop=FALSE]]\n}\n\n# -------------------------------------------------\n#' split matrix of clocations into submatrices\n#' @description\n#' split matrix of clocations (by rows) into submatrices according\n#' to \\code{by} \\cr\n#' @param clocations matrix of clocations\n#' @param by group factors (should be of length nrow(clocations))\n#' @return list of submatrices (named by factors)\n#' @seealso \\link{clocs.rbind} for the reverse operation\n#' @note\n#' levels in \\code{by} that do not occur are dropped.\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs <- coords2clocs(fh, 1:25)\n#' x <- clocs.rsplit(clocs)\n#' y <- clocs.rbind(x)\n#' z <- clocs2coords(fh, y)\n#' identical(as.integer(z[,1]), 1:25)\n#' basta.close(fh)\n#'\nclocs.rsplit <- function(clocations, by=clocations[,1]) {\n  if (is.null(clocations)) clocations <- clocs.matrix(NULL)\n  spl <- split(seq_len(nrow(clocations)), by)\n  lapply(spl, function(x) clocs.matrix(clocations[x,,drop=FALSE]))\n}\n\n# -------------------------------------------------\n#' catenate a list of matrices of clocations into single matrix\n#' @description\n#' catenate (by rows) a list of matrices of clocations into a\n#' single matrix of clocations.\\cr\n#' @param submatrices list of submatrices of clocations\n#' @return matrix of clocations\n#' @seealso \\link{clocs.rsplit} for the reverse operation\n#' @note\n#' this is equivalent to \\code{do.call(rbind, submatrices)}\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs <- coords2clocs(fh, 1:25)\n#' x <- clocs.rsplit(clocs)\n#' y <- clocs.rbind(x)\n#' z <- clocs2coords(fh, y)\n#' identical(as.integer(z[,1]), 1:25)\n#' basta.close(fh)\n#'\nclocs.rbind <- function(submatrices) {\n  clocations(do.call(rbind, submatrices))\n}\n\n# -------------------------------------------------\n#' convert clocations to llocations\n#' @description\n#' convert a nx3 matrix of clocations to a list of\n#' mx2 locations.\n#' (see \\link{HELP.COORD} for help on coordinates systems)\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @return named list of mx2 relative locations per chromosome\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs <- coords2clocs(fh, 1:25)\n#' llocs <- clocs2llocs(clocs)\n#' rclocs <- llocs2clocs(llocs)\n#' identical(clocs, rclocs)\n#' basta.close(fh)\n#'\nclocs2llocs <- function(clocations) {\n  lx.lapply(clocs.rsplit(clocations), function(clocs) clocs[,-1, drop=FALSE],\n                use.threads=FALSE)\n}\n\n# -------------------------------------------------\n#' convert llocations to clocations\n#' @description\n#' convert a named list of mx2 locations to a nx3 matrix of clocations.\n#' (see \\link{HELP.COORD} for help on coordinates systems)\n#' @param llocations named list of mx2 relative locations per chromosome (see note)\n#' @return nx3 matrix of relative clocations (1-based)\n#' @note\n#' llocations must be named by chromosome indexes (as character)\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs <- coords2clocs(fh, 1:25)\n#' llocs <- clocs2llocs(clocs)\n#' rclocs <- llocs2clocs(llocs)\n#' identical(clocs, rclocs)\n#' basta.close(fh)\n#'\nllocs2clocs <- function(llocations) {\n  clocs.rbind(lx.napply(llocations, function(name, lloc) {\n    cbind(as.integer(name), lloc)\n  }, use.threads=FALSE))\n}\n\n# -------------------------------------------------\n#' test if clocations is empty\n#' @description \n#' Test if clocations is empty (either null or no rows)\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @return boolean TRUE if empty.\n#' @examples\n#' clocs.is.empty(NULL)\n#' clocs.is.empty(clocations())\n#' clocs.is.empty(clocations(c(1,1,10)))\n#' \nclocs.is.empty <- function(clocations) {\n  nr <- nrow(clocations)\n  is.null(nr) || (nr == 0)\n}\n\n# -------------------------------------------------\n#' clocations sanity check\n#' @description \n#' Test if clocations matrix is valid i.e. that\\cr\n#' \\code{1 <= from <= to <= seq.len} and \\code{1 <= chr <= nchr}.\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open}). this parameter is optional (see details).\n#' @details if \\code{handle} is provided then the function checks\n#' that \\code{to <= seq.len} and \\code{chr <= nchr} else these\n#' conditions are ignored.\n#' @note an empty clocations is valid.\n#' @return boolean TRUE if valid.\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs.is.valid(NULL)\n#' clocs <- clocations(c(1,10,25, 2,30,10))\n#' clocs.is.valid(clocs)\n#' clocs <- clocations(c(1,10,25, 2,10,30))\n#' clocs.is.valid(clocs)\n#' clocs.is.valid(clocs, fh)\n#' clocs <- clocations(c(1,10,24, 2,10,30))\n#' clocs.is.valid(clocs, fh)\n#' basta.close(fh)\n#' \nclocs.is.valid <- function(clocations, handle=NULL) {\n  if (clocs.is.empty(clocations)) return(TRUE)\n  ok <- all(  (clocations[,1] >= 1)\n            & (clocations[,2] >= 1)\n            & (clocations[,3] >= clocations[,2]))\n  if (! ok) return(FALSE)\n  if (! is.null(handle)) {\n    ok <- all(clocations[,1] <= handle$header$nbseq)\n    if (! ok) return(FALSE)\n    #\n    # for compatibilty with version < 1.6\n    # where header$sizes was absent\n    #\n    if (is.null(handle$header$sizes))\n      handle$header$sizes <- sapply(handle$header$seq, function(x) x$size)\n    ok <- all(clocations[,3] <= handle$header$sizes[clocations[,1]])\n  }\n  ok\n}\n\n# -------------------------------------------------\n#' test if clocations are \\bold{not} sorted\n#' @description \n#' Test if clocations are not sorted without the cost of sorting it.\n#' @details the sort order is: first by increasing chromosome index\n#' (clocations[,1]) then, for equal chromosome index, by increasing from\n#' (clocations[,2]) then, for equal from, by increasing to if \n#' \\code{decreasing.to==FALSE} else by decreasing to.\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param decreasing.to boolean or NA.\n#' should the sort order of \\code{to} be increasing or decreasing?\n#' may be set to NA if you don't care about the order of to.\n#' @return boolean TRUE if unsorted, FALSE if sorted\n#' @note for coords you may use the R base function \\link{is.unsorted}\n#' @seealso \\link{clocs.sort}\n#' @examples\n#' clocs <- clocations(c(1,1,5, 1,10,10, 1,10,20, 2,5,10))\n#' clocs.is.unsorted(clocs)\n#' clocs.is.unsorted(clocs, decreasing.to=TRUE)\n#' clocs.is.unsorted(clocs, decreasing.to=NA)\n#' clocs <- clocs.sort(clocs, decreasing.to=TRUE)\n#' \nclocs.is.unsorted <- function(clocations, decreasing.to=FALSE) {\n  dif.chr  <- diff(clocations[,1])\n  if (any(dif.chr < 0)) return(TRUE)\n  dif.from <- diff(clocations[,2])\n  if (any((dif.from < 0) & (dif.chr == 0))) return(TRUE)\n  if (is.na(decreasing.to)) return(FALSE)\n  dif.to <- diff(clocations[,3])\n  dif.to <- if (decreasing.to) (dif.to > 0) else (dif.to < 0)\n  any(dif.to & (dif.from == 0) & (dif.chr == 0))\n}\n\n# -------------------------------------------------\n#' sort clocations\n#' @description \n#' sort clocations in increasing order of chr, from and increasing or\n#' decreasing order of to.\n#' @details the sort order is: first by increasing chromosome index\n#' (clocations[,1]) then, for equal chromosome index, by increasing from\n#' (clocations[,2]) then, for equal from, by increasing to\n#' if \\code{decreasing.to=FALSE} else by decreasing to.\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param decreasing.to boolean.\n#' should the sort order of \\code{to} be decreasing or increasing?\n#' @return sorted nx3 matrix of relative clocations\n#' @note for coords you may simply use the R base function \\link{sort}\n#' @seealso \\link{clocs.is.unsorted}\n#' @examples\n#' clocs <- clocations(c(1,10,20, 1,10,30, 2,5,10, 1,1,100))\n#' clocs.sort(clocs)\n#' clocs.sort(clocs, decreasing.to=TRUE)\n#'\nclocs.sort <- function(clocations, decreasing.to=FALSE) {\n  if (clocs.is.empty(clocations)) return(clocations(NULL))\n  to <- if (decreasing.to) -clocations[,3] else clocations[,3]\n  clocations[order(clocations[,1], clocations[,2], to),,drop=F]\n}\n\n# -------------------------------------------------\n#' test if clocations are disjoint\n#' @description \n#' Test if clocations are (weakly or strongly) disjoint.\\cr\n#' weakly disjoint <=> no interval is completely\n#' included in another one (but intervals may overlap)\\cr\n#' strongly disjoint <=> no two intervals overlap.\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param strong if strongly disjoint\n#' @return boolean TRUE if (weakly/strongly) disjoint\n#' @note this function runs slightly quicker if clocations has already\n#' been sorted by \\link{clocs.sort} with decreasing.to=TRUE.\n#' @examples\n#' clocs <- clocations(c(1,1,10, 1,11,20, 1,21,30, 2,5,10))\n#' clocs.is.disjoint(clocs)\n#' clocs <- clocations(c(1,1,10, 1,5,20, 1,10,30, 2,5,10))\n#' clocs.is.disjoint(clocs)\n#' clocs.is.disjoint(clocs, strong=FALSE)\n#' clocs <- clocations(c(1,1,10, 1,5,30, 1,10,30, 2,5,10))\n#' clocs.is.disjoint(clocs, strong=FALSE)\n#' \nclocs.is.disjoint <- function(clocations, strong=TRUE) {\n  if (clocs.is.empty(clocations)) return(TRUE)\n  if (clocs.is.unsorted(clocations, decreasing.to=TRUE))\n    clocations <- clocs.sort(clocations, decreasing.to=TRUE)\n  if (strong) {\n    dif.chr <- diff(c(rbind(clocations[,1], clocations[,1])))\n    dif.pos <- diff(c(t(clocations[,2:3])))\n  } else {\n    dif.chr <- diff(clocations[,1])\n    dif.pos <- diff(clocations[,3])\n  }\n  ! any((dif.pos <= 0) & (dif.chr == 0))\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# clocs.join algo a (shift) - for (weakly) disjoint intervals\n# assume clocations have been sorted and are (weakly) disjoint\n#\n.clocs.join.shift <- function(clocations, delta=0L) {\n  \n  to   <- lx.head(clocations[,3], -1)\n  chrt <- lx.head(clocations[,1], -1)\n  from <- lx.tail(clocations[,2], -1)\n  chrf <- lx.tail(clocations[,1], -1)\n  \n  # joined : boolean vector TRUE on junctions\n  joined  <- c((chrf == chrt) & ((from - to - 1) <= delta), FALSE)\n\n  # nothing to do  \n  if (! any(joined)) return(clocations)\n  \n  # shifted : joined right shifted\n  shifted <- lx.shift(joined, -1, F)\n  \n  # begs -> (F)T transitions\n  begs <- (! shifted) & joined\n  # ends -> (T)F transitions\n  ends <- shifted & (! joined)\n  \n  clocations[begs,3] <- pmax(clocations[begs,3], clocations[ends,3])\n  \n  # keep boundaries\n  clocations[begs | !(joined | ends),,drop=F]\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# clocs.join algo b (reduce) - for all other cases\n#\n.clocs.join.reduce <- function(clocations, use.threads=lx.use.threads()) {\n  \n  chrs <- unique(clocations[,1])\n  \n  clocations <- clocs.rsplit(clocations)\n  \n  res <- lx.lapply(as.character(chrs), function(chr) {\n    int <- .clocs2inter(clocations[[chr]])\n    mat <- as.matrix(intervals::close_intervals(intervals::reduce(int)))\n    mat <- if (nrow(mat) != 0) cbind(as.integer(chr), mat) else clocs.matrix(NULL)\n    mat\n  }, use.threads=use.threads, mc.preschedule=FALSE)\n  \n  clocs.rbind(res)\n}\n\n# -------------------------------------------------\n#' join clocations\n#' @description\n#' join consecutive clocations that are separated by at most \\code{delta} bp,\n#' compact results and retains intervals above a specified width.\n#' @details\n#' This function joins together consecutive intervals (separated by at most\n#' \\code{delta >= 0} bp). It then compacts results to disjoint intervals\n#' and finally retains intervals above a given width.\\cr\n#' It is legal to call it with  \\code{delta = 0} in order to fusion\n#' overlapping or stricly adjacent intervals. This will produce the most\n#' compact representation of the input set of intervals and is\n#' equivalent to \\link{clocs.reduce}.\\cr\\cr\n#' The function implements two different algorithms.\\cr\n#' The first one (shift)\n#' is very efficient if the clocations are (weakly) disjoints\n#' (see \\link{clocs.is.disjoint}).\\cr\n#' The second algorithm (reduce) does not have this requirement but works more\n#' slowly on the average.\\cr\n#' The function will switch to the most appropriate\n#' algorithm by using \\link{clocs.is.disjoint}. If you know that the disjoint\n#' condition will \\bold{not} be satisfied, you may force the use of the (reduce)\n#' algorithm by using the \\code{.force.reduce} parameter.\\cr\n#' note that in all cases the result is the same, just the execution time\n#' may vary.\\cr\n#' the \\code{use.threads} parameter is only active with algorithm (reduce).\\cr\n#' Results are always sorted by increasing chromosome index, from and to \n#' positions (see \\link{clocs.sort}).\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param delta positive or zero integer. the maximal spacing between\n#' two consecutive intervals to be joined.\n#' @param minsize minimum interval width. all resulting intervals\n#' strictly smaller than \\code{minsize} are discarded.\n#' @param .force.reduce (see details).\n#' @param use.threads (see \\link{lx.use.threads}).\n#' @seealso \\link{clocs.reduce}\n#' @examples\n#' clocs <- clocations(c(1,1,10, 1,11,20, 1,20,30, 1,40,50, 1,60,70, 1,70,80, 1,90,100, 2,1,10))\n#' clocs.join(clocs)\n#' clocs.join(clocs, delta=9)\n#' clocs <- clocs.rbind(list(clocs, c(1,1,100)))\n#' clocs.join(clocs)\n#'\nclocs.join <- function(clocations, delta=0L, minsize=1L,\n                       .force.reduce=FALSE,\n                       use.threads=lx.use.threads()) {\n  \n  if (clocs.is.empty(clocations))\n    return(clocs.matrix(NULL))\n  \n  lx.stopif(delta < 0, \"delta should be >= 0\")\n  \n  if (! .force.reduce) {\n    clocations <- clocs.sort(clocations, decreasing.to=TRUE)\n    .force.reduce <- ! clocs.is.disjoint(clocations, strong=FALSE)\n  }\n  \n\n                        # ------------------\n  if (.force.reduce) {  # algo (b) : reduce\n                        # ------------------\n    clocations[,3] <- clocations[,3] + delta\n    clocations <- .clocs.join.reduce(clocations, use.threads=use.threads)\n    clocations[,3] <- clocations[,3] - delta\n                        # ------------------\n  } else {              # algo (a) : shift\n                        # ------------------\n    clocations <- .clocs.join.shift(clocations, delta=delta)\n  }\n  \n  # threshold result\n  valid <- (clocations[,3] - clocations[,2] + 1L) >= minsize\n  \n  clocs.sort(clocs.matrix(clocations[valid,,drop=FALSE]))\n}\n\n# -------------------------------------------------\n#' compactly re-represent clocations\n#' @description\n#' a set of clocations represents intervals on chromosomes.\n#' in general these intervals may overlap (partially or completely)\n#' or may be strictly adjacent.\n#' this function computes the union of all intervals on each\n#' chromosome. This will produce (strongly) disjoint intervals\n#' (see \\link{clocs.is.disjoint}) corresponding to the most compact\n#' representation of the input set of intervals. It also sorts the resulting\n#' clocations by increasing chromosome index, from and to positions.\n#' Finally only intervals above a specified width are retained.\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param minsize minimum interval width. all resulting intervals\n#' strictly smaller than \\code{minsize} are discarded.\n#' @param use.threads (see \\link{lx.use.threads})\n#' @note\n#' this is formally equivalent (and actually implemented as):\\cr\n#' \\code{clocs.join(clocations, delta=0L, minsize=minsize, use.thread=use.thread)}\\cr\n#' this function has been kept for historical reasons\n#' (and to keep open the possibility\n#' of a more efficient version in the future).\n#' @note\n#' \\code{clocs.reduce(x)} is formally equivalent to \\code{clocs.inter(x,x)}\n#' but much more efficient.\n#' @seealso \\link{clocs.join}, \\link{clocs.inter}\n#' @examples\n#' clocs <- clocations(c(1,1,10, 1,11,20, 1,20,30, 1,40,50, 1,60,70, 1,70,80, 1,90,100, 2,1,10))\n#' clocs.reduce(clocs)\n#' clocs <- clocs.rbind(list(clocs, c(1,1,100)))\n#' clocs.reduce(clocs)\n#' clocs.reduce(NULL)\n#'\nclocs.reduce <- function(clocations,\n                         minsize=1L,\n                         use.threads=lx.use.threads()) {\n  \n  clocs.join(clocations, delta=0L, minsize=minsize, use.threads=use.threads)\n}\n\n# -------------------------------------------------\n#' get overlaps from one set of clocations to another\n#' @description\n#' given two sets of clocations, indicates for each clocation of\n#' the first set which clocations from the second set it overlaps\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param over mx3 matrix of relative clocations (1-based)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a list of length nrow(clocations). the elements are vector\n#' of indices indicating which elements of the second set are overlapped.\n#' A list element of length 0 indicates no overlapping elements.\n#' @note\n#' multithreading is performed by chromosomes\n#' @seealso \\link{clocs.nearest}, \\link{clocs.included}, \\link{clocs.covered}\n#' @examples\n#' c1 <- clocations(c(1,1,10, 1,20,30, 2,1,10))\n#' clocs.overlap(c1, c1)\n#' c2 <- clocations(c(1,1,20))\n#' clocs.overlap(c1, c2)\n#' clocs.overlap(c2, c1)\n#' c2 <- clocations(c(1,1,15, 1,5,25))\n#' clocs.overlap(c1, c2)\n#' clocs.overlap(c2, c1)\n#' clocs.overlap(c1, NULL)\n#' clocs.overlap(NULL, NULL)\n#'\nclocs.overlap <- function(clocations, over,\n                          use.threads=lx.use.threads()) {\n  \n  clocations <- clocs.rsplit(clocations)\n  over <- clocs.rsplit(over)\n  \n  res <- lx.lapply(names(clocations), function(chr) {\n    in1 <- .clocs2inter(clocations[[chr]])\n    in2 <- .clocs2inter(over[[chr]])\n    intervals::interval_overlap(in1, in2)\n  }, use.threads=use.threads, mc.preschedule=FALSE)\n  \n  unlist(res, recursive=F, use.names=F)\n}\n\n# -------------------------------------------------\n#' Identify nearest member(s) in a set of clocations\n#' @description\n#' For each clocations in the \\code{from} argument,\n#' identify the nearest clocation or clocations (in case of ties)\n#' in the \\code{to} argument.\n#' @details\n#' the distance between two intervals is their spacing. So if they overlap\n#' the distance is 0.\\cr\n#' @param from nx3 matrix of relative clocations (1-based)\n#' @param to mx3 matrix of relative clocations (1-based)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return A data frame with three columns: \n#' distance_to_nearest, which_nearest, and which_overlap.\n#' the first one is NA if there are no interval at all in\n#' the \\code{to} set.\\cr\n#' The last two are lists, since there may be zero, one, \n#' or more nearest intervals in the \\code{to} set.\n#' @note\n#' multithreading is performed by chromosomes\n#' @seealso \\link{clocs.overlap}, \\link{clocs.included}, \\link{clocs.covered}\n#' @examples\n#' c1 <- clocations(c(1,5,15, 1,15,40, 1,20,30, 1,25,35, 1,60,70, 2,1,10))\n#' c2 <- clocations(c(1,1,20, 1,40,50))\n#' clocs.nearest(c1,c2)\n#' clocs.nearest(c1,NULL)\n#' clocs.nearest(NULL, NULL)\n#'\nclocs.nearest <- function(from, to,\n                          use.threads=lx.use.threads()) {\n  \n  from <- clocs.rsplit(from)\n  to   <- clocs.rsplit(to)\n  \n  res <- lx.lapply(names(clocations), function(chr) {\n    in1 <- .clocs2inter(from[[chr]])\n    in2 <- .clocs2inter(to[[chr]])\n    intervals::which_nearest(in1, in2)\n  }, use.threads=use.threads, mc.preschedule=FALSE)\n  \n  do.call(rbind, res)\n}\n\n# -------------------------------------------------\n#' assess inclusion from one set of clocations to another\n#' @description\n#' given two sets of clocations, indicates for each clocation of\n#' the first set if it is included in at least one clocation of the\n#' second set.\n#' @param clocations nx3 matrix of clocations to be tested.\n#' @param include nx3 matrix of clocations to search in\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return logical vector of length nrow(clocations)\n#' @seealso \\link{clocs.covered}, \\link{clocs.overlap}\n#' @examples\n#' c1 <- clocations(c(1,1,10))\n#' c2 <- clocations(c(1,1,5, 1,6,10))\n#' clocs.included(c1, c2)\n#' clocs.included(c2, c1)\n#' c1 <- clocations(c(1,1,10, 1,20,30, 2,10,20))\n#' c2  <- clocations(c(1,1,20, 1,25,30))\n#' clocs.included(c1, c2)\n#' clocs.included(c2, c1)\n#' clocs.included(c1, NULL)\n#' clocs.included(NULL, NULL)\n#' # the difference with clocs.covered is in the reduction of the second argument\n#' c1 <- clocations(c(1,20,30))\n#' c2 <- clocations(c(1,1,25, 1,25,40))\n#' clocs.included(c1, c2)\n#' clocs.covered(c1, c2)\n#' clocs.included(c1, clocs.reduce(c2))\n#'\nclocs.included <- function(clocations, include,\n                           use.threads=lx.use.threads()) {\n  \n  .included <- function(c1, c2) (c1[[2]] >= c2[[2]]) && (c1[[3]] <= c2[[3]])\n  \n  over <- clocs.overlap(clocations, include)\n  \n  res <- lx.lapply(seq_along(over), function(i) {\n    any(sapply(over[[i]], function(j) .included(clocations[i,], include[j,])))\n  }, use.threads=use.threads, mc.preschedule=TRUE)\n\n  unlist(res, recursive=F, use.names=F)\n}\n\n# -------------------------------------------------\n#' assess coverage from one set of clocations by another\n#' @description\n#' this is a variant of \\link{clocs.included} which test if clocations\n#' from the first set are fully covered by intervals in the second\n#' set.\n#' @details this is functionnaly equivalent to\n#' \\code{clocs.included(clocations, clocs.reduce(cover))}.\n#' i.e. the second set is first reduced (see \\link{clocs.reduce}) to\n#' disjoint intervals then the inclusion test (see \\link{clocs.included})\n#' is performed. But is implemented in a more efficient way, especially\n#' when \\code{cover} is already disjoint.\n#' @param clocations nx3 matrix of clocations to be tested.\n#' @param cover nx3 matrix of clocations to search in\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return logical vector of length nrow(clocations)\n#' @note if \\code{cover} is already disjoint, this is equivalent to\n#' \\link{clocs.included} but much more efficient.\n#' @seealso \\link{clocs.included}, \\link{clocs.reduce}, \\link{clocs.overlap}\n#' @examples\n#' c1 <- clocations(c(1,1,10))\n#' c2 <- clocations(c(1,1,5, 1,6,10))\n#' clocs.covered(c1, c2)\n#' clocs.covered(c2, c1)\n#' c1 <- clocations(c(1,1,10, 1,20,30, 2,10,20))\n#' c2  <- clocations(c(1,1,20, 1,25,30))\n#' clocs.covered(c1, c2)\n#' clocs.covered(c2, c1)\n#' clocs.covered(c1, NULL)\n#' clocs.covered(NULL, NULL)\n#' # the difference with clocs.covered is in the reduction of the second argument\n#' c1 <- clocations(c(1,20,30))\n#' c2 <- clocations(c(1,1,25, 1,25,40))\n#' clocs.covered(c1, c2)\n#' clocs.included(c1, c2)\n#' clocs.included(c1, clocs.reduce(c2))\n#'\nclocs.covered <- function(clocations, cover,\n                         use.threads=lx.use.threads()) {\n  \n  if (clocs.is.empty(cover))\n    return(rep(FALSE, nrow(clocations(clocations))))\n                                    \n  if (clocs.is.unsorted(cover, decreasing.to=TRUE))\n    cover <- clocs.sort(cover, decreasing.to=TRUE)\n\n  if (! clocs.is.disjoint(cover))\n    cover <- clocs.reduce(cover, use.threads=use.threads)\n  \n  cover[,3] <- cover[,3] + 1\n  \n  cover <- split(as.vector(t(cover[,2:3])), rep(cover[,1], each=2))\n  \n  is.point <- all(clocations[,2] == clocations[,3])\n\n  apply.clocs(clocations, function(clocs, handle) {\n    chr <- as.character(clocs[1,1])\n    from.ok <- findInterval(clocs[,2], cover[[chr]])\n    ok <- (from.ok %% 2 == 1)\n    if (! is.point) {\n      to.ok   <- findInterval(clocs[,3], cover[[chr]])\n      ok <- ok & (from.ok == to.ok)\n    }\n    ok\n  }, handle=NULL, flatten=T, use.threads=use.threads)\n}\n\n# -------------------------------------------------\n# <internal not exported>\n# compute intervals operation on two sets of clocations\n# oper = intervals::interval_intersection or intervals::interval_union\n# see clocs.inter and clocs.union below\n#\n.clocs.oper <- function(clocations1, clocations2, chrs, oper,\n                        minsize=1L, use.threads=lx.use.threads()) {\n\n  opname <- as.character(lx.args('oper')[1])\n\n  clocations1 <- clocs.rsplit(clocations1)\n  clocations2 <- clocs.rsplit(clocations2)\n\n  res <- lx.lapply(as.character(chrs), function(chr) {\n    lx.out(\"running \", opname, \" on regions of chr: \", chr, up.frame=1, level=\"debug\")\n    in1 <- .clocs2inter(clocations1[[chr]])\n    in2 <- .clocs2inter(clocations2[[chr]])\n    in1 <- oper(in1, in2) # keep oper out of next call\n    mat <- as.matrix(intervals::close_intervals(in1))\n    mat <- mat[(mat[,2] - mat[,1] + 1L) >= minsize,, drop=FALSE]\n    mat <- if (nrow(mat) != 0) cbind(as.integer(chr), mat) else clocs.matrix(NULL)\n    mat\n  }, use.threads=use.threads, mc.preschedule=FALSE)\n\n  clocs.rbind(res)\n}\n\n# -------------------------------------------------\n#' compute the intersection of two sets of clocations \n#' @description\n#' each set of clocations represents intervals on chromosomes.\n#' this function intersects (by chromosome) all intervals from the first set\n#' with all intervals from the second set and retains intervals\n#' above a specified width.\\cr\n#' @param clocations1 nx3 matrix of relative clocations (1-based)\n#' @param clocations2 mx3 matrix of relative clocations (1-based)\n#' @param minsize minimum interval width (see details)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return kx3 matrix of relative clocations (1-based)\n#' @details\n#' minsize parameter: all resulting intervals strictly smaller than \\code{minsize} are discarded\n#' @note\n#' intersecting a set with itself is formally equivalent to calling \\link{clocs.reduce}\n#' @note\n#' multithreading is performed by chromosomes\n#' @examples\n#' c1 <- clocations(c(1,1,10, 1,20,30, 2,1,10))\n#' c2 <- clocations(c(1,5,15, 1,10,25))\n#' clocs.inter(c1, c2)\n#' clocs.inter(c2, c1)\n#' identical(clocs.inter(c2,c2), clocs.reduce(c2))\n#' clocs.inter(c1, NULL)\n#' clocs.inter(NULL, NULL)\n#'\nclocs.inter <- function(clocations1, clocations2,\n                        minsize=1L, use.threads=lx.use.threads()) {\n\n  if (clocs.is.empty(clocations1) || clocs.is.empty(clocations2))\n      return(clocs.matrix(NULL))\n\n  chrs <- intersect(unique(clocations1[,1]), unique(clocations2[,1]))\n\n  .clocs.oper(clocations1, clocations2, chrs,\n              intervals::interval_intersection,\n              minsize=minsize, use.threads=use.threads)\n}\n\n# -------------------------------------------------\n#' compute the union of two sets of clocations \n#' @description\n#' each set of clocations represents intervals on chromosomes.\n#' this function makes union (by chromosome) of all intervals\n#' from the first set and all intervals from the second set and retains intervals\n#' above a specified width.\\cr\n#' @param clocations1 nx3 matrix of relative clocations (1-based)\n#' @param clocations2 mx3 matrix of relative clocations (1-based)\n#' @param minsize minimum interval width (see details)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return kx3 matrix of relative clocations (1-based)\n#' @details\n#' minsize parameter: all resulting intervals strictly smaller than \\code{minsize} are discarded\n#' @note\n#' this is formally equivalent to concatenating (by \\link{clocs.rbind}) the two sets \n#' and calling \\link{clocs.reduce} but much more efficient.\n#' @note\n#' multithreading is performed by chromosomes\n#' @examples\n#' c1 <- clocations(c(1,1,10, 1,20,30, 2,1,10))\n#' c2 <- clocations(c(1,5,15, 1,10,25))\n#' clocs.union(c1, c2)\n#' identical(clocs.union(c1, c2), clocs.reduce(clocs.rbind(list(c1, c2))))\n#' identical(clocs.union(c1, NULL), c1)\n#' clocs.union(NULL, NULL)\n#'\nclocs.union <- function(clocations1, clocations2,\n                        minsize=1L, use.threads=lx.use.threads()) {\n\n  if (clocs.is.empty(clocations1)) clocations1 <- clocs.matrix(NULL)\n  if (clocs.is.empty(clocations2)) clocations2 <- clocs.matrix(NULL)\n  \n  if (clocs.is.empty(clocations1) && clocs.is.empty(clocations2))\n    return(clocs.matrix(NULL))\n\n  chrs <- union(unique(clocations1[,1]), unique(clocations2[,1]))\n\n  .clocs.oper(clocations1, clocations2, chrs,\n              intervals::interval_union,\n              minsize=minsize, use.threads=use.threads)\n}\n\n# -------------------------------------------------\n#' filter clocations by size\n#' @description\n#' keep only clocations which size \\code{(w=to-from+1)} is greater\n#' or equal to \\code{minsize}.\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param reduce perform a \\link{clocs.reduce} first\n#' @param minsize minimum width\n#' @param use.threads (see \\link{lx.use.threads}) (only used if reduce==TRUE)\n#' @examples\n#' c1 <- clocations(c(1,1,5, 1,20,30, 2,1,10))\n#' identical(clocs.threshold(c1, minsize=0), c1)\n#' clocs.threshold(c1, minsize=10)\n#' clocs.threshold(c1, minsize=30)\n#' clocs.threshold(NULL)\n#'\nclocs.threshold <- function(clocations, minsize=1L, reduce=TRUE,\n                            use.threads=lx.use.threads()) {\n  if (reduce)\n    clocations <- clocs.reduce(clocations, use.threads=use.threads)\n  valid <- (clocations[,3] - clocations[,2] + 1L) >= minsize\n  clocs.matrix(clocations[valid,,drop=FALSE])\n}\n\n# -------------------------------------------------\n#' transform a matrix of clocations to bitfield(s)\n#' @description\n#' transform a matrix of clocations to bit bitfield(s) of \n#' allowed positions on specified chromosome(s).\\cr\n#' bitfield(s) are defined in \\code{bit} library\\cr\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param clocations nx3 matrix of relative clocations (1-based)\n#' @param chrs vector (possibly scalar) of chromosome indexes (not names) to work on\n#' @param save.mem save memory at expense of speed (see details)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return named list (possibly of size 0) of bitfields\n#' @details\n#' by default, this function internally works using logicals.\n#' This requires N bytes of memory per chromosome, \n#' where N is the size of each chromosome.\n#' The \\code{save.mem} parameter will force using bitfields internally.\n#' This results in a 30 fold reduction of memory size at expense of speed.\n#' If memory is short, also consider using \\code{use.threads = FALSE} to\n#' proceed each chromosome sequentially.\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' slocs <- c(\"seq1:1-10\", \"seq1:15-20\", \"seq2:2-5\") \n#' clocs <- clocs.matrix(lapply(slocs, sloc2cloc, handle=fh))\n#' bits <- clocs2bits(fh, clocs)\n#' empty <- clocs2bits(fh, clocs.matrix(NULL))\n#' basta.close(fh)\n#\nclocs2bits <- function(handle, clocations, chrs=unique(clocations[,1]),\n                       save.mem=FALSE, use.threads=lx.use.threads()) {\n\n  use.threads = use.threads && (length(chrs) > 1)\n  \n  clocations <- clocations[clocations[,1] %in% chrs,,drop=FALSE]\n  \n  clocations <- clocs.rsplit(clocations)\n\n  lx.out(\"computing bits on chrs: [\", paste(names(clocations), collapse=', '), \"]\")\n  res <- lx.napply(clocations, function(chr, clocs) {\n     chr <- as.integer(chr)\n     lx.out(\"  computing bits on chrindex: \", chr, level=\"debug\")\n     size <- handle$header$seq[[chr]]$size\n     clocs[,2] <- pmax(1, clocs[,2])\n     clocs[,3] <- pmin(size, clocs[,3])\n     res <- if (save.mem) bit::bit(size) else logical(size)\n     for (i in seq_len(nrow(clocs)))\n       res[clocs[i,2]:clocs[i,3]] <- TRUE\n     bit::as.bit(res)\n  }, use.threads=use.threads, mc.preschedule=FALSE, SIMPLIFY=FALSE)\n\n  res\n}\n\n# -------------------------------------------------\n#' find runs of TRUE's in bitfield\n#' @description\n#' considering a single bitfield (usually representing\n#' allowed positions on a chromosome), this function\n#' will recover all runs of TRUE (larger than the given\n#' threshold) and return them as a nx3 matrix of clocations\n#' (with specified chromosome index \\code{chr}).\n#' @param bit a bitfield (see package bit)\n#' @param chr default chrindex\n#' @param minsize minimum number of consecutive TRUE to report (see details)\n#' @param p0 region origin (see details)\n#' @param delta region size factor (see details)\n#' @return nx3 matrix of clocations\n#' @details\n#' \\code{p0} and \\code{delta} are two parameters to transform indices\n#' in bitfileds into actual positions on chromosomes according to:\\cr\n#'  \\code{       pos = p0 + (i-1) * delta}\\cr\n#' this is useful when indices actually correspond to binned values\n#' (delta=binsize) or to regions that do not start at 1\n#' (p0 = from).\\cr\n#' when using delta!=1, the minsize parameter is interpreted with the\n#' transformation applied (e.g with delta=1000 and minsize=1000, a single\n#' TRUE will actually pass the test)\n#' @seealso \\link{bits2clocs} for a list version\n#' @examples\n#' b <- bit::as.bit(c(TRUE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE,TRUE,FALSE))\n#' runs2clocs(b)\n#' runs2clocs(b, minsize=3)\n#' runs2clocs(b, delta=1000, minsize=1000) \n#' runs2clocs(b, delta=1000, minsize=2000) \n#'\nruns2clocs <- function(bit, chr=0, minsize=1L, p0=1L, delta=1L) {\n  if (lx.warnif(! bit::is.bit(bit), 'runs2clocs requires a bit::bit object'))\n    return(clocs.matrix(NULL))\n\n  .fact <- function(i) {p0 + (i-1) * delta}\n    \n  left  <- c(bit::as.bit(FALSE), bit)\n  right <- c(bit, bit::as.bit(FALSE))\n\n  begs <- .fact(bit::as.which(right & ! left))\n  ends <- .fact(bit::as.which(left  & ! right) - 1L) + delta - 1\n\n  val <- (ends - begs + 1) >= minsize\n  res <- if (sum(val) == 0) NULL else cbind(as.integer(chr), begs[val], ends[val])\n  \n  clocs.matrix(res)\n}\n\n# -------------------------------------------------\n#' transform bitfields into matrix of clocations\n#' @description\n#' considering a \\bold{list of bitfields} (each of them representing\n#' allowed positions on a chromosome), this function\n#' will recover runs of TRUE's (larger than the given\n#' threshold) on each of them and return them as a nx3 matrix of clocations.\n#' the input list should be named by the chromosome indexes.\n#' @param bits named list of bitfields (see note)\n#' @param minsize minimum region size\n#' @param p0 region origin (see details)\n#' @param delta region size factor (see details)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a matrix of clocations\n#' @seealso \\link{runs2clocs} for single bitfield version\n#' @details\n#' names of the \\code{bits} parameter are chromosome indexes\n#' (in order to put them into clocations)\\cr\n#' \\code{p0} and \\code{delta} are two parameters to transform indices\n#' of TRUE's in bitfields into actual positions on chromosomes according to:\\cr\n#'  \\code{       pos = p0 + (i-1) * delta}\\cr\n#' this is useful when indices actually correspond to binned values\n#' (delta=binsize) or to regions that do not start at 1\n#' (p0 = from)\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' slocs <- c(\"seq1:1-10\", \"seq1:15-20\", \"seq2:2-3\") \n#' clocs <- clocs.matrix(lapply(slocs, sloc2cloc, handle=fh))\n#' bits <- clocs2bits(fh, clocs)\n#' rclocs <- bits2clocs(bits)\n#' identical(clocs, rclocs)\n#' rclocs <- bits2clocs(bits, 5)\n#' rclocs <- bits2clocs(bits, 50)\n#' bits[[1]] <- bit::bit(length(bits[[1]]))\n#' rclocs <- bits2clocs(bits)\n#' bits[[2]] <- bit::bit(length(bits[[2]]))\n#' rclocs <- bits2clocs(bits)\n#' basta.close(fh)\n#'\nbits2clocs <- function(bits, minsize=1L, p0=1L, delta=1L,\n                       use.threads=lx.use.threads()) {\n\n  use.threads = use.threads && (length(bits) > 1)\n    \n  lx.out(\"computing clocs on chrs: [\", paste(names(bits), collapse=\", \"), \"]\")\n    \n  res <- lx.napply(bits, function(chr, b) {\n    lx.out(\"  computing clocs on chr: \", chr, level=\"debug\")\n    runs2clocs(b, chr=chr, minsize=minsize, p0=p0, delta=delta)\n  }, use.threads=use.threads, mc.preschedule=FALSE, SIMPLIFY=FALSE)\n    \n  clocs.rbind(res)\n}\n\n# -------------------------------------------------\n#' sample absolute point locations on chromosomes\n#' @description\n#' sample locations within regions specified by clocations.\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param clocations regions where we can sample (endpoints included)\n#' @param size number of points to sample\n#' @param replace sample with replacement (see \\link{lx.sample})\n#' @return vector of \\code{size} absolute point coordinates.\n#' (see \\link{coords2clocs} to transform into clocations)\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs <- basta2clocs(fh)\n#' samp <- coords.sample(fh, clocs, size=10)\n#' coords2clocs(fh, sort(samp))\n#' basta.close(fh)\n#' @note\n#' if replace=FALSE and N, the number of points in the union\n#' of all regions, is less than 2*size then downsample to N/2 points\n#'\ncoords.sample <- function(handle, clocations, size=1000000L, replace=FALSE) {\n\n   coords <- clocs2coords(handle, clocations)\n   lens   <- coords[,2] - coords[,1] + 1\n   \n   #\n   # determine total region size\n   #\n   tot.size <- sum(lens)\n   lx.out(\"sampling \", nrow(clocations), \" regions of total size \", tot.size, \" bp\")\n   if ((! replace) && (tot.size < (2*size))) {\n     lx.warn(\"not enough region space to sample \", size, \" with replace=FALSE\",\n             \" downsampling to \", tot.size/2)\n     size <- tot.size / 2\n   }\n\n   #\n   # sample uniformly\n   #\n   picks <- ceiling(lens * size / tot.size)\n   \n   samp <- lx.mapply(function(f, l, p) {\n                f - 1 + sample(l, size=p, replace=replace)\n           }, coords[,1], lens, picks, use.threads=FALSE)\n   \n   #\n   # resample using prob weights = region length\n   # for sampling correction.\n   #\n   # here, it is important to use lx.sample and not base::sample.\n   # when replace=FALSE this is much quicker.\n   #\n\n   lx.out(\"resampling to size \", size)\n   prob <- lx.mapply(function(l, p) {\n                rep(l,p)\n            }, lens, picks, use.threads=FALSE)\n\n   samp <- unlist(samp, use.names=FALSE)\n   prob <- unlist(prob, use.names=FALSE)\n\n   if (length(samp) <= 1)\n     return(samp)\n   \n   # open question: should we sample with replace=replace \n   # or replace=FALSE here ?\n   \n   lx.sample(samp, size=size, prob=prob, replace=replace)\n}\n\n",
    "created" : 1497365417968.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4246871308",
    "id" : "B138CDEF",
    "lastKnownWriteTime" : 1502733481,
    "last_content_update" : 1502733481,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/xlx/R/xlx.coords.r",
    "project_path" : "R/xlx.coords.r",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}