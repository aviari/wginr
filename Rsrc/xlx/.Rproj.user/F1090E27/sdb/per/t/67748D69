{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: xlx.bbaf.r 237 2017-06-18 07:59:51Z viari $\n# xlx baf format\n#\n\n# -------------------------------------------------\n#' @name HELP.BAF\n#' @docType data\n#' @title Baf format\n#' @description\n#' Baf is a binary format to compactly represents reads alignments\n#' from bam files. It basically only keeps the information about\n#' each allele counts at each position of the chromosomes\n#' (all other information such as alignement quality, CIGAR etc...\n#' is discarded). It can therefore be used to retrieve allelic frequencies,\n#' total cover (sum of all alleles) or GC content (sum of G and C alleles).\n#' \n#' This is a little endian binary file composed of\n#' a header:\\cr\n#' \\tabular{lll}{\n#' int32 \\tab 0x62696d31 \\tab magic number ('baf1')\\cr\n#' int32 \\tab nbseq \\tab number of sequences\\cr\n#' ---- \\tab ------------ \\tab -------\\cr\n#' \\tab \\tab repeat nbseq times\\cr\n#' ---- \\tab ------------ \\tab -------\\cr\n#' string \\tab namei \\tab name of sequence i (see 1)\\cr\n#' int64 \\tab sizei \\tab length of sequence i\\cr\n#' int32 \\tab codei \\tab encoding size in bytes for this sequence (0, 1,2,4)\\cr\n#' ---- \\tab ------------ \\tab -------\\cr\n#' }\n#' followed by the concatenation of nbseq arrays each of\n#' 4 * sizei * codei bytes. each codei bytes (codei=1,2 or4)\n#' represent total number of read bases (i.e non counting deletions) covering \n#' each position.\\cr\n#' (codei=1: unsigned char, codei=2: unsigned short, codei=4: unsigned int32,\n#' and codei=0 means that all counts on this chromosome are 0)\\cr.\n#'\n#' (1) string format is:\n#' \\tabular{lll}{\n#' int32 \\tab size \\tab string length\\cr\n#' bytes \\tab size + 1 \\tab NULL terminated char array\\cr\n#'}\n#'\n#' @note\n#' When opening a baf file, the header is loaded\n#' into memory but not the count arrays. Counts\n#' will be directly accessed from disk when needed.\n#'\n#' @note\n#' Conversion from bam to baf is performed by the\n#' external C executable \\code{bam2baf} provided\n#' in Csrc directory.\n#'\n#' @note\n#' Baf header is compatible with Basta header (see \\link{HELP.BASTA})\n#' and Baf handles can therefore be passed as the handle argument of\n#' most functions accepting a Basta handle (except of course for\n#' those that need to access to sequence).\n#'\n#' @note\n#' of course when using together a Basta and a Baf file, you should ensure\n#' that sequences in both header are stricly identical. In practice this means that\n#' the Bam file from which the baf file was generated was built using\n#' the same fasta sequences from which the Basta file was generated.\\cr\n## see \\link{baf.is.basta} to check coherency\n#'\nNULL\n\n# =================================================\n# globals\n# =================================================\n\n.baf.MAGIC   <- 0x62616631  # 'baf1'\n\n# =================================================\n# internals <no_export>\n# =================================================\n\n# -------------------------------------------------\n# <internal> <no_export>\n# read baf header\n#  this is an internal function (used in baf.open)\n#  and not exported\n#\n.baf.read.header <- function(handle) {\n\n  header <- list()\n  \n  header$magic = lx.read.int32(handle)\n  lx.stopif(header$magic != .baf.MAGIC, \"bad magic header\")\n\n  header$nbseq <- lx.read.int32(handle)\n  \n  header$seq <- list()\n  header$baseoffset <- 8\n  off.read <- off.seq <- 0\n  \n  for (e in 1:header$nbseq) {\n    nam <- lx.read.string(handle)\n    siz <- lx.read.int64(handle)\n    cod <- lx.read.int32(handle)\n    header$seq[[nam]] <- list(index=e, name=nam, size=siz, code=cod,\n                              off.read=off.read,\n                              off.seq=off.seq,\n                              offset=off.seq)\n    header$baseoffset <- header$baseoffset + nchar(nam) + 17\n    lx.out(\"header: index=\", e, \" name=\", nam, \" size=\", siz,\n           \" encode=\", cod,\n           \" off.read=\", off.read,\n           \" off.seq=\", off.seq,\n           level=\"debug\", up.frame=1)\n    off.read <- off.read + 4 * siz * cod\n    off.seq <- off.seq + siz\n  }\n  \n  # keep offsets and sizes to speedup some operations\n  \n  header$off.reads <- sapply(header$seq, function(x) x$off.read)\n  header$off.seqs  <- sapply(header$seq, function(x) x$off.seq)\n  header$sizes     <- sapply(header$seq, function(x) x$size)\n\n  # for compatibility with basta$header\n  header$offsets   <- header$off.seqs \n\n  handle$header <- header\n  handle\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# read n read counts from baf file starting at given\n# offset.\n# reads 4*n elements (one element for each base in order 'A', 'C', 'G', 'T')\n# and return an integer matrix of size nx4\n#\n.baf.fetch <- function(handle, offset, n, code) {\n  if (code == 0) \n    fun <- function(h,n,signed=F) rep(0, n)\n  else if (code == 1)\n    fun <- lx.read.int8\n  else if (code == 2)\n    fun <- lx.read.int16\n  else\n    fun <- lx.read.int32\n\n  lx.seek(handle, offset)\n  \n  res <- fun(handle, n=4*n, signed=F)\n  \n  res <- matrix(res, ncol=4, byrow=T, dimnames=list(NULL, c('A','C','G','T')))\n  \n  lx.out(\"fetched : \", nrow(res), \" sites\", level=\"debug\", with.mem=TRUE)\n  \n  res\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# determine mincov based on quantile\n# count : nx4 count matrix\n# quant : quantile * 1000\n#\n.mincov <- function(count, quant) {\n  count <- rowSums(count)\n  count <- count[count != 0]\n  mincov <- max(0, quantile(count,  abs(quant/1000)))\n  lx.out(\"mincov = \", mincov, \" [\", length(count), \" data points]\", level=\"debug\")\n  mincov\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# empty matrix\n#\n.empty.mat <- function() {\n  matrix(integer(0), ncol=4, nrow=0, dimnames=list(NULL, c('A','C','G','T')))\n}\n\n\n# =================================================\n# API\n# =================================================\n\n# -------------------------------------------------\n#' open baf file\n#' @description\n#' open baf file for reading\n#' @param filename baf file name\n#' @return baf file handle\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.close(baf)\n#'\nbaf.open <- function(filename) {\n  handle <- lx.open(filename)\n  handle <- .baf.read.header(handle)\n  handle$type <- \"baf\"\n  \n  handle\n}\n\n# -------------------------------------------------\n#' close baf file\n#' @description\n#' same as \\link{lx.close}\n#' @param handle file handle (opened by \\link{baf.open})\n#'\nbaf.close <- lx.close\n\n# -------------------------------------------------\n#' convert seqname to seqindex\n#' @description\n#' convert seqname to seqindex.\\cr\n#' see \\link{basta.name2index} this is the same function\n#' @inheritParams basta.name2index\n#'\nbaf.name2index <- basta.name2index\n\n# -------------------------------------------------\n#' convert seqindex to seqname\n#' @description\n#' convert seqindex to seqname.\\cr\n#' see \\link{basta.index2name} this is the same function\n#' @inheritParams basta.index2name\n#'\nbaf.index2name <- basta.index2name\n\n# -------------------------------------------------\n#' fetch allele counts\n#' @description\n#' fetch allele counts using absolute coordinates.\\cr\n#' \\code{coord} defines a region on a chromosome. this function\n#' returns a count matrix (with 4 columns) of\n#' the number of symbols at each position within the region.\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param coord absolute sequence coordinates (c(absfrom, absto)) (1-based)\n#'               or a single position absfrom (this implies absto=absfrom)\n#' @return integer matrix of size n x 4 containing allele counts.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.fetch.cloc}, \\link{baf.bin.coord},\n#' \\link{baf.fetch.points.chr}, \\link{baf.heterozygous.coord}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.fetch.coord(baf, c(33725, 33732))\n#' i <- baf.name2index(baf, \"machaon\")\n#' baf.fetch.cloc(baf, c(i, 560, 567))\n#' baf.close(baf)\n#' \nbaf.fetch.coord <- function(handle, coord) {\n\n  if (length(coord) == 1) coord <- c(coord, coord)\n\n  off <- handle$header$off.seqs\n\n  ifrom <- findInterval(coord[1] - 1, off)\n  ito   <- findInterval(coord[2] - 1, off)\n  \n  if (ifrom != ito) {\n    lx.warn(\"coordinates overlap chromosomes\")\n    return(NULL)\n  }\n\n  seq <- handle$header$seq[[ifrom]]\n\n  coord <- coord - seq$off.seq\n  \n  off <- handle$header$baseoffset + seq$off.read + 4 * (seq$code * (coord[1] - 1))\n\n  .baf.fetch(handle, off, coord[2] - coord[1] + 1, seq$code)\n}\n\n# -------------------------------------------------\n#' fetch allele counts\n#' @description\n#' fetch allele counts using using relative coordinates.\\cr\n#' \\code{cloc} defines a region on a chromosome. this function\n#' returns a count matrix (with 4 columns) of\n#' the number of symbols at each position within the region.\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param clocation relative clocation = c(seqname, from, to) (1-based)\n#' @return integer matrix of size n x 4 containing allele counts.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.fetch.coord}, \\link{baf.bin.cloc},\n#' \\link{baf.fetch.points.chr}, \\link{baf.heterozygous.cloc}\n#' \n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.fetch.coord(baf, c(33725, 33732))\n#' i <- baf.name2index(baf, \"machaon\")\n#' baf.fetch.cloc(baf, c(i, 560, 567))\n#' baf.close(baf)\n#'\nbaf.fetch.cloc <- function(handle, clocation) {\n  coord <- cloc2coord(handle, clocation)\n  baf.fetch.coord(handle, coord)\n}\n\n# -------------------------------------------------\n#' fetch allele counts\n#' @description\n#' fetch allele counts at several relative point locations\n#' on the same chromosome.\\cr\n#' \\code{relpts} is a set of relative \\bold{point} positions on the same chromosome.\n#' this function returns a count matrix (with 4 columns) of\n#' the number of symbols at each position.\n#' this formaly equivalent to:\\cr\n#' \\code{clocs <- lapply(relpts, function(x) c(chrindex, x, x))}\\cr\n#' \\code{do.call(rbind, lapply(clocs, baf.fetch.cloc, handle=handle))}\\cr\n#' but is much quicker when relpts vector is large and values\n#' span most of the chromosome.\\cr\n#' The idea is to load the allele\n#' counts by chunks of size \\code{.chunk.size} instead of accessing each\n#' location individually (thus reducing disk access overhead).\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param chr chromosome index (if integer) or chromosome name (if character)\n#' @param relpts vector of relative positions (1-based) on this\n#' chromosome\n#' @param .chunk.size <internal parameter> size of chunk. changing this parameter\n#' will only affect time or memory used, not result.\n#' @return integer matrix of size n x 4 containing allele counts.\n#' @seealso \\link{baf.fetch.cloc}, \\link{baf.fetch.coord} \n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' x <- baf.fetch.points.chr(baf, 3, 550:570)\n#' y <- baf.fetch.points.chr(baf, 3, 550:570, .chunk.size=1)\n#' identical(x, y)\n#' baf.close(baf)\n#'\nbaf.fetch.points.chr <- function(handle, chr, relpts, .chunk.size=1000000L) {\n\n  if (length(relpts) == 0)\n    return(.empty.mat())\n  \n  chrindex <- if (is.character(chr)) baf.name2index(handle, chr) else chr\n  lx.out(\"fetching \", length(relpts), \" points on chr index \", chrindex, level=\"debug\")\n  chr.size <- handle$header$seq[[chrindex]]$size\n  chunk.size <- min(chr.size, .chunk.size)\n\n  chunk.from <- seq.int(min(relpts), min(chr.size, max(relpts)), by=chunk.size)\n\n  #\n  # keep initial points order\n  #\n  ptorder <- order(relpts)\n  relpts <- relpts[ptorder]\n\n  #\n  # split into chunks (this will reorder points)\n  #\n  lx.out(\"  splitting in \", length(chunk.from), \" chunks\", level=\"debug\")\n  chunk.indx <- split(relpts, factor(findInterval(relpts, chunk.from),\n                                     levels=seq_along(chunk.from)))\n                                     \n  chunk.clocs <- lapply(chunk.from, function(x) {\n                        as.integer(c(chrindex, x, min(x+chunk.size-1, chr.size)))\n                        })\n\n  chunks <- mapply(function(x, y) {\n                        list(cloc=x, pos=y)\n                        }, chunk.clocs, chunk.indx, SIMPLIFY=FALSE)\n  #\n  # load chunks in turn and get counts for positions in each chunk\n  #\n  .load <- function(chunk) {\n     count <- if (length(chunk$pos) == 0) c()\n            else baf.fetch.cloc(handle, chunk$cloc)\n     count[chunk$pos - chunk$cloc[2] + 1,,drop=F]\n  }\n  \n  lx.out(\"  loading in \", length(chunks), \" chunks\", level=\"debug\")\n  res <- lapply(chunks, .load)\n\n  lx.out(\"  binding results\", level=\"debug\")\n  res <- do.call(rbind, res)\n\n  #\n  # put points back in initial order\n  #\n  lx.out(\"  reshaping results\", level=\"debug\")\n  res <- res[order(ptorder),,drop=F]\n  \n  res\n}\n\n# -------------------------------------------------\n#' binning coverage or GC content using absolute coordinates\n#' @description\n#' \\code{coord} defines a region on a chromosome. this function\n#' collects coverage or GC content by bins of width \\code{binsize} within the region.\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param coord absolute sequence coordinates (c(absfrom, absto)) (1-based)\n#'        or a single position absfrom (this implies absto=absfrom)\n#' @param binsize size of bins\n#' @param what what to collect \"coverage\" or \"gc\" (may be abrreviated)\n#' @param fun collect function (e.g. sum, mean, median, user-closure, ...) see details.\n#' @param drop drop the last element of result if region width is not a muliple\n#'        of binsize\n#' @param na.gc boolean to specify how to handle GC content for positions with\n#'        0 coverage. na.gc = TRUE will produce 0/0 = NA and na.gc = FALSE\n#'        will produce 0/0 = 0.\n#' @param ... optional arguments to be passed to \\code{fun}\n#' @param .quick use a quicker algorithm (valid for fun=sum or fun=mean only and\n#'        na.gc=FALSE) at the expense of memory overhead.\n#' @return numeric vector of size n containing binned cover or gc content\n#' @details\n#' let us note allele.counts the binsize x 4 matrix of alleles counts in each\n#' bin.\\cr\n#' if (what==\"cover\") then fun(coverage) is collected in each bin,\\cr\n#' with coverage = rowSums(allele.counts)\\cr\\cr\n#' if (what==\"gc\") then fun(gc.line) is collected in each bin,\\cr\n#' with gc.line = rowSums(GC.allele.counts) / rowSums(allele.counts).\n#' (with a special treatment of NA's. see below)\\cr\n#' Therefore fun=sum will produce the number of GC alleles in bin and \n#' fun=mean will produce the \\%GC. Note that functions other than sum\n#' or mean are usually meaningless with what==\"gc\"\\cr\\cr\n#' \\code{fun} can be any function or user-supplied closure\n#' taking a numerical vector as input and returning a scalar.\\cr\\cr\n#' the \\code{na.gc} parameter is intended to handle the special case where\n#' coverage=0 at a position.\\cr\n#' Then the computed gc.line at this position is\n#' NA if na.gc=TRUE, and 0 if na.gc=FALSE.\\cr\n#' Please note that na.gc=TRUE will disable quick mode.\\cr\\cr\n#' the \\code{drop} parameter handles the last bin when \n#' region width is not a muliple of binsize.\\cr\n#' if drop=TRUE then the last (incomplete) bin is omited.\n#' if drop=FALSE then the last (incomplete) bin is included.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.fetch.coord} \\link{baf.bin.cloc}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.fetch.coord(baf, c(33725, 33730))\n#' # 'fun' usage\n#' baf.bin.coord(baf, c(33725, 33730), 3) # sum\n#' baf.bin.coord(baf, c(33725, 33730), 3, fun=mean)\n#' baf.bin.coord(baf, c(33725, 33730), 3, fun=median)\n#' # 'na.gc' usage\n#' baf.bin.coord(baf, c(33725, 33730), 3, what=\"gc\")\n#' baf.bin.coord(baf, c(33725, 33730), 3, what=\"gc\", na.gc=TRUE)\n#' baf.bin.coord(baf, c(33725, 33730), 3, what=\"gc\", na.gc=TRUE, na.rm=TRUE)\n#' # 'drop' usage\n#' baf.bin.coord(baf, c(33725, 33730), 4)\n#' baf.bin.coord(baf, c(33725, 33730), 4, drop=FALSE)\n#' baf.bin.coord(baf, c(33725, 33730), 10)\n#' baf.bin.coord(baf, c(33725, 33730), 10, drop=FALSE)\n#' baf.close(baf)\n#\nbaf.bin.coord <- function(handle, coord, binsize=10000L, \n                 what=c(\"coverage\", \"gc\"), fun=sum, drop=TRUE, na.gc=FALSE, ...,\n                 .quick=any(sapply(c(sum, mean), identical, fun)) && (!na.gc)) {\n  \n  what <- match.arg(what)\n  \n  .quick <- .quick && any(sapply(c(sum, mean), identical, fun)) && (!na.gc)\n  \n  rest <- if (drop) 0 else (coord[2]-coord[1]+1) %% binsize\n\n  .load <- function(coor) {\n    tmp <- baf.fetch.coord(handle, coor)\n    res <- rowSums(tmp)\n    if (what==\"gc\")\n      res <- (tmp[,'G']+tmp[,'C']) / (if (na.gc) res else pmax(1, res))\n    res\n  }\n  \n  if (.quick) {\n    res <- .load(coord)\n    res <- lx.binsum(res, binsize, drop=drop)\n    if (identical(fun, mean)) {\n      res <- res / binsize\n      if (rest != 0) \n        res[length(res)] <- res[length(res)] * binsize / rest\n    }\n  } else {\n    res <- if (coord[2] - coord[1] + 1 < binsize) numeric(0)\n           else sapply(seq.int(coord[1], coord[2]-binsize+1, by=binsize),\n                       function(pos) fun(.load(c(pos, pos+binsize-1)), ...))\n    if (rest != 0)\n      res <- c(res, fun(.load(c(coord[2]-rest+1, coord[2]))))\n  }\n  res\n}\n\n# -------------------------------------------------\n#' binning coverage or GC content using relative coordinates\n#' @description\n#' \\code{clocation} defines a region on a chromosome. this function\n#' collects coverage or GC content by bins of width \\code{binsize} within the region.\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param clocation relative clocation = c(seqname, from, to) (1-based)\n#' @param binsize size of bins\n#' @param what what to collect \"coverage\" or \"gc\" (may be abrreviated)\n#' @param fun collect function (e.g. sum, mean, median, user-closure, ...) see details.\n#' @param drop drop the last element of result if region width is not a muliple\n#'        of binsize\n#' @param na.gc boolean to specify how to handle GC content for positions with\n#'        0 coverage. na.gc = TRUE will produce 0/0 = NA and na.gc = FALSE\n#'        will produce 0/0 = 0.\n#' @param ... optional arguments to be passed to \\code{fun}\n#' @param .quick use a quicker algorithm (valid for fun=sum or fun=mean only and\n#'        na.gc=FALSE) at the expense of memory overhead.\n#' @return numeric vector of size n containing binned cover or gc content\n#' @details\n#' let us note allele.counts the binsize x 4 matrix of alleles counts in each\n#' bin.\\cr\n#' if (what==\"cover\") then fun(coverage) is collected in each bin,\\cr\n#' with coverage = rowSums(allele.counts)\\cr\\cr\n#' if (what==\"gc\") then fun(gc.line) is collected in each bin,\\cr\n#' with gc.line = rowSums(GC.allele.counts) / rowSums(allele.counts).\n#' (with a special treatment of NA's. see below)\\cr\n#' Therefore fun=sum will produce the number of GC alleles in bin and \n#' fun=mean will produce the \\%GC. Note that functions other than sum\n#' or mean are usually meaningless with what==\"gc\"\\cr\\cr\n#' \\code{fun} can be any function or user-supplied closure\n#' taking a numerical vector as input and returning a scalar.\\cr\\cr\n#' the \\code{na.gc} parameter is intended to handle the special case where\n#' coverage=0 at a position.\\cr\n#' Then the computed gc.line at this position is\n#' NA if na.gc=TRUE, and 0 if na.gc=FALSE.\\cr\n#' Please note that na.gc=TRUE will disable quick mode.\\cr\\cr\n#' the \\code{drop} parameter handles the last bin when \n#' region width is not a muliple of binsize.\\cr\n#' if drop=TRUE then the last (incomplete) bin is omited.\n#' if drop=FALSE then the last (incomplete) bin is included.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.fetch.cloc} \\link{baf.bin.coord}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' i <- baf.name2index(baf, \"machaon\")\n#' baf.fetch.cloc(baf, c(i, 560, 565))\n#' # 'fun' usage\n#' baf.bin.coord(baf, c(33725, 33730), 3) # sum\n#' baf.bin.cloc(baf, c(i, 560, 565), 3, fun=mean)\n#' baf.bin.cloc(baf, c(i, 560, 565), 3, fun=median)\n#' # 'na.gc' usage\n#' baf.bin.cloc(baf, c(i, 560, 565), 3, what=\"gc\")\n#' baf.bin.cloc(baf, c(i, 560, 565), 3, what=\"gc\", na.gc=TRUE)\n#' baf.bin.cloc(baf, c(i, 560, 565), 3, what=\"gc\", na.gc=TRUE, na.rm=TRUE)\n#' # 'drop' usage\n#' baf.bin.cloc(baf, c(i, 560, 565), 4)\n#' baf.bin.cloc(baf, c(i, 560, 565), 4, drop=FALSE)\n#' baf.bin.cloc(baf, c(i, 560, 565), 10)\n#' baf.bin.cloc(baf, c(i, 560, 565), 10, drop=FALSE)\n#' baf.close(baf)\nbaf.bin.cloc <- function(handle, clocation, binsize=10000L,\n                what=c(\"coverage\", \"gc\"), fun=sum, drop=TRUE, na.gc=FALSE, ...,\n                .quick=any(sapply(c(sum, mean), identical, fun)) && (!na.gc)) {\n  coord <- cloc2coord(handle, clocation)\n  baf.bin.coord(handle, coord, binsize=binsize, what=what, fun=fun,\n                drop=drop, na.gc=na.gc, ..., .quick=.quick)\n}\n\n# -------------------------------------------------\n#' get sample of alleles counts\n#' @description\n#' sample positions on all chromosomes and return allele counts\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param chrs integer (chromosome indexes) or character (chromosome names) vector\n#' specifying which chromosomes to use. Use NULL to specify all\n#' chromosome declared in baf header.\n#' @param sample.size sample size (set to +Inf to collect all positions)\n#' @param .seed random seed (for reproducibility). use a strictly negative\n#' integer to disable seeding.\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return integer matrix of size .sample.size x 4 containing allele counts.\n#' with chrindex '.' (1-based) positions as rownames.\n#' @note you may set sample.size to +Inf to collect allele counts on all position.\n#' but be careful this may use a very large amount of memory.\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' smp <- baf.sample(baf, sample.size=100, .seed=0, use.threads=FALSE)\n#' baf.close(baf)\n#'\nbaf.sample <- function(handle, chrs=NULL, sample.size=1e6L, .seed=-1L,\n                       use.threads=lx.use.threads()) {\n\n  # <internal> sample on one chromosome\n  # will be possibly run within thread\n  .baf.sample.chr <- function(handle, chrindex, sample.size, .seed) {\n    if (.seed >= 0) set.seed(.seed)\n    chr.size <- handle$header$seq[[chrindex]]$size\n    smp.size <- min(sample.size, chr.size)\n    pos <- sort(sample(chr.size, smp.size, replace=F))\n    res <- baf.fetch.points.chr(handle, chrindex, pos)\n    rownames(res) <- pos\n    res\n  }\n\n  if (is.null(chrs))\n    chrs <- seq.int(handle$header$nbseq)\n  \n  if (is.character(chrs))\n    chrs <- sapply(chrs, function(chr) baf.name2index(handle, chr))\n  \n  # truncate chrs if needed\n  chrs <- intersect(chrs, seq.int(handle$header$nbseq))\n\n  # prepare seeds for random\n  if (.seed >= 0) {\n    set.seed(.seed)\n    chr.seed <- sample(length(chrs), length(chrs), replace=F)\n  } else {\n    chr.seed <- rep(.seed, length(chrs))\n  }\n  names(chr.seed) <- chrs\n  \n  # truncate .sample.size if needed\n  sum.size <- sum(sapply(chrs, function(chr) handle$header$seq[[chr]]$size))\n  sample.size <- min(sample.size, sum.size)\n\n  # sample by chromosome\n  res <- lx.happly(chrs, function(chrindex, handle, seeds) {\n    size <- ceiling(handle$header$seq[[chrindex]]$size * sample.size / sum.size)\n    lx.out(size)\n    .baf.sample.chr(handle, chrindex, sample.size=size, .seed=seeds[[as.character(chrindex)]])\n  }, handle=handle, seeds=chr.seed, use.threads=use.threads)\n  \n  # add rownames\n  chr.nams <- unlist(mapply(rep, chrs, sapply(res, nrow), USE.NAMES=F))\n  res <- do.call(rbind, res)\n  rownames(res) <- paste(chr.nams, rownames(res), sep=\".\")\n  \n  # resample to proper size\n  if (sample.size != sum.size) {\n    isamp <- sort(sample(nrow(res), sample.size, replace=F))\n    res <- res[isamp,]\n  }\n  \n  res\n}\n\n# -------------------------------------------------\n#' filter allele counts\n#' @description filter allele counts according to coverage, min and max\n#' number of alleles and max allele frequency (see details).\n#' @details \n#' \\bold{definitions}\\cr\n#' an allele X is present iff:\\cr\n#' \\itemize{\\item count_X > \\code{lowread}}\n#' a site (i.e. a row of \\code{count}) is valid iff:\\cr\n#' \\itemize{\n#' \\item coverage >= \\code{covmin}\n#' \\item \\code{minall} <= nb_alleles <= \\code{maxall}\n#' \\item if (nb_alleles > 1) abs(0.5 - count_max_allele / coverage) <= \\code{deltafreq}\n#' }\n#' \n#' if \\code{mincov} is < 0 then \\code{mincov} is computed as:\\cr\n#' \\code{quantile(coverage, -mincov/1000)}\\cr\n#' \n#' if \\code{delta.freq} == NA or maxall < 2 then freq condition is ignored\n#' \n#' @param count nx4 integer matrix of alleles counts.\n#' as returned by \\code{baf.fetch.xxx}, \\code{baf.sample.xxx} or\n#' \\code{baf.heterozygous.xxx}.\n#' @param lowread low read threshold (see details)\n#' @param mincov minimal coverage (see details)\n#' @param minall minimal number of alleles (see details)\n#' @param maxall maximal number of alleles (see details)\n#' @param deltafreq max allele frequency (see details)\n#' @param what kind of result to return (see value)\n#' @return \\itemize{\n#' \\item if (what == \"count\") filtered count matrix\n#' \\item if (what == \"index\") indexes of valid rows\n#' \\item if (what == \"logical\") logical vector indicating valid rows\n#' }\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' cnt <- baf.sample(baf, sample.size=Inf)\n#' cnt.ok <- baf.count.filter(cnt, lowread=2, mincov=10, minall=1, maxall=4, deltafreq=NA)\n#' baf.close(baf)\n#\n# note: since count can be very large (> 10e8 rows) this implementation\n#       makes maximum use of vector operations\n#\nbaf.count.filter <- function(count, lowread=2L, mincov=10L, minall=1L, maxall=2L,\n                             deltafreq=0.1, what=c(\"count\", \"index\", \"logical\")) {\n  \n  # determine mincov  \n  if (mincov < 0)\n    mincov <- .mincov(count, mincov)\n\n  # get total coverage\n  cov <- rowSums(count)\n\n  # filter mincov\n  ok <- (cov >= mincov)\n  \n  # filter nb alleles\n  nball <- integer(nrow(count))\n  for (i in 1:4) nball <- nball + (count[,i] > lowread)\n  ok <- ok & (nball >= minall) & (nball <= maxall)\n  \n  # filter max allele frequency\n  if ((! is.na(deltafreq)) && (maxall >= 2)) {\n    frq <- lx.rowMaxs(count, ties.method=\"first\")\n    frq <- frq / pmax(1, cov)\n    ok <- ok & ((nball < 2) | (abs(frq - 0.5) <= deltafreq))\n    frq <- NULL\n  }\n  nball <- NULL\n    \n  # select result\n  count <- switch(what[1],\n                  logical=ok,\n                  index=seq.int(nrow(count))[ok],\n                  count[ok,,drop=F])\n  \n  lx.out(\"filtered sites : \", sum(ok), \" / \", length(ok), level=\"debug\", with.mem=TRUE)\n  \n  count\n}\n\n# -------------------------------------------------\n#' get genotype from allele counts\n#' @description retrieve genotypes from allele counts matrix\n#' @param count nx4 integer matrix of alleles counts.\n#' as returned by \\code{baf.fetch.xxx}, \\code{baf.sample.xxx} or\n#' \\code{baf.heterozygous.xxx}.\n#' @param lowread low read threshold (see details)\n#' @param what kind of result to return (see value)\n#' @param sorted sort result by frequencies (see details)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @details \n#' this function returns the list of allele(s) present at each\n#' row of the \\code{count} matrix.\\cr\n#' an allele X is present iff: \\code{count_X > lowread}\\cr\n#' the typeof result depends upon the \\code{what} parameter:\\cr\n#' \\itemize{\n#' \\item if (what == \"symbol\") list of character array of alleles symbols\n#' \\item if (what == \"index\") list of integer array of alleles indices\n#' \\item if (what == \"string\") array of genotype strings\n#' }\n#' if \\code{sorted}==FALSE (default) each array element of the result list\n#' (or each character in string) appears in the same order as in \\code{colnames(count)}\n#' whatever the frequency value.\n#' if \\code{sorted}==TRUE then array elements are sorted by decreasing frequency.\n#' @return list of alleles or array of strings (see details)\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' cnt <- baf.sample(baf, sample.size=Inf)\n#' # sample: count all genotypes\n#' cnt.ok <- baf.count.filter(cnt, lowread=0, mincov=10, minall=1, maxall=4, deltafreq=NA)\n#' geno <- baf.count.genotype(cnt.ok, lowread=0)\n#' table(nb.all <- sapply(geno, length))\n#' # sample: ordered bi-allelic genotypes\n#' cnt.ok <- baf.count.filter(cnt, lowread=0, mincov=10, minall=2, maxall=2, deltafreq=NA)\n#' geno <- baf.count.genotype(cnt.ok, lowread=0, sorted=TRUE)\n#' baf.close(baf)\n#\nbaf.count.genotype <- function(count, lowread=2L, what=c(\"symbol\", \"index\", \"string\"),\n                               sorted=FALSE, use.threads=lx.use.threads()) {\n\n  what <- match.arg(what)\n  \n  .ord <- function(x) order(x, decreasing=T)\n  .nam <- colnames(count)\n  if (sorted) {\n    .sel <- switch(what,\n                   index=function(r) { o <- .ord(r); list(o[which(r[o] > lowread)]) },\n                   function(r) { o <- .ord(r); list(.nam[o[which(r[o] > lowread)]]) })\n  } else {\n    .sel <- switch(what,\n                   index=function(r) list(which(r > lowread)),\n                   function(r) list(.nam[which(r > lowread)]))\n  }\n\n  geno <- if (use.threads) \n    lx.lapply(seq_len(nrow(count)), function(i) .sel(count[i,]), use.threads=T)\n  else\n    apply(count, 1, .sel)\n\n  geno <- unlist(geno, recursive=F)\n  \n  if (what %in% \"string\")\n    geno <- sapply(geno, paste, collapse=\"\")\n  \n  geno\n}\n\n\n# -------------------------------------------------\n#' get heterozygous positions within region \n#' @description\n#' get heterozygous positions within region using absolute coordinates.\\cr\n#' \\code{coord} defines a region on a chromosome. this function\n#' gather all heterozygous positions defined as valid by \\link{baf.count.filter}:\\cr\n#' \\itemize{\n#' \\item coverage >= \\code{covmin}\n#' \\item nb_alleles == 2\n#' \\item abs(0.5 - count_max_allele / coverage) <= \\code{deltafreq}\n#' }\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param coord absolute sequence coordinates (c(absfrom, absto)) (1-based)\n#'               or a single position absfrom (this implies absto=absfrom)\n#' @param lowread low read threshold (see \\link{baf.count.filter})\n#' @param mincov minimal coverage (see \\link{baf.count.filter})\n#' @param deltafreq max allele frequency (see \\link{baf.count.filter})\n#' @return integer matrix of size n x 4 containing allele counts at heterozygous sites.\n#' with (1-based) positions as rownames.\n#' @note take care that if mincov < 0 the actual mincov will be computed on this\n#' region (as \\code{quantile(coverage, -mincov/1000)}),\n#' not on whole chromosome nor genome. you better use a positive value for\n#' mincov.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.heterozygous.cloc}, \\link{baf.count.filter}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.heterozygous.coord(baf, c(33725, 33732), deltafreq=0.5)\n#' baf.close(baf)\n#'\nbaf.heterozygous.coord <- function(handle, coord, lowread=2L, mincov=10L, deltafreq=0.1) {\n\n  # fetch points\n  count <- baf.fetch.coord(handle, coord)\n\n  # get heterozygous positions\n  indx <- baf.count.filter(count, lowread=lowread, mincov=mincov, \n                           minall=2, maxall=2, deltafreq=deltafreq,\n                           what=\"index\")\n  \n  count <- count[indx,,drop=F]\n  rownames(count) <- seq(from=coord[1], to=coord[2])[indx]\n  \n  count\n}\n\n# -------------------------------------------------\n#' get heterozygous positions within region \n#' @description\n#' get heterozygous positions within region using relative coordinates.\\cr\n#' \\code{clocation} defines a region on a chromosome. this function\n#' gather all heterozygous positions defined as valid by \\link{baf.count.filter}:\\cr\n#' \\itemize{\n#' \\item coverage >= \\code{covmin}\n#' \\item nb_alleles == 2\n#' \\item abs(0.5 - count_max_allele / coverage) <= \\code{deltafreq}\n#' }\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param clocation relative clocation = c(seqname, from, to) (1-based)\n#' @param lowread low read threshold (see \\link{baf.count.filter})\n#' @param mincov minimal coverage (see \\link{baf.count.filter})\n#' @param deltafreq max allele frequency (see \\link{baf.count.filter})\n#' @return integer matrix of size n x 4 containing allele counts at heterozygous sites.\n#' with (1-based) positions as rownames.\n#' @note take care that if mincov < 0 the actual mincov will be computed on this\n#' region (as \\code{quantile(coverage, -mincov/1000)})\n#' not on whole chromosome nor genome. you better use a positive value for\n#' mincov.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.heterozygous.coord}, \\link{baf.count.filter}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' i <- baf.name2index(baf, \"machaon\")\n#' baf.heterozygous.cloc(baf, c(i, 560, 567), deltafreq=0.5)\n#' baf.close(baf)\n#'\nbaf.heterozygous.cloc <- function(handle, clocation, lowread=2L, mincov=10L, deltafreq=0.1) {\n  coord <- cloc2coord(handle, clocation)\n  res <- baf.heterozygous.coord(handle, coord, lowread=lowread,\n                                mincov=mincov, deltafreq=deltafreq)\n  rownames(res) <- coords2clocs(handle, as.numeric(rownames(res)))[,2]\n  res\n}\n\n# -------------------------------------------------\n#' get heterozygous positions on chromosome\n#' @description\n#' get heterozygous positions on chromosome \\code{chr}.\n#' this function gather all heterozygous positions defined \n#' as valid by \\link{baf.count.filter}:\\cr\n#' \\itemize{\n#' \\item coverage >= \\code{covmin}\n#' \\item nb_alleles == 2\n#' \\item abs(0.5 - count_max_allele / coverage) <= \\code{deltafreq}\n#' }\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param chr chromosome index (if integer) or chromosome name (if character)\n#' @param lowread low read threshold (see \\link{baf.count.filter})\n#' @param mincov minimal coverage (see \\link{baf.count.filter})\n#' @param deltafreq max allele frequency (see \\link{baf.count.filter})\n#' @param .chunk.size chunk size for loading chromosome (to save memory). Use NA\n#' to load in one single chunk (quicker but memory expensive). see note below for the\n#' compatibility with a negative mincov.\n#' @param .sample.size sample size to determine mincov for the case where .chunk.size != NA\n#' and mincov < 0 (see note).\n#' @return integer matrix of size n x 4 containing allele counts at heterozygous sites.\n#' with (1-based) positions as rownames.\n#' @note if (mincov < 0) then mincov will be estimated \n#' (\\code{quantile(coverage, -mincov/1000)}) as in \\link{baf.count.filter}.\n#' However the region for computing coverage will depends upon the \\code{.chunk.size}\n#' parameter: if \\code{.chunk.size == NA} then this will be performed on the\n#' whole chromosome.\n#' if \\code{.chunk.size != NA} then mincov will be first evaluated\n#' on a sample of \\code{.sample.size} data points. Therefore for exact results, you\n#' should better use a positive value for mincov.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.heterozygous.coord}, \\link{baf.heterozygous.cloc}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.heterozygous.chr(baf, 3, deltafreq=0.5)\n#' baf.close(baf)\n#'\nbaf.heterozygous.chr <- function(handle, chr, lowread=2L, mincov=10L, deltafreq=0.1, \n                                 .chunk.size=NA, .sample.size=1e6L) {\n  \n  chrindex <- if (is.character(chr)) baf.name2index(handle, chr) else chr\n  \n  chr.size <- handle$header$seq[[chrindex]]$size\n  \n  .chunk.size <- if (is.na(.chunk.size)) chr.size else .chunk.size\n  \n  chunk.from <- seq.int(1L, chr.size, by=.chunk.size)\n  \n  # estimate mincov if needed\n  if ((.chunk.size != chr.size) && (mincov < 0)) {\n    lx.warn(\"chunk size and mincov < 0 are incompatible. need to sample data points\")\n    samp <- baf.sample(handle, chrs=chr, sample.size=.sample.size, .seed=-1, use.threads=F)\n    mincov <- .mincov(samp, mincov)\n  }\n  \n  # go ahead\n  res <- lapply(chunk.from, function(from) {\n      cloc <- c(chrindex, from, min(from + .chunk.size - 1, chr.size))\n      baf.heterozygous.cloc(handle, cloc, lowread=lowread,\n                            mincov=mincov, deltafreq=deltafreq)\n  })\n  \n  do.call(rbind, res)\n}\n\n# -------------------------------------------------\n#' get heterozygous positions on all chromosomes\n#' @description\n#' get heterozygous positions on all chromosomes\n#' this function gather all heterozygous positions\n#' defined as valid by \\link{baf.count.filter}:\\cr\n#' \\itemize{\n#' \\item coverage >= \\code{covmin}\n#' \\item nb_alleles == 2\n#' \\item abs(0.5 - count_max_allele / coverage) <= \\code{deltafreq}\n#' }\n#' @param handle file handle (as returned by \\link{baf.open})\n#' @param chrs integer (chromosome indexes) or character (chromosome names) vector\n#' specifying which chromosomes to use. Use NULL to specify all\n#' chromosome declared in baf header.\n#' @param lowread low read threshold (see \\link{baf.count.filter})\n#' @param mincov minimal coverage (see \\link{baf.count.filter})\n#' @param deltafreq max allele frequency (see \\link{baf.count.filter})\n#' @param flatten if TRUE flatten all chromosomes within a single matrix\n#' else return a list of such matrices, one per chromosome\n#' @param use.threads (see \\link{lx.use.threads})\n#' @param .chunk.size chunk size for loading chromosomes. see \\link{baf.heterozygous.chr}\n#' @param .sample.size sample size to determine mincov for the case where mincov < 0 \n#' (see note below).\n#' @return (list of) integer matrix of size n x 4 containing allele counts at heterozygous sites.\n#' if flatten is TRUE matrix rownames are of the form: chr.position (1-based)\n#' else position (1 based) only.\n#' @note if (mincov < 0) then mincov will be estimated \n#' (as \\code{quantile(coverage, -mincov/1000)}) as in \\link{baf.count.filter}.\n#' However the region for computing coverage will depends upon the \\code{.chunk.size}\n#' parameter: if \\code{.chunk.size == NA} then this will be performed on each chromosome\n#' separately (therefore leading to potential different values of mincov per chromosome).\n#' if \\code{.chunk.size != NA} then mincov will be first evaluated\n#' on a sample of \\code{.sample.size} data points. Therefore for exact results, you\n#' better use a positive value for mincov.\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @seealso \\link{baf.heterozygous.chr}\n#' @examples\n#' baf <- baf.open(lx.system.file('samples/test.baf', 'xlx'))\n#' baf.heterozygous(baf, NULL, deltafreq=0.5)\n#' baf.heterozygous(baf, NULL, deltafreq=0.5, flatten=FALSE)\n#' baf.close(baf)\n#'\nbaf.heterozygous <- function(handle, chrs=NULL, lowread=2L, mincov=10L, deltafreq=0.1,\n                             flatten=TRUE, .chunk.size=NA, .sample.size=1e6L,\n                             use.threads=lx.use.threads()) {\n\n  if (is.null(chrs))\n    chrs <- seq.int(handle$header$nbseq)\n  \n  if (is.character(chrs))\n    chrs <- sapply(chrs, function(chr) baf.name2index(handle, chr))\n  \n  # truncate chrs if needed\n  chrs <- intersect(chrs, seq.int(handle$header$nbseq))\n\n  # estimate mincov if needed\n  if ((! is.na(.chunk.size)) && (mincov < 0)) {\n    lx.warn(\"chunk size and mincov < 0 are incompatible. need to sample data points\")\n    samp <- baf.sample(handle, chrs=chrs, sample.size=.sample.size, .seed=-1L, \n                       use.threads=use.threads)\n    mincov <- .mincov(samp, mincov)\n  }\n\n  # collect by chromosome\n  res <- lx.happly(chrs, function(chrindex, handle) {\n    lx.out(\"collecting baf on chr \", chrindex, level=\"debug\")\n    baf.heterozygous.chr(handle, chrindex, lowread=lowread,\n                         mincov=mincov, deltafreq=deltafreq,\n                         .chunk.size=.chunk.size, .sample.size=.sample.size)\n  }, handle=handle, use.threads=use.threads)\n  \n  # flatten and add rownames\n  if (flatten) {\n    chr.nams <- unlist(mapply(rep, chrs, sapply(res, nrow), USE.NAMES=F))\n    res <- do.call(rbind, res)\n    rownames(res) <- paste(chr.nams, rownames(res), sep=\".\")\n  } else {\n    names(res) <- chrs\n  }\n\n  res\n}\n\n# -------------------------------------------------\n#' make clocations spanning all chromosomes\n#' @description\n#' make clocations spanning all chromosomes declared in basta/baf file\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @return nx3 matrix of clocations\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @details\n#' this is the same function as \\link{basta2clocs}\n#' \nbaf2clocs <- basta2clocs\n\n# -------------------------------------------------\n#' make absolute coordinates spanning all chromosomes\n#' @description\n#' make absolute coordinates spanning all chromosomes\n#' declared in basta/baf file\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @return nx2 matrix of absolute coordinates (1-based)\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @details\n#' this is the same function as \\link{basta2coords}\n#' \nbaf2coords <- basta2coords\n\n# -------------------------------------------------\n#' allelic frequency regularization\n#' @description\n#' regularize allelic frequency using poisson pseudo-counts\n#' @param count nx4 integer matrix of alleles counts.\n#' as returned by \\code{baf.fetch.xxx}, \\code{baf.sample.xxx} or\n#' \\code{baf.heterozygous.xxx}.\n#' @param tot total count (i.e. depth)\n#' @param n number of draws per point\n#' @param .eps lambda correction\n#' @param .seed seed for random (do not seed if < 0)\n#' @return names list of 3 vectors (cnt=regularized counts,\n#' tot=regularized total, raf=regulized all. freq.)\n#' @examples\n#' N <- 10000\n#' cnt <- round(rpois(N, 5))\n#' tot <- cnt + round(rpois(N, 5))\n#' unreg <- cnt / tot\n#' reg <- baf.count.regularize(cnt, tot, \"poisson\", .seed=0)\n#' \nbaf.count.regularize.poisson <- function(count, tot, n=10L, .eps=0, .seed=-1L) {\n  if (.seed >= 0) set.seed(.seed)\n  zero  <- rep.int(0, max(length(count), length(tot)))\n  count <- count + zero # force recycling\n  tot   <- tot + zero\n  rac   <- pmax(0, sapply(count, function(x) mean(rpois(n, lambda=x+.eps))))\n  rrc   <- pmax(0, sapply(tot-count, function(x) mean(rpois(n, lambda=x+.eps))))\n  rac[(count > tot) | (count < 0)] <- NA\n  raf <- pmin(1.0, rac / (rac + rrc))\n  list(cnt=rac, tot=rac+rrc, raf=raf)\n}\n\n# -------------------------------------------------\n#' allelic frequency regularization\n#' @description\n#' regularize allelic frequency using gaussian pseudo-counts\n#' @param count nx4 integer matrix of alleles counts.\n#' as returned by \\code{baf.fetch.xxx}, \\code{baf.sample.xxx} or\n#' @param tot total count (i.e. depth)\n#' @param sd gaussian standard deviation\n#' @param n number of draws per point\n#' @param .seed seed for random (do not seed if < 0)\n#' @return names list of 3 vectors (cnt=regularized counts,\n#' tot=regularized total, raf=regulized all. freq.)\n#' @examples\n#' N <- 10000\n#' cnt <- round(rpois(N, 5))\n#' tot <- cnt + round(rpois(N, 5))\n#' unreg <- cnt / tot\n#' reg <- baf.count.regularize(cnt, tot, \"gaussian\", .seed=0)\n#'\nbaf.count.regularize.gaussian <- function(count, tot, sd=0.5, n=10L, .seed=-1L) {\n  if (.seed >= 0) set.seed(.seed)\n  npt   <- max(length(count), length(tot))\n  zero  <- rep.int(0, npt)\n  count <- count + zero # force recycling\n  tot   <- tot + zero\n  rac   <- pmax(0, sapply(count, function(x) x + mean(rnorm(n, 0, sd=sd))))\n  rrc   <- pmax(0, sapply(tot-count, function(x) x + mean(rnorm(n, 0, sd=sd))))\n  rac[(count > tot) | (count < 0)] <- NA\n  raf <- pmin(1.0, rac / (rac + rrc))\n  list(cnt=rac, tot=rac+rrc, raf=raf)\n}\n\n# -------------------------------------------------\n#' allelic frequency regularization\n#' @description\n#' regularize allelic frequency using various methods\n#' @param count nx4 integer matrix of alleles counts.\n#' as returned by \\code{baf.fetch.xxx}, \\code{baf.sample.xxx} or\n#' @param tot total count (i.e. depth)\n#' @param method method to use (\"poisson\" or \"gaussian\")\n#' @param ... specific method parameters \n#' @return names list of 3 vectors (cnt=regularized counts,\n#' tot=regularized total, raf=regularized all. freq.)\n#' @examples\n#' N <- 10000\n#' cnt <- round(rpois(N, 30))\n#' tot <- cnt + round(rpois(N, 30))\n#' unreg <- cnt / tot\n#' reg <- baf.count.regularize(cnt, tot, \"gaussian\", .seed=0)\n#'\nbaf.count.regularize <- function(count, tot, method=c(\"poisson\", \"gaussian\"), ...) {\n  method <- match.arg(method)\n  do.call(paste0(\"baf.count.regularize.\", method), c(list(count=count, tot=tot), ...))\n}\n",
    "created" : 1496008328105.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2629380397",
    "id" : "67748D69",
    "lastKnownWriteTime" : 1501924704,
    "last_content_update" : 0,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/xlx/R/xlx.bbaf.r",
    "project_path" : "R/xlx.bbaf.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}