{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: xlx.basta.r 290 2017-08-05 09:58:42Z viari $\n# xlx basta format\n#\n\n# -------------------------------------------------\n#' @name HELP.BASTA\n#' @docType data\n#' @title Basta format\n#' @description\n#' Basta file format is similar to Fasta format\n#' but allow indexed access to sequences.\\cr\n#' this is a little endian binary file composed of\n#' a header:\\cr\n#' \\tabular{lll}{\n#' int32 \\tab 0x62617332 \\tab magic number ('bas2')\\cr\n#' int32 \\tab nbseq \\tab number of sequences\\cr\n#' ---- \\tab ------------ \\tab -------\\cr\n#' \\tab \\tab repeat nbseq times\\cr\n#' ---- \\tab ------------ \\tab -------\\cr\n#' string \\tab namei \\tab name of sequence i (see 1)\\cr\n#' int64 \\tab sizei \\tab length of sequence i\\cr\n#' int32 \\tab crc32i \\tab crc32 of sequence i\\cr\n#' ---- \\tab ------------ \\tab -------\\cr\n#' }\n#' followed by the concatenation of all sequences\n#' as character arrays (not NULL terminated).\n#'\n#' (1) string format is:\n#' \\tabular{lll}{\n#' int32 \\tab size \\tab string length\\cr\n#' bytes \\tab size + 1 \\tab NULL terminated char array\\cr\n#'}\n#'\n#' @note\n#' When opening a basta file, the header is loaded\n#' into memory but not the sequences. Sequences\n#' are directly accessed from disk.\n#'\n#' @note\n#' Conversion from fasta to basta is performed by the\n#' external C executable \\code{fasta2basta} provided\n#' in Csrc directory.\n#'\nNULL\n\n# =================================================\n# globals\n# =================================================\n\n.basta.MAGIC <- 0x62617332  # 'bas2'\n\n# =================================================\n# internals <no_export>\n# =================================================\n\n# -------------------------------------------------\n# <internal> <no_export>\n#  check sequence crc32\n#  this is an internal function (used in basta.open)\n#  and not exported\n#\n.basta.check.crc32 <- function(handle, seqname) {\n  seq <- handle$header$seq[[seqname]]\n  dna <- basta.fetch.cloc(handle, as.integer(c(seq$index, 1, seq$size)))\n  crc <- digest::digest(dna, algo=\"crc32\", serialize=F, length=seq$size)\n  ref <- lx.tobase(seq$crc32)\n  ok  <- (crc == ref)\n  if (ok) \n    lx.out(\"crc checksum sequence \", seq$name, \" ok\", level=\"debug\")\n  else\n    lx.out(\"crc checksum sequence \", seq$name, \" \", crc, \" != \", ref, level=\"debug\")\n  ok\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# read basta header\n#  this is an internal function (used in basta.open)\n#  and not exported\n#\n.basta.read.header <- function(handle) {\n  header <- list()\n  \n  header$magic = lx.read.int32(handle)\n  lx.stopif(header$magic != .basta.MAGIC, \"bad magic header\", up.frame=1)\n\n  header$nbseq <- lx.read.int32(handle)\n  \n  header$seq <- list()\n  header$baseoffset <- 8\n  offset <- 0\n  \n  for (e in 1:header$nbseq) {\n    nam <- lx.read.string(handle)\n    siz <- lx.read.int64(handle)\n    crc <- lx.read.int32(handle)\n    header$seq[[nam]] <- list(index=e, name=nam, size=siz, crc32=crc, offset=offset)\n    header$baseoffset <- header$baseoffset + nchar(nam) + 17\n    lx.out(\"header: index=\", e, \" name=\", nam, \" size=\", siz,\n              \" crc32=\", lx.tobase(crc, prefix=\"0x\"),\n              \" offset=\", offset,\n              level=\"debug\", up.frame=1)\n    offset <- offset + siz\n  }\n  \n  # keep offsets and seq sizes here to speedup some operations\n  \n  header$offsets <- sapply(header$seq, function(x) x$offset)\n  header$sizes   <- sapply(header$seq, function(x) x$size)\n  \n  handle$header <- header\n  handle\n}\n\n\n# =================================================\n# API\n# =================================================\n\n# -------------------------------------------------\n#' open basta file\n#' @description\n#' open basta file for reading\n#' @param filename basta file name\n#' @param check.crc32 perform crc32 check\n#' @return basta file handle\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'), check.crc32=TRUE)\n#' basta.close(fh)\n#'\nbasta.open <- function(filename, check.crc32=FALSE) {\n\n  handle <- lx.open(filename)\n  handle <- .basta.read.header(handle)\n  handle$type <- \"basta\"\n\n  # check crc32 if requested\n  if (check.crc32)\n    sapply(handle$header$seq, function(x) .basta.check.crc32(handle, x$name))\n\n  handle\n}\n\n# -------------------------------------------------\n#' close basta file\n#' @description\n#' same as \\link{lx.close}\n#' @param handle file handle (opened by \\link{basta.open})\n#'\nbasta.close <- lx.close\n\n# -------------------------------------------------\n#' convert seqname to seqindex\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param seqname character vector of sequence name(s)\n#' @return integer vector of 1-based sequence index or 0 if seqname not found\n#' @seealso \\link{basta.index2name}\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.name2index(fh, 'seq1')\n#' basta.index2name(fh, 2)\n#' basta.name2index(fh, c('seq1', 'nothere'))\n#' basta.index2name(fh, 1:3)\n#' basta.close(fh)\n#'\nbasta.name2index <- function(handle, seqname) {\n  nams <- names(handle$header$seq)\n  sapply(seqname, function(nam) {\n    ok <- nam %in% nams\n    lx.warnif(! ok, nam, \" : name not found\", up.frame=3)\n    if (ok) handle$header$seq[[nam]]$index else 0\n  })\n}\n\n# -------------------------------------------------\n#' convert seqindex to seqname\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param seqindex integer vector of 1-based sequence index\n#' @return character vector of seq name or NULL if index out of bounds\n#' @seealso \\link{basta.name2index}\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.name2index(fh, 'seq1')\n#' basta.index2name(fh, 2)\n#' basta.name2index(fh, c('seq1', 'nothere'))\n#' basta.index2name(fh, 1:3)\n#' basta.close(fh)\n#'\nbasta.index2name <- function(handle, seqindex) {\n  sapply(seqindex, function(indx) {\n    ok <- (indx > 0) && (indx <= handle$header$nbseq)\n    lx.warnif(! ok, indx, \" : index out of bounds\", up.frame=3)\n    if (ok) handle$header$seq[[indx]]$name else NULL\n  })\n}\n\n# -------------------------------------------------\n#' fetch sequence using absolute coordinates\n#' @param handle basta file handle (as returned by \\link{basta.open})\n#' @param coord absolute coordinates (c(absfrom, absto)) (1-based) or\n#'        single absolute position.\n#' @return sequence string\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.fetch.coord(fh, c(25, 34))\n#' basta.fetch.sloc(fh, \"seq2:1-10\")\n#' basta.fetch.cloc(fh, c(2, 1, 10))\n#' basta.close(fh)\n#'\nbasta.fetch.coord <- function(handle, coord) {\n  if (length(coord) == 1) coord <- c(coord, coord)\n  if (coord[1] > coord[2]) {\n    lx.warn('invalid coordinates : ', coord)\n    return(\"\")\n  }\n  lx.seek(handle, handle$header$baseoffset + coord[1] - 1)\n  lx.read.char(handle, coord[2]-coord[1]+1, .raw=TRUE)\n}\n\n# -------------------------------------------------\n#' fetch sequence using relative clocation\n#' @param handle basta file handle (as returned by \\link{basta.open})\n#' @param clocation relative clocation = c(seqname, from, to) (1-based)\n#' @param truncate truncate 3' to seq.size if needed\n#' @return sequence string\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.fetch.coord(fh, c(25, 34))\n#' basta.fetch.sloc(fh, \"seq2:1-10\")\n#' basta.fetch.cloc(fh, c(2, 1, 10))\n#' basta.close(fh)\n#' \nbasta.fetch.cloc <- function(handle, clocation, truncate=TRUE) {\n  coord <- cloc2coord(handle, clocation, truncate=truncate)\n  basta.fetch.coord(handle, coord)\n}\n\n# -------------------------------------------------\n#' fetch sequence using relative slocation\n#' @param handle basta file handle (as returned by \\link{basta.open})\n#' @param slocation relative slocation (\"seqname:from-to\")\n#' @param zero.based.loc given slocation is 0-based\n#' @param truncate truncate 3' to seq.size if needed\n#' @return sequence string\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.fetch.coord(fh, c(25, 34))\n#' basta.fetch.sloc(fh, \"seq2:1-10\")\n#' basta.fetch.cloc(fh, c(2, 1, 10))\n#' basta.close(fh)\n#' \nbasta.fetch.sloc <- function(handle, slocation, zero.based.loc=FALSE, truncate=TRUE) {\n  coord <- sloc2coord(handle, slocation, zero.based.loc=zero.based.loc, truncate=truncate)\n  basta.fetch.coord(handle, coord)\n}\n\n# -------------------------------------------------\n#' fetch sequence at several relative point locations\n#' @description\n#' \\code{relpts} s a set of relative \\bold{point} positions on the same chromosome.\n#' this function returns sequence of length size starting at each position.\n#' this formaly equivalent to:\\cr\n#' \\code{clocs <- lapply(relpts, function(x) c(chrindex, x, x+size-1))}\\cr\n#' \\code{res <- unlist(lapply(clocs, basta.fetch.cloc, handle=handle))}\\cr\n#' but is much quicker when relpts vector is large and values\n#' span most of the chromosome.\\cr\n#' The idea is to load the chromosome\n#' counts by chunks of size \\code{.chunk.size} instead of accessing each\n#' location individually (thus reducing disk access overhead).\n#' @param handle file handle (as returned by \\link{basta.open})\n#' @param chr chromosome index (if integer) or chromosome name (if character)\n#' @param relpts vector of relative positions (1-based) on this\n#' chromosome\n#' @param size size of sequence to fetch\n#' @param .chunk.size <internal parameter> size of chunk. changing this parameter\n#' will only affect time or memory used, not result.\n#' @return array of character string giving the sequence starting\n#' at each point location.\n#' @examples\n#' basta <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' x <- basta.fetch.points.chr(basta, 1, 1:10)\n#' y <- lx.strsplit(basta.fetch.cloc(basta, c(1,1,10)), \"\")\n#' identical(x, y)\n#' x <- basta.fetch.points.chr(basta, 1, 15:25, size=10)\n#' basta.close(basta)\n#'\nbasta.fetch.points.chr <- function(handle, chr, relpts, size=1L,\n                                   .chunk.size=1000000L) {\n  \n  lx.stopif(size <= 0, \"size parameter should be > 0\")\n  if (.chunk.size <= size) .chunk.size <- size\n  chrindex <- if (is.character(chr)) basta.name2index(handle, chr) else chr\n  \n  lx.out(\"fetching \", length(relpts), \" points on chr index \", chrindex, level=\"debug\")\n  chr.size <- handle$header$seq[[chrindex]]$size\n  chunk.size <- min(chr.size, .chunk.size)\n  \n  chunk.from <- seq.int(min(relpts), min(chr.size, max(relpts)), by=chunk.size)\n  \n  #\n  # keep initial points order\n  #\n  ptorder <- order(relpts)\n  relpts <- relpts[ptorder]\n  \n  #\n  # split into chunks (this will reorder points)\n  #\n  lx.out(\"  splitting in \", length(chunk.from), \" chunks\", level=\"debug\")\n  chunk.indx <- split(relpts, factor(findInterval(relpts, chunk.from),\n                                     levels=seq_along(chunk.from)))\n  \n  chunk.clocs <- lapply(chunk.from, function(x) {\n    as.integer(c(chrindex, x, min(x+chunk.size-1+size-1, chr.size)))\n  })\n  \n  chunks <- mapply(function(x, y) {\n    list(cloc=x, pos=y)\n  }, chunk.clocs, chunk.indx, SIMPLIFY=FALSE)\n  #\n  # load chunks in turn and get counts for positions in each chunk\n  #\n  .load <- function(chunk) {\n    seq <- if (length(chunk$pos) == 0) \"\"\n    else basta.fetch.cloc(handle, chunk$cloc)\n    lapply(chunk$pos - chunk$cloc[2] + 1, function(x) substr(seq, x, x+size-1))\n  }\n  \n  lx.out(\"  loading in \", length(chunks), \" chunks\", level=\"debug\")\n  res <- unlist(lapply(chunks, .load), recursive=FALSE)\n  \n  #\n  # put points back in initial order\n  #\n  lx.out(\"  reshaping results\", level=\"debug\")\n  res <- unlist(res[order(ptorder)])\n  \n  res\n}\n\n# -------------------------------------------------\n#' fetch symbols counts using absolute coordinates\n#' @description \n#' fetch sequence thru \\link{basta.fetch.coord} and\n#' count the number of occurences of symbols specified\n#' in \\code{sym} in contiguous bins of size \\code{binsize}\n#' @param handle basta file handle (as returned by \\link{basta.open})\n#' @param coord absolute coordinates (c(absfrom, absto)) (1-based) or\n#'        single absolute position.\n#' @param sym vector of strings specifying symbols to be counted.\n#' see details.\n#' @param binsize size of bins (defaults to whole sequence length)\n#' @param case.sensitive symbols in \\code{sym} are case sensitive\n#' @param drop drop the last bin if sequence length is not a muliple\n#'        of binsize\n#' @return a matrix or vector of counts. if \\code{length(sym)==1} returns\n#' a vector of symbol(s) counts for each bin position.\n#' if \\code{length(sym)>1} returns a matrix of symbols counts\n#' with length(sym) columns and each row corresponds to each bin\n#' position.\n#' @details each string in \\code{sym} specifies a set of symbols to be\n#' counted. if this set starts with '!', it means symbols \\bold{not} in\n#' set. As a special case the string \"Other\" is equivalent to \"!ACGT\".\n#' @seealso \\link{basta.count.coord}\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.fetch.coord(fh, c(1, 24))\n#' # count all DNA symbols\n#' basta.count.coord(fh, c(1, 24))\n#' # count GC only\n#' basta.count.coord(fh, c(1, 24), sym=\"GC\")\n#' # count GC in bins\n#' basta.count.coord(fh, c(1, 24), sym=\"GC\", binsize=4)\n#' basta.close(fh)\n#\nbasta.count.coord <- function(handle, coord, \n                              sym=c('A', 'C', 'G', 'T', 'other'),\n                              binsize=diff(range(coord))+1,\n                              case.sensitive=FALSE,\n                              drop=TRUE) {\n\n  if (! exists(\"dontCheck\")) dontCheck <- identity # for R < 3.1\n  \n  .bit.sum <- function(bits, range)\n    .Call(\"R_bit_sum\", bits, as.integer(range), PACKAGE=dontCheck(\"bit\"))\n\n  len <- diff(range(coord))+1\n  seq <- basta.fetch.coord(handle, coord)\n  pos <- seq(from=1, to=len-binsize+1, by=binsize)\n  rst <- if (drop) 0 else len %% binsize\n\n  res <- lapply(sym, function(s) {\n    issym <- bit::bit(len)\n    if (tolower(s) == \"other\") s <- \"!ACGT\"\n    isneg <- substring(s, 1, 1) == \"!\"\n    if (isneg) s <- substring(s, 2)\n    if (! case.sensitive) s <- paste0(tolower(s), toupper(s))\n    issym[lx.strchr(seq, s)] <- TRUE\n    if (isneg) issym <- ! issym\n    res <- sapply(pos, function(p) .bit.sum(issym, c(p, p+binsize-1)))\n    if (rst != 0) res <- c(res, .bit.sum(issym, c(len-rst+1, len)))\n    res\n  })\n  \n  res <- do.call(cbind, res)\n  colnames(res) <- sym\n  \n  if (ncol(res) == 1) as.vector(res) else res\n}\n\n# -------------------------------------------------\n#' fetch symbols counts using relative clocation\n#' @description \n#' fetch sequence thru \\link{basta.fetch.cloc} and\n#' count the number of occurences of symbols specified\n#' in \\code{sym} in contiguous bins of size \\code{binsize}\n#' @param handle basta file handle (as returned by \\link{basta.open})\n#' @param clocation relative clocation = c(seqname, from, to) (1-based)\n#' @param truncate truncate 3' to seq.size if needed\n#' @param sym vector of strings specifying symbols to be counted.\n#' see details.\n#' @param binsize size of bins (defaults to whole sequence)\n#' @param case.sensitive symbols in \\code{sym} are case sensitive\n#' @param drop drop the last window if sequence length is not a muliple\n#'        of binsize\n#' @return a matrix or vector of counts. if \\code{length(sym)==1} returns\n#' a vector of symbol(s) counts for each bin position.\n#' if \\code{length(sym)>1} returns a matrix of symbols counts\n#' with length(sym) columns and each row corresponds to each bin\n#' position.\n#' @details each string in \\code{sym} specifies a set of symbols to be\n#' counted. if this set starts with '!', it means symbols \\bold{not} in\n#' set. As a special case the string \"Other\" is equivalent to \"!ACGT\".\n#' @seealso \\link{basta.count.coord}\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' basta.fetch.cloc(fh, c(1, 1, 24))\n#' # count all DNA symbols\n#' basta.count.cloc(fh, c(1, 1, 24))\n#' # count GC only\n#' basta.count.cloc(fh, c(1, 1, 24), sym=\"GC\")\n#' # count GC in bins\n#' basta.count.cloc(fh, c(1, 1, 24), sym=\"GC\", binsize=4)\n#' basta.close(fh)\n#\nbasta.count.cloc <- function(handle, clocation, truncate=TRUE,\n                              sym=c('A', 'C', 'G', 'T', 'other'),\n                              binsize=clocation[3]-clocation[2]+1,\n                              case.sensitive=FALSE,\n                              drop=TRUE) {\n\n  coord <- cloc2coord(handle, clocation, truncate=truncate)\n  basta.count.coord(handle, coord, sym=sym, binsize=binsize,\n                    case.sensitive=case.sensitive, drop=drop) \n}\n\n# -------------------------------------------------\n#' make clocations spanning all chromosomes\n#' @description\n#' make clocations spanning all chromosomes declared in basta/baf file\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @return nx3 matrix of clocations\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' clocs <- basta2clocs(fh)\n#' basta.close(fh)\n#' \nbasta2clocs <- function(handle) {\n  x <- lapply(handle$header$seq, function(x) c(x$index, 1L, x$size))\n  clocs.matrix(unlist(x, use.names=F))\n}\n\n# -------------------------------------------------\n#' make absolute coordinates spanning all chromosomes\n#' @description\n#' make absolute coordinates spanning all chromosomes\n#' declared in basta/baf file\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @return nx2 matrix of absolute coordinates (1-based)\n#' @note\n#' see \\link{HELP.COORD} for help on coordinates systems\n#' @examples\n#' fh <- basta.open(lx.system.file('samples/test.bst', 'xlx'))\n#' coords <- basta2coords(fh)\n#' basta.close(fh)\n#' \nbasta2coords <- function(handle) {\n  clocs2coords(handle, basta2clocs(handle))\n}\n",
    "created" : 1496096191215.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2924452820",
    "id" : "AB88B27E",
    "lastKnownWriteTime" : 1501927122,
    "last_content_update" : 0,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/xlx/R/xlx.basta.r",
    "project_path" : "R/xlx.basta.r",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}