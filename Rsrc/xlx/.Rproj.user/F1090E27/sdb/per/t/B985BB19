{
    "collab_server" : "",
    "contents" : "# -------------------------------------------------\n# $Id: xlx.regions.r 321 2017-08-18 11:10:19Z viari $\n# Chromosomal regions definition\n#\n\n# =================================================\n# internals <no_export>\n# =================================================\n\n# -------------------------------------------------\n# <internal> <no_export>\n# collect binned gc counts for a single clocation\n# @description\n# return a vector of gc counts in adjacent bins of size binsize\n# @param handle basta of baf file handle\n# @param cloc clocation\n# @param binsize size of bins\n# @return a numerical vector of gccounts\n# @seealso \\link{.bygc.cloc}\n#\n.gc.bin.cloc <- function(handle, cloc, binsize=1000L) {\n  switch(handle$type,\n         basta=basta.count.cloc(handle, cloc, sym=\"GC\",\n                                binsize=binsize, drop=T),\n         baf=baf.bin.cloc(handle, cloc, what=\"gc\", fun=sum,\n                          binsize=binsize, drop=T, na.gc=FALSE),\n        lx.stopif(T, \"invalid file handle type\"))\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# get regions by gc content for a single clocation\n# @description\n# return a vector (possibly empty) of clocations restricted to given gc content.\n# @param handle basta of baf file handle\n# @param cloc clocation to split\n# @param binsize size of bins\n# @param gcrange gc range\n# @param minreg minimum size of resulting regions\n# @param use.threads (see \\link{lx.use.threads})\n# @return a nx3 matrix of (1-based) clocations\n# @seealso \\link{regions.bygc}\n#\n.bygc.cloc <- function(handle, cloc,\n                       binsize=1000L, gcrange=c(0.0, 1.0),\n                       minreg=binsize) {\n  \n  # default result : empty regions\n  #\n  regions <- clocs.matrix(NULL)\n  \n  cloclen <- cloc[3]-cloc[2]+1\n  \n  if (cloclen < min(binsize, minreg))\n    return(regions)\n\n  # get binned gc counts\n  #\n  gcnt <- .gc.bin.cloc(handle, cloc, binsize)\n\n  pos  <- seq.int(from=1, to=cloclen-binsize+1, by=binsize)\n\n  # filter gc regions\n  #\n  gcrange <- gcrange * binsize\n  pos <- pos[(gcnt >= gcrange[1]) & (gcnt <= gcrange[2])]\n  \n  # convert to clocations\n  #\n  regions <- if (length(pos) > 0) cbind(cloc[1], pos, pos + binsize - 1) else NULL\n  regions <- clocs.threshold(clocs.matrix(regions), minsize=minreg, use.threads=FALSE)\n  \n  regions\n}\n\n# -------------------------------------------------\n# <internal> <no_export>\n# get regions by gc content strata for a single clocation\n# @description\n# stratify adjacent bins of size binsize by their gc content.\n# return a vector of regions stratified by gc content.\n# @param handle basta or baf file handle\n# @param cloc clocation to stratify \n# @param binsize window size to compute gc content\n# @param nstrata number of %gc strata (strata go from 0. to 1. by 1/nstrata)\n# @param minreg minimum size of resulting regions\n# @return a vector of size nstrata. each element is a nx3 matrix of (1-based) clocations\n# @seealso \\link{regions.strata.bygc}\n#\n.strata.bygc.cloc <- function(handle, cloc,\n                              binsize=1000L, nstrata=10L,\n                              minreg=binsize) {\n\n  # default result : empty regions\n  #\n  bylevel <- rep(list(NULL), nstrata)\n  names(bylevel) <- as.character(seq.int(nstrata))\n  \n  cloclen <- cloc[3]-cloc[2]+1\n  \n  if (cloclen < binsize) \n    return(bylevel)\n\n  \n  # get gc counts and convert to levels in range 1:nstrata\n  #\n  gcnt <- .gc.bin.cloc(handle, cloc, binsize)\n  gcnt <- pmin(nstrata, round(gcnt / binsize * nstrata) + 1)\n  \n  pos <- seq.int(from=1, to=cloclen-binsize+1, by=binsize)\n  \n  # split window start position by levels\n  #\n  pos <- pos + cloc[2] - 1\n  pos <- split(pos, gcnt)\n  bylevel[names(pos)] <- pos\n  \n  # convert to clocations\n  #\n  lapply(bylevel, function(lpos) {\n    lpos <- if (is.null(lpos)) NULL else cbind(cloc[1], lpos, lpos + binsize - 1)\n    clocs.threshold(clocs.matrix(lpos), minsize=minreg, use.threads=FALSE)\n  })\n}\n\n\n# =================================================\n# API\n# =================================================\n\n# -------------------------------------------------\n#' get user's defined regions from bed files\n#' @description \n#' loop over provided bed files, intersect their regions, filter out\n#' small regions and returns clocations.\n#' @param handle basta/baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open})\n#' @param filenames a character vector of filenames\n#' @param init regions (clocations) to start with (default is regions spanning all chromosomes)\n#' @param minreg minimum region size (see \\link{clocs.inter})\n#' @param check check that region boundaries are correct (see \\link{bed2clocs})\n#' @param file.stop boolean, stops if a bed file is not found\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a nx3 matrix of (1-based) clocations\n#' @note\n#' the function also checks if each file exists and will skip over \n#' or stop on non-existing file(s)\n#' @seealso \\link{bed.read}, \\link{bed2clocs} and \\link{basta2clocs}\n#' @examples\n#' fh <- basta.open(lx.system.file(\"samples/test.bst\", \"xlx\"))\n#' bedfile <- lx.system.file(\"samples/test.bed\", \"xlx\")\n#' clocs <- regions.bybed(fh, bedfile)\n#' # this is the same as:\n#' clocs2 <- clocs.reduce(bed2clocs(fh, bed.read(bedfile)))\n#' #\n#' identical(clocs, clocs2)\n#' basta.close(fh)\n#'\nregions.bybed <- function(handle, filenames, init=basta2clocs(handle),\n                          minreg=1L, check=TRUE, file.stop=FALSE,\n                          use.threads=lx.use.threads()) {\n\n  clocs <- init\n\n  lx.out(\"getting user's regions\") \n  # loop over filenames\n  for (bedfile in filenames) {\n    if (file.exists(bedfile)) {\n      lx.out(\"reading bedfile: \", bedfile)\n      bedclocs <- bed2clocs(handle, bed.read(bedfile), check=check)\n      clocs <- clocs.inter(clocs, bedclocs, minsize=minreg,\n                           use.threads=use.threads)\n    }\n    else {\n      lx.stopif(file.stop, \"bedfile not found: \", bedfile)\n      lx.out(\"skipping bedfile: \", bedfile, level=\"warning\")\n    }\n  }\n\n  clocs\n}\n\n# -------------------------------------------------\n#' get binned coverage in regions\n#' @description\n#' loop over given \\code{regions}\n#' and collect mean coverage in adjacent windows of size \\code{binsize}.\n#' @param handle baf file handle (as returned by \\link{baf.open})\n#' @param regions clocations regions to bin (default is regions spanning\n#' all chromosomes)\n#' @param binsize size of bins\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a list of length nrow(regions), each element is a numerical\n#' vector of mean coverage in adjacent windows of size \\code{binsize}\n#' in the region.\n#' @examples\n#' baf <- baf.open(lx.system.file(\"samples/test.baf\", \"xlx\"))\n#' x <- regions.bincover(baf, binsize=1000, use.threads=FALSE)\n#' baf.close(baf)\n#' @seealso \\link{regions.bycover.range}, \\link{regions.bycover.band}\n#'\nregions.bincover <- function(handle, regions=baf2clocs(handle),\n                             binsize=10000L,\n                             use.threads=lx.use.threads()) {\n\n  # compute bins\n  lx.out(\"computing binned coverage on \", nrow(regions),\" regions\")\n  bins <- apply.cloc(regions, function(cloc, handle, binsize) {\n            baf.bin.cloc(handle, cloc, binsize=binsize, what=\"cover\",\n                         fun=mean, drop=TRUE, .quick=!use.threads)\n          },\n          handle=handle, binsize=binsize,\n          keep.order=TRUE,\n          use.threads=use.threads)\n\n  # keep chr index as names (may not be unique)\n  names(bins) <- regions[,1]\n\n  bins\n}\n\n# -------------------------------------------------\n#' select regions in range of coverage\n#' @description\n#' loop over given \\code{init} regions.\n#' foreach of them keep regions with mean coverage \n#' in range [mincover, maxcover].\n#' @param handle baf file handle (as returned by \\link{baf.open})\n#'        (ignored if \\code{bins} is provided)\n#' @param init clocations regions to start with (default is regions spanning all\n#'        chromosomes). if \\code{bins} is provided \\code{init} should be the\n#'        regions used to compute bins (thru \\link{regions.bincover}).\n#' @param bins list (of length \\code{nrow(init)}) of binned coverage in regions\n#'        (as returned by \\link{regions.bincover}).\n#'        if NULL this will be computed using \\link{regions.bincover} with\n#'        same parameters. (see notes)\n#' @param binsize size of bins\n#' @param mincover minimum coverage (default 0)\n#' @param maxcover maximum coverage (default +Inf).\n#' @param minreg minimum region size (should be >= binsize)\n#' @param keep.bins if TRUE, \\code{bins, binsize and binrange} are kept as\n#'        attributes in the result (set to FALSE to save memory)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a nx3 matrix of (1-based) clocations\n#' @note the \\code{bins} != NULL form is provided to avoid recomputation and\n#' is mostly used internally (by \\link{regions.bycover.band}).\n#' @examples\n#' baf <- baf.open(lx.system.file(\"samples/test.baf\", \"xlx\"))\n#' x <- regions.bycover.range(baf, binsize=1000, mincover=1)\n#' y <- attr(x, \"binsize\")\n#' baf.close(baf)\n#' @seealso \\link{regions.bycover.band}\n#'\nregions.bycover.range <- function(handle, init=baf2clocs(handle),\n                             bins=NULL,\n                             binsize=10000L,\n                             mincover=0, maxcover=Inf,\n                             minreg=binsize,\n                             keep.bins=TRUE,\n                             use.threads=lx.use.threads()) {\n  \n  # compute binned mean coverage\n  #\n  if (is.null(bins))\n    bins <- regions.bincover(handle, init, binsize, use.threads)\n  \n  lx.stopif(length(bins) != nrow(init), \"bins and init are of incompatible size\")\n\n  # get regions with valid counts\n  #\n  lx.out(\"gathering \", length(bins), \" regions within counts range [\",\n         format(mincover, digits=2, nsmall=2), \", \", \n         format(maxcover, digits=2, nsmall=2), \"]\")\n\n  res <- lx.lapply(seq_along(bins), function(i) {\n    bin  <- bins[[i]]\n    cloc <- init[i,]\n    isok <- bit::as.bit((bin >= mincover) & (bin <= maxcover))\n    runs2clocs(isok, chr=cloc[1], minsize=minreg, p0=cloc[2], delta=binsize)\n  }, use.threads=use.threads,\n     mc.preschedule=TRUE)\n\n  res <- clocs.rbind(res)\n  \n  # keep selection bins as attribute\n  #\n  attr(res, \"binsize\")   <- binsize\n  attr(res, \"binpos\")    <- (mincover + maxcover) / 2\n  attr(res, \"binrange\")  <- c(mincover, maxcover)\n  if (keep.bins)\n    attr(res, \"bins\") <- bins\n\n  res\n}\n\n# -------------------------------------------------\n#' select regions in band of coverage distribution\n#' @description\n#' compute the distribution of (mean) coverage in all \\code{init} regions,\n#' select a band in this distribution according to different\n#' models (see details).\\cr\n#' then loop over given \\code{init} regions.\n#' foreach of them keep regions with coverage in that band.\n#' @details\n#' let us call \\code{dist} is the distribution of coverage in all bins of\n#' size \\code{binsize}.\\cr\n#' the band of coverage [a, b] is defined by (a combination of) various models,\n#' specified by the following formula:\\cr\\cr\n#' \\code{ [alpha1 '*'] model1 ['+'|'-' [alphan '*'] modeln]*}\\cr\\cr\n#' where:\\cr\n#' \\itemize{\n#' \\item model=\"median\": (a,b)=median(dist)-/+alpha*mad(dist)\n#' \\item model=\"poisson\": (a,b)=mode(dist)+/-alpha*sqrt(mode(dist))\\cr\n#' where mode(dist) is the coverage value associated to the largest maximum\n#' of the distribution. this model correspond roughly to a poisson distributed\n#' coverage (when coverage is large enough).\n#' \\item model=\"peak\": a=pos-alpha*left; b=pos+alpha*right\\cr\n#' where pos, left and right are the maximum peak parameters returned\n#' by \\link{lx.peaks}.\n#' \\item model=\"twin\": a=pos-alpha*(pos-pos.left)/2; b=pos+alpha*(pos.right-pos)/2\\cr\n#' where pos, pos.left, pos.right are respectively the maximum peak position,\n#' the immediately left and right maxima, as returned\n#' by \\link{lx.maxima}.\n#' \\item model=<name>: a and b are defined by a user-provided function called\n#' as .band.name(bins, alpha, ...) that should returns c(a, b)\n#' }\n#' in the previous formula, models are evaluated from left to right, each returning\n#' an interval (band) that are further combined in the following way:\\cr\n#' \\code{[a,b] + [c,d] = [min(a,c), max(b,d)]} (extension)\\cr\n#' \\code{[a,b] - [c,d] = [max(a,c), min(b,d)]} (reduction)\n#' \n#' @param handle baf file handle (as returned by \\link{baf.open})\n#'        (ignored if \\code{bins} is provided)\n#' @param init clocations regions to start with (default is regions spanning all\n#'        chromosomes). if \\code{bins} is provided it should be the regions\n#'        used to compute bins (thru \\link{regions.bincover}).\n#' @param binsize size of bins\n#' @param model model formula (see details).\n#' @param smooth.k k parameter to \\link{lx.smooth.median} to smooth bins before\n#'        computing distribution. (use NULL or 0 to disable smoothing)\n#' @param minreg minimum region size (should be >= binsize)\n#' @param keep.bins if TRUE, \\code{bins} are kept as\n#'        attributes in the result (set to FALSE to save memory)\n#' @param ... additional parameters to user-defined function if specified\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a nx3 matrix of (1-based) clocations\n#' @note result also contains bins (and smoothed bins) statistics\n#' such as range, mode and density.\\cr\\cr\n#' if \\code{smooth.k != 0} then regions selection is performed\n#' on smoothed bins.\\cr\\cr\n#' the smoothing is performed on the concatenation of all regions,\n#' therefore ignoring chromosomes and regions boundaries. this will be\n#' improved in the future.\n#' @examples\n#' baf <- baf.open(lx.system.file(\"samples/test.baf\", \"xlx\"))\n#' x <- regions.bycover.band(baf, binsize=1000, smooth.k=3)\n#' x <- regions.bycover.band(baf, binsize=1000, smooth.k=0, model=\"twin - 4 * poisson\")\n#' y <- attr(x, \"binsize\")\n#' baf.close(baf)\n#' @seealso \\link{regions.bycover.range}\n#'\nregions.bycover.band <- function(handle, init=baf2clocs(handle),\n                             binsize=10000L,\n                             model=\"poisson\",\n                             smooth.k=c(3L, 5L, 15L, 35L, 55L),\n                             minreg=binsize,\n                             keep.bins=TRUE,\n                             ...,\n                             use.threads=lx.use.threads()) {\n\n  # ------------------------\n  # internal utilities\n  \n  # internal cleanup\n  .clean <- function(bins) {\n    bins <- unlist(bins, use.names=FALSE)\n    bins[bins != 0]  # remove 0 counts\n  }\n  \n  # internal band models\n  .band.median <- function(bins, alpha, ...) {\n    bins     <- .clean(bins)\n    bins.med <- median(bins)\n    bins.mad <- mad(bins, center=bins.med)\n    bins.min <- floor(max(0, bins.med - (alpha*bins.mad)))\n    bins.max <- ceiling(bins.med + (alpha*bins.mad))\n    band <- c(bins.min, bins.max)\n    attr(band, \"model\") <- \"median\"\n    attr(band, \"binpos\") <- bins.med\n    band\n  }\n  \n  .band.poisson <- function(bins, alpha, ...) {\n    bins      <- .clean(bins)\n    bins.dens <- lx.density(bins, n=1024)\n    bins.pos  <-  bins.dens$x[lx.maxima(bins.dens$y, span=0)[[1]]]\n    bins.min  <-  max(0, bins.pos - (alpha*sqrt(bins.pos)))\n    bins.max  <-  bins.pos + (alpha*sqrt(bins.pos))\n    band <- c(bins.min, bins.max)\n    attr(band, \"model\") <- \"poisson\"\n    attr(band, \"binpos\") <- bins.pos\n    band\n  }\n  \n  .band.peak <- function(bins, alpha, ...) {\n    bins      <- .clean(bins)\n    bins.dens <- lx.density(bins, n=1024)\n    bins.peak <- lx.peaks(bins.dens$y, span=0, eps.x=0.1, na.val=100)\n    bins.pos  <- bins.dens$x[bins.peak$pos[[1]]]\n    bins.min  <- bins.dens$x[bins.peak$left[[1]]]\n    bins.max  <- bins.dens$x[bins.peak$right[[1]]]\n    bins.min  <- max(0, bins.pos - (bins.pos-bins.min)*alpha)\n    bins.max  <- bins.pos + (bins.max-bins.pos)*alpha\n    band <- c(bins.min, bins.max)\n    attr(band, \"model\") <- \"peak\"\n    attr(band, \"binpos\") <- bins.pos\n    band\n  }\n  \n  .band.twin <- function(bins, alpha, ...) {\n    bins      <- .clean(bins)\n    bins.dens <- lx.density(bins, n=1024)\n    bins.peak <- lx.peaks(bins.dens$y, span=0, eps.x=0.1, na.val=100)\n    bins.pos <- bins.dens$x[bins.peak$pos[1]]\n    \n    delta <- bins.peak$pos[1] - bins.peak$pos\n    delta[delta <= 0] <- Inf\n    imin <- which.min(delta)\n    imin <- if (is.infinite(delta[imin])) 1 else bins.peak$pos[imin]\n    bins.min <- bins.dens$x[imin]\n    bins.min <- max(0, bins.pos - (bins.pos - bins.min)*alpha/2)\n    \n    delta <- bins.peak$pos - bins.peak$pos[1]\n    delta[delta <= 0] <- Inf\n    imin <- which.min(delta)\n    imin <- if (is.infinite(delta[imin])) length(bins.dens$x) else bins.peak$pos[imin]\n    bins.max <- bins.dens$x[imin]\n    bins.max <- bins.pos + (bins.max - bins.pos)*alpha/2\n    \n    band <- c(bins.min, bins.max)\n    attr(band, \"model\") <- \"twin\"\n    attr(band, \"binpos\") <- bins.pos\n    band\n  }\n  \n  # band combination\n  .combine.plus  <- function(b1, b2) c(pmin(b1, b2)[1], pmax(b1, b2)[2])\n  .combine.minus <- function(b1, b2) c(pmax(b1, b2)[1], pmin(b1, b2)[2])\n  \n  # model parser + caller\n  .call.formula <- function(form, bins, ...) {\n    form <- gsub(\"[[:blank:]]+\",\"\", form)\n    split.form <- lx.strsplit(form, \"\\\\+|-\")\n    \n    oper <- head(cumsum(sapply(split.form, nchar, USE.NAMES=F))\n                 + seq_along(split.form), -1)\n    oper <- c(\"-\", sapply(oper, function(p) substr(form, p, p)))\n    oper <- gsub(\"-\", \"minus\", gsub(\"\\\\+\", \"plus\", oper))\n    \n    fun  <- sapply(lapply(split.form, function(s) lx.strsplit(s, \"\\\\*\")), \n                  function(s) if (length(s) == 1) c(1,s) else s)\n    \n    res <- apply(fun, 2, function(x)\n            do.call(get(paste0(\".band.\", x[2])),\n                    list(bins, alpha=as.integer(x[1]), ...)))\n\n    res <- Reduce(function(p, i) \n              do.call(paste0(\".combine.\", oper[i]), list(p, res[,i])),\n              1:ncol(res), c(-Inf, Inf))\n    res\n  }\n  \n  \n  # ------------------------\n  # function body\n  \n  # compute binned counts\n  #\n  bins <- regions.bincover(handle, init, binsize, use.threads)\n\n  # smooth if requested\n  #\n  smoothed <- ! (is.null(smooth.k) || all(smooth.k==0))\n  \n  if (smoothed) {\n    flat.bins <- lx.smooth.median(unlist(bins, use.names=F), k=smooth.k)\n    lens.bins <- sapply(bins, length)\n    smooth.bins <- split(flat.bins, rep.int(seq_along(bins), lens.bins)) \n    names(smooth.bins) <- names(bins)\n    sel.bins <- smooth.bins\n  } else {\n    sel.bins <- bins\n  }\n\n  # get and call band function\n  #\n  band <- tryCatch(.call.formula(model, sel.bins, ...),\n                   error=function(e) lx.stopif(T, \"invalid formula: \", model, \n                                               \" \", e$message))\n  \n  lx.stopif(band[1] > band[2], \"invalid cover band \", band)\n\n  # filter regions\n  #\n  res <- regions.bycover.range(handle, init, sel.bins, binsize,\n                                band[[1]], band[[2]], minreg, keep.bins,\n                                use.threads)\n  \n  # keep attributes\n  #\n    \n  # copy band attributes\n  for (att in setdiff(names(attributes(band)), \"names\"))\n    attr(res, att) <- attr(band, att, exact=T)\n  \n  # add new attributes\n  if (keep.bins)\n    attr(res, \"bins\") <- bins\n  attr(res, \"bindens\") <- lx.density(.clean(bins), n=1024)\n  \n  if (smoothed) {\n    attr(res, \"smooth.k\") <- smooth.k\n    if (keep.bins)\n      attr(res, \"smooth.bins\") <- smooth.bins\n    attr(res, \"smooth.dens\") <- lx.density(.clean(smooth.bins), n=1024)\n  }\n\n  res\n}\n\n# -------------------------------------------------\n#' get regions with only [agct] symbols\n#' @description\n#' loop over given \\code{init} regions.\n#' foreach of them keep regions containing only a,c,g or t's.\\cr\n#' @param handle basta file handle (as returned by \\link{basta.open})\n#' @param init regions to start with (default is regions spanning all chromosomes)\n#' @param minreg minimum region size\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a nx3 matrix of (1-based) clocations\n#' @examples\n#' fh <- basta.open(lx.system.file(\"samples/test.bst\", \"xlx\"))\n#' x <- regions.byacgt(fh, minreg=1, use.threads=FALSE)\n#' basta.close(fh)\n#'\nregions.byacgt <- function(handle, init=basta2clocs(handle),\n                           minreg=10000L,\n                           use.threads=lx.use.threads()) {\n\n  # compute regions\n  lx.out(\"computing acgt on regions\")\n  res <- apply.cloc(init, function(cloc, handle) {\n              seq <- basta.fetch.cloc(handle, cloc)\n              isok <- bit::bit(nchar(seq))\n              isok[lx.strchr(seq, \"ACGTacgt\")] <- TRUE\n              seq <- NULL\n              runs2clocs(isok, cloc[1], minsize=minreg, p0=cloc[2]) \n            },\n            handle=handle,\n            use.threads=use.threads)\n\n  clocs.rbind(res)\n}\n\n# -------------------------------------------------\n#' get regions with specified gc content\n#' @description\n#' loop over given \\code{init} regions.\n#' foreach of them keep regions of specified %gc.\\cr\n#' @details there is a slight difference in the way the gc content is computed\n#' depending whether you pass a basta or baf file handle.\\cr\n#' if a basta file handle is provided then the gc content is computed\n#' on the basis of the reference genome.\\cr\n#' if a baf file handle is provided then the gc content is computed\n#' on the basis of the actual observed alleles (see \\link{baf.bin.cloc}).\n#' note that this may lead to 0 counts in region with no mapping.\\cr\n#' basta mode is (about 10 times) quicker than baf mode.\n#' @param handle basta or baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open}). see details\n#' @param init regions to start with (default is regions spanning all chromosomes)\n#' @param winsize window size to compute gc content\n#' @param gcrange percent gc range (should be in [0, 1])\n#' @param minreg minimum final region size (should be >= winsize)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a nx3 matrix of (1-based) clocations\n#' @examples\n#' fh <- basta.open(lx.system.file(\"samples/test.bst\", \"xlx\"))\n#' x <- regions.bygc(fh, winsize=3, gcrange=c(0., 0.5))\n#' basta.close(fh)\n#' @seealso \\link{regions.strata.bygc} for a stratified version\n#'\nregions.bygc <- function(handle, init=basta2clocs(handle),\n                         winsize=1000L, gcrange=c(0.0, 1.0),\n                         minreg=winsize,\n                         use.threads=lx.use.threads()) {\n  \n  lx.out(\"filtering regions by gc in [\", gcrange[1], \", \", gcrange[2], \"]\")\n  res <- apply.cloc(init, function(cloc, handle) {\n    .bygc.cloc(handle, cloc, binsize=winsize,\n               gcrange=gcrange, minreg=minreg)\n  }, handle=handle, use.threads=use.threads)\n\n  Reduce(rbind, res[-1], res[[1]])\n}\n\n# -------------------------------------------------\n#' stratify regions by gc content\n#' @description\n#' stratify subregions from \\code{init} regions into gc content\n#' @details there is a slight difference in the way the gc content is computed\n#' depending whether you pass a basta or baf file handle.\\cr\n#' if a basta file handle is provided then the gc content is computed\n#' on the basis of the reference genome.\\cr\n#' if a baf file handle is provided then the gc content is computed\n#' on the basis of the actual observed alleles (see \\link{baf.bin.cloc}).\n#' note that this may lead to 0 counts in region with no mapping.\\cr\n#' basta mode is (about 10 times) quicker than baf mode.\n#' @param handle basta or baf file handle (as returned by \\link{basta.open}\n#' or \\link{baf.open}). see details\n#' @param init regions to start with (default is regions spanning all chromosomes)\n#' @param winsize window size to compute gc content\n#' @param nstrata number of \\%gc strata (strata go from 0. to 1. by 1/nstrata)\n#' @param minreg minimum final region size (should be >= winsize)\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a vector of size nstrata. each element is a nx3 matrix of (1-based) clocations\n#' @examples\n#' fh <- basta.open(lx.system.file(\"samples/test.bst\", \"xlx\"))\n#' x <- regions.strata.bygc(fh, winsize=3)\n#' basta.close(fh)\n#' @seealso \\link{regions.bygc} for a non stratified version\n#' \nregions.strata.bygc <- function(handle, init=basta2clocs(handle),\n                         winsize=1000L, nstrata=5L, minreg=winsize,\n                         use.threads=lx.use.threads()) {\n  \n  lx.out(\"stratifying regions by gc\")\n  res <- apply.cloc(init, function(cloc, handle) {\n    .strata.bygc.cloc(handle, cloc, binsize=winsize,\n                      nstrata=nstrata, minreg=minreg)\n  }, handle=handle, use.threads=use.threads)\n  \n  # sum up by strata\n  #\n  res <- do.call(mapply, c(rbind, res))\n  \n  # rename strata\n  #\n  names(res) <- sprintf(\"%.2f\", (seq.int(nstrata) - 1) / nstrata)\n  res\n}\n\n# -------------------------------------------------\n#' trim regions\n#' @description\n#' remove \\code{trim} on both sides of regions\n#' and keep only regions whose size is >= minreg\n#' @param regions regions to trim\n#' @param trim size to remove on both ends\n#' @param minreg minimum final region size (should be >= trim)\n#' @return a nx3 matrix of (1-based) clocations\n#'\nregions.trim <- function(regions, trim=1000L, minreg=10000L) {\n\n  regions[,2] <- regions[,2] + trim\n  regions[,3] <- regions[,3] - trim\n  \n  regions <- regions[regions[,2]<=regions[,3],,drop=FALSE]\n\n  clocs.threshold(regions, minsize=minreg)\n}\n\n# -------------------------------------------------\n#' exclude locations from regions\n#' @description\n#' remove locations (+/- margin) from regions\n#' and keep only regions whose size is >= minreg\n#' @param handle basta or baf file handle (as returned by \\link{basta.open} \n#' or \\link{baf.open}\n#' @param coords nx2 matrix of absolute coordinates (1-based) or\n#'        vector of n absolute point coordinates to remove\n#' @param init regions to start with (default is regions spanning all chromosomes)\n#' @param spaceleft size to remove on left side of coords\n#' @param spaceright size to remove on right side of coords\n#' @param minreg minimum final region size\n#' @param use.threads (see \\link{lx.use.threads})\n#' @return a nx3 matrix of (1-based) clocations\n#'\nregions.exclude <- function(handle, coords, init=basta2clocs(handle),\n                            spaceleft=0L, spaceright=spaceleft, minreg=1L,\n                            use.threads=lx.use.threads()) {\n\n  ncols <- ncol(coords)\n  if ( is.null(ncols) || (ncols < 2))\n    coords <- cbind(coords, coords)\n\n  clocs <- coords2clocs(handle, coords)\n  clocs[,2] <- min(1, clocs[,2]-spaceleft)\n  clocs[,3] <- clocs[,3]+spaceright\n  clocs.inter(init, clocs, minsize=minreg,\n              use.threads=use.threads)\n}\n\n\n",
    "created" : 1495741541994.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2122289524",
    "id" : "B985BB19",
    "lastKnownWriteTime" : 1503054619,
    "last_content_update" : 1503054619,
    "path" : "~/Developpements/SvnProjects/WGInR_Asdog/Rsrc/xlx/R/xlx.regions.r",
    "project_path" : "R/xlx.regions.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}