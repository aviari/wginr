% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mdb.swiss.r
\name{mdb.swiss.read}
\alias{mdb.swiss.read}
\title{read swissprot db}
\usage{
mdb.swiss.read(pathname, extra = "ALL")
}
\arguments{
\item{pathname}{pathname of uniprot file to read}

\item{extra}{string comma-separated list of additional lines to parse (e.g "DE,OS,OC,KW")\cr
if empty only the default ID, AC, and seq (sequence) lines are parsed\cr
if "ALL" then all keys are parsed}
}
\value{
a list indexed by records primary AC\cr
        each element is a list indexed by the record key (sequence is indexed by 'seq')\cr
        each recordkey element is either the raw line(s) or the result of a specific parser\cr
        current parsers are provided for : AC, OC, KW, DR (see note)\cr
}
\description{
read swissprot db and parse ID,AC,seq + extra fields as requested
}
\note{
you may add your own function \code{.mdb.swiss.parse.<key>(rec)}
to parse other keys than (AC, OC, KW, DR and seq).\cr
\code{rec} is a string containing all lines of the current record 
to be parsed (with newlines as \\n) and your function may return whatever
is appropriate (usually a list).\cr

the uniprot file may be provided in plain text or gzipped format. this is checked
automaticaly, there is no need to add the .gz extension.
}
\examples{

db <- mdb.swiss.read(lx.system.file("samples/test_swiss.dat", "xlx"))

# get entry names
names(db)

# get info about specific entry :
db$P04395
db$P04395$OC
db$P04395$DR$PROSITE

# search for entries matching pattern :
mdb.find(db, "KW", "gluconate", ignore.case=TRUE)

dc <- mdb.swiss.read(lx.system.file("samples/test_swiss_compressed.dat", "xlx"))
identical(db, dc)

}
\seealso{
\code{\link{mdb.swiss.load}}
}
