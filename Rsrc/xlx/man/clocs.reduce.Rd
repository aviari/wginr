% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xlx.coords.r
\name{clocs.reduce}
\alias{clocs.reduce}
\title{compactly re-represent clocations}
\usage{
clocs.reduce(clocations, minsize = 1L, use.threads = lx.use.threads())
}
\arguments{
\item{clocations}{nx3 matrix of relative clocations (1-based)}

\item{minsize}{minimum interval width. all resulting intervals
strictly smaller than \code{minsize} are discarded.}

\item{use.threads}{(see \link{lx.use.threads})}
}
\description{
a set of clocations represents intervals on chromosomes.
in general these intervals may overlap (partially or completely)
or may be strictly adjacent.
this function computes the union of all intervals on each
chromosome. This will produce (strongly) disjoint intervals
(see \link{clocs.is.disjoint}) corresponding to the most compact
representation of the input set of intervals. It also sorts the resulting
clocations by increasing chromosome index, from and to positions.
Finally only intervals above a specified width are retained.
}
\note{
this is formally equivalent (and actually implemented as):\cr
\code{clocs.join(clocations, delta=0L, minsize=minsize, use.thread=use.thread)}\cr
this function has been kept for historical reasons
(and to keep open the possibility
of a more efficient version in the future).

\code{clocs.reduce(x)} is formally equivalent to \code{clocs.inter(x,x)}
but much more efficient.
}
\examples{
clocs <- clocations(c(1,1,10, 1,11,20, 1,20,30, 1,40,50, 1,60,70, 1,70,80, 1,90,100, 2,1,10))
clocs.reduce(clocs)
clocs <- clocs.rbind(list(clocs, c(1,1,100)))
clocs.reduce(clocs)
clocs.reduce(NULL)

}
\seealso{
\link{clocs.join}, \link{clocs.inter}
}
