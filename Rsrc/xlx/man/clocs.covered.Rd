% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xlx.coords.r
\name{clocs.covered}
\alias{clocs.covered}
\title{assess coverage from one set of clocations by another}
\usage{
clocs.covered(clocations, cover, use.threads = lx.use.threads())
}
\arguments{
\item{clocations}{nx3 matrix of clocations to be tested.}

\item{cover}{nx3 matrix of clocations to search in}

\item{use.threads}{(see \link{lx.use.threads})}
}
\value{
logical vector of length nrow(clocations)
}
\description{
this is a variant of \link{clocs.included} which test if clocations
from the first set are fully covered by one or more intervals in the second
set.
}
\details{
this is almost functionaly equivalent to
\code{clocs.included(clocations, clocs.reduce(cover))}.
i.e. the second set is first reduced (see \link{clocs.reduce}) to
disjoint intervals then the inclusion test (see \link{clocs.included})
is performed. But it is implemented in a more efficient way, especially
when \code{cover} is already disjoint.\cr
the main difference is that \link{clocs.included} keeps row order from
\code{clocations} whereas this implementation reorder rows in the result
for efficiency.
}
\note{
if \code{cover} is already disjoint, this is equivalent to
\link{clocs.included} but much more efficient.
}
\examples{
c1 <- clocations(c(1,1,10))
c2 <- clocations(c(1,1,5, 1,6,10))
clocs.covered(c1, c2)
clocs.covered(c2, c1)
c1 <- clocations(c(1,1,10, 1,20,30, 2,10,20))
c2  <- clocations(c(1,1,20, 1,25,30))
clocs.covered(c1, c2)
clocs.covered(c2, c1)
clocs.covered(c1, NULL)
clocs.covered(NULL, NULL)
# the difference with clocs.covered is in the reduction of the second argument
c1 <- clocations(c(1,20,30))
c2 <- clocations(c(1,1,25, 1,25,40))
clocs.covered(c1, c2)
clocs.included(c1, c2)
clocs.included(c1, clocs.reduce(c2))

}
\seealso{
\link{clocs.included}, \link{clocs.reduce}, \link{clocs.overlap}
}
